# 15. 파일 시스템 내부 구조(File-system internals)

- (13장) 파일 시스템은 데이터와 프로그램을 포함한 파일 내용에 대한 온라인 저장 및 접근 기법을 제공한다
- 이번 장은 주로 파일 시스템의 내부구조와 작동에 관한 것이다
  - 파일 사용을 구성하고
  - 저장 공간을 할당하고
  - 해제된 공간을 복구하고
  - 데이터 위치를 추적하고
  - 운영체제의 다른 부분과 보조저장장치를 상호 연결하는 방법을 자세히 살펴본다

#### 이 장의 목표

- 파일 시스템과 구현의 세부 사항에 대해 자세히 설명한다
- 부팅 및 파일 공유에 대해 탐구한다
- NFS를 예로 사용하여 원격 파일 시스템을 설명한다

## 15.1 파일 시스템 (File Systems)

- 컴퓨터 시스템에는 여러 저장장치가 있을 수 있다
- 컴퓨터 시스템은 또한 다양한 개수의 파일 시스템을 가질 수 있다

#### 그림 15.1 전형적인 파일 시스템의 구성

- 볼륨1, 2 > 파티션A, B > {디렉터리, 파일} => 저장 장치 1

#### 그림 15.2 Solaris 파일 시스템

- Solaris 파일 시스템
  - / : ufs
  - /tmp : tmpfs
  - /system/object : objfs
  - /system/contract : ctfs
  - / opt : ufs
  - /lib/libc.so.1 : lofs
  - /proc : procfs
- tmpfs : 휘발성 메인 메모리에 생성되고 시스템이 재부팅되거나 고장 났을 때 파일 시스템의 내용이 지워지는 "임시" 파일 시스템
- objfs : 디버거가 커널 심볼을 접근할 수 있게 하는 "가상" 파일 시스템
  - 실제로는 파일 시스템으로 보이는 커널 인터페이스
- ctfs : 시스템이 부트될 때 시작하여 운영체제가 실행되는 동안 실행되어야 하는 프로세스를 관리하기 위한 "contract" 정보를 저장하기 위한 가상 파일 시스템
- lofs : 한 파일 시스템 대신에 다른 파일 시스템에 접근할 수 있게 하는 "loop back" 파일 시스템
- procfs : 모든 프로세스에 관한 정보를 파일 시스템 형태로 보여주는 가상 파일 시스템
- ufs, zfs : 범용 파일 시스템

## 15.2 파일 시스템 마운팅(File System Mounting)

- 파일 시스템은 프로세스들에 의해 사용되기 전에 마운트 되어야 한다
- 디렉터리 구조는 다양한 볼륨으로 만들어 질 수 있는데, 각 파티션들이 마운트되어야 파일 시스템 네임 스페이스 안에서 이용 가능하다

- 마운트 과정
  - 운영체제에서 장치 이름과 마운트 포인트(파일시스템을 부착할 수 있는 파일 구조 내의 위치)를 준다
    - 일반적으로 마운트 포인트는 마운트되는 파일 시스템이 부착될 비어있는 디렉터리이다
  - 몇몇 운영체제는 파일 시스템의 유형이 제공되어야 하고, 다른 운영체제는 장치의 구조를 검사하여 파일 시스템의 유형을 결정한다
  - 운영체제는 장치가 유효한 파일 시스템을 포함하는지 확인한다
  - 운영체제는 파일 시스템이 지정된 마운트 포인트에 마운트되었음을 디렉터리 구조에 기록한다
- 이 기법은 운영체제가 디렉터리 구조를 순회하고 파일 시스템을 적절히 전환할 수 있게 하고
  - 심지어 파일 시스템의 유형도 필요에 따라 적절히 전환할 수 있게 한다

#### 그림 15.3 파일 시스템. 기존 파일 시스템, 마운트되지 않은 볼륨

- 파일 마운팅 설명
- 마운트된 볼륨에만 접근이 가능하다
  - 파티션이 언마운트되면 파일 시스템은 다시 그림 15.3에 보인 상황으로 복원된다
- 시스템은 기능을 명확하게 나타내기 위해 의미(semantic)를 부여한다
- 예를 들어, 시스템은 파일을 포함하고 있는 디렉터리에 대해 마운트를 허가하지 않거나
  - 또는 마운트된 파일 시스템만 그 디렉터리에서 사용할 수 있게 하고 기존 파일들은 언마운트될 때 까지 사용할 수 없게 만들 수 있다
  - 언마운트 후에는 마운트되었던 파일 시스템은 사용이 끝나고 기존 파일들이 다시 사용 가능해진다
- 다른 예로, 어떤 시스템은 다른 마운트 포인트에 같은 파일 시스템을 반복적으로 마운트하는 것을 허용하거나

  - 파일 시스템당 한 번의 마운트를 허용할 수 있다

#### macOS 운영체제

- 시스템이 디스크를 처음 발견하면 macOS 운영체제는 장치에 존재하는 파일 시스템을 검색한다
- 발견하면 파일 시스템을 /volumes 디렉터리에 자동으로 마운트하고, 장치 디렉터리에 저장된 파일 시스템의 이름이 붙은 폴더 아이콘을 추가한다
- 사용자는 아이콘을 클릭하여 새로 마운트 된 파일 시스템을 탐색할 수 있다

#### Windows 계열 운영체제

- 확장딘 2단계 디렉터리 구조를 유지하며, 장치와 볼륨에는 드라이브 문자가 할당된다
- 각 볼륨은 문자와 연관된 일반적인 그래프 디렉터리 구조를 가진다
  - 특정 파일 경로는 dri-letter: \path\to\file 로 형성된다
    - 예를 들어, C: 드라이브는 C:\Windows\Fonts\arial.ttf 파일을 가질 수 있다
- 더 최신 버전의 Windows는 UNIX와 마찬가지로 부팅 시 발견한 모든 장치에 존재하는 파일 시스템을 자동으로 마운트 한다
- Windows 운영체제는 부팅 시 발견한 모든 장치에 존재하는 파일 시스템을 자동으로 마운트 한다
- UNIX 같은 몇몇 시스템에서는 마운트 명령어가 명시적으로 필요하다
- 시스템 구성 파일은 부팅 시 자동 마운팅을 위해 장치 목록과 마운트 포인트를 가지고 있지만, 몇몇은 직접 마운트를 해야 한다

## 15.3 파티션과 마운팅(Partitions and Mounting)

- 디스크의 배치는 운영체제와 볼륨 관리자 소프트웨어에 따라 크게 달라질 수 있다
- 디스크는 여러 파티션으로 분할될 수 있고, 또는 한 파티션이 여러 디스크로 구성딜 수도 있다
  - 디스크가 여러 파티션으로 분할되는 경우 : 이번 절에서 다룸
  - 파티션이 여러 디스크로 구성되는 경우 : RAID의 한 유형, 11.8절에서 다룸
- 디스크가 여러 파티션으로 분할되는 경우 2가지로 나뉜다
  - 각 파티션은 파일 시스템을 포함하지 않은 "미가공(raw)" 파티션
  - 파일 시스템을 포함하는 "가공(cooked)" 파티션
- Raw 디스크는 파일 시스템이 사용되지 않는 곳에서 사용된다
  - UNIX 스왑공간은 디스크상에 자신의 고유 포맷을 사용하고 파일 시스템을 사용하지 않으므로 이 raw파티션을 사용한다
  - 몇몇 데이터ㅔ이스에서 raw 디스크를 사용하여 데이터를 그들의 요구에 맞게 포맷한다
- 또한 raw 디스크는 RAID 시스템에서 필요한 정보를 저장할 수 있다
  - 어느 블록이 mirrored 되었는지
  - 또는 어느 블록이 변경되어 mirrored 될 필요가 있는지를 가리키는 비트맵 같은 것을 가지고 있다
  - 유사하게 raw 디스크는 어느 디스크가 각 RAID 세트의 멤버인지를 가리키는 RAID 구성 정보를 수록한 축소형 데이터베이스를 포함한다
  - Raw 디스크의 용도는 11.5.1절에서 더욱 자세히 설명되었다

#### 파티션에 부팅 가능한 파일 시스템이 포함된 경우 -> 자체 형식을 가진다 : 부트스트랩 로더

- 파티션에 부팅 가능한 파일 시스템(올바로 설치 및 구성된 운영체제가 존재하는 파일 시스템)이 포함되어 있으면
  - 11.5.2절에서 설명한대로 파티션은 부팅정보도 필요하다
- 부팅 중에 시스템이 적재된 파일 시스템 코드가 없고 따라서 파일 시스템 형식을 해석할 수 없기 때문에 이 정보는 `자체 형식을 가진다`
- 부팅 정보는 (도커의 이미지 처럼) 메모리에 적재되는 연속된 블록이다
- 이 이미지(부트스트랩 로더)의 실행은 첫 번째 바이트 처럼 미리 정해진 위치에서 시작한다
- 부트스트랩 로더는 커널을 찾아서 적재하고 실행을 시작할 수 있을 만큼 파일 시스템 구조에 대해 충분히 알고 있다
- 부트 로더는 특정 운영체제를 부트할 수 있는 명령어 이상을 포함하고 있다

  - 예를 들어, PC들이나 다른 시스템은 이중 부팅을 할 수 있어서 하나의 시스템에 다수의 운영체제를 설치할 수 있게 한다
    - 시스템은 어떤 운영체제로 부트할지를 어떻게 알 수 있는가?
    - 여러 파일 시스템과 여러 운영체제를 인식하느 부트 로더가 부트 공간을 점유할 수 있다
    - 일단 적재되면, 그 드라이브에서 이용 가능한 운영체제 중 하나를 부트할 수 있다
    - 드라이브는 여러 파티션을 가질 수 있는데, 각 파티션이 다른 파일 시스템과 운영체제를 포함할 수도 있다
    - 부트 로더가 특정 파일 시스템 형식을 이해하지 못하면 해당 파일 시스템에 저장된 운영체제는 부트 가능하지 않다
    - 이것이 일부 운영체제에서 일부 파일 시스템만 루트 파일 시스템으로 사용되는 이유 중 하나이다

- `부트 로더에 의해` 선택된 운영체제 커널 및 다른 시스템 파일을 포함하고 있는 `루트 파티션이 부팅할 때 마운트` 된다

  - 다른 파티션은 부트 시에 자동으로 마운트되거나 운영체제에 따라 수동으로 나중에 마운트 된다
  - 마운트 연산 중에 운영체제는 시스템이 유효한 파일 시스템을 가지고 있는가를 확인한다
  - 운영체제는 장치 드라이버에게 장치 디렉터리를 읽도록 요청하고 디렉터리가 유효한 포맷을 가졌는지 확인함으로써 이 과정을 수행한다
  - 포맷이 유효하지 않다면 사용자의 중재에 의하거나 또는 중재 없이 파티션의 일관성을 검사하고 가능하다면 바로 잡으려 할 것이다
  - 마지막으로 운영체제는 메모리에 존재하는 마운트 테이블에 파일 시스템이 마운트되었다는 사실과, 파일 시스템의 유형을 기록한다

- Windows 기반 시스템은 앞서 언급했던 것 처럼 각각의 파티션을 문자와 콜론으로 명시된 다른 네임 스페이스에 마운트한다

  - 예를 들어, 파일 시스템이 F:에 마운트된 것을 기록하기 위해 운영체제는 F:에 대응하는 `장치 구조의 한 필드`에 `파일 시스템 포인터를 기록`한다
  - 프로세스가 드라이드 문자를 지정하면 운영체제는 적절한 파이러 시스템 포인터를 찾으며, 지정된 파일이나 디렉터리를 찾기 위해 그 장치상의 디렉터리 구조를 탐색한다

- UNIX에서 파일 시스템은 어떤 디렉터리에도 마운트될 수 있다
  - 이것은 그 디렉터리 메모리 내 inode(파일 제어 블록 file control block, FCB)의 한 플래그를 설정함으로써 구현된다
  - 플래그는 디렉터리가 마운트 포인트임을 가리킨다
  - 그 경우 한 필드가 마운트 테이블의 한 항을 가리켜 아느 정치가 그곳에 마운트 되었는가를 알려준다
  - 마운트 테이블항은 그 장칭상의 파일 시스템의 수퍼 블록을 가리키는 포인터를 포함한다
  - 이 기법은 운영체제가 파일 시스템을 필요에 따라 적절히 교체하면서 디렉터리 구조를 탐색할 수 있게 해준다

## 15.4 파일 공유(File sharing)

- 공동 작업을 수행을 위해 필요
- 사용자 지향 운영체제는 문제 자체의 원래 어려움에도 불구하고 파일을 공유할 필요성을 수용해야 한다
- 이 절에서는 파일 공유의 여러 측면을 살펴본다
- 첫 번째는 다수의 사용자와 가능한 공유 방법이다
- 일단 `다수의 사용자가 파일을 공유하도록 허용`하면, 다음 문제는 `원격 파일 시스템을 포함하여 여러 파일 시스템을 공유`하도록 확장하는 것이다
- 마지막으로 공유 파일에 대해 발생하는 상반된 행위에 대해 여러 해석이 가능하다.
  - 예를 들어, 다수의 사용자가 파일에 쓰기를 한다면, 모든 쓰기의 수행을 허용해야 할지 아니면 운영체제가 각 사용자의 작업을 서로로부터 보호해야 할지에 관한 문제이다

### 15.4.1 다수의 사용자 (Multiple users)

- 운영체제가 여러 사용자를 수용할 때, 파일 공유, 파일 네이밍, 파일 보호가 더욱 중요해진다
- 디렉터리 구조가 사용자의 파일 공유를 허용한다면 시스템은 파일 공유를 중재해야 한다
  - 시스템은 한 사용자에게 기본적으로 다른 사용자의 파일 접근을 허용하든지 아니면 사용자가 명시적으로 파일 접근을 허용하든지
  - 아니면 사용자가 명시적으로 파일 접근을 허용하도록 요구한다
  - 접근 제어와 보호의 이슈는 13.4절에서 살펴볼 것이다
- `파일 공유와 보호를 구현`하기 위해서, 시스템은 파일과 디렉터리에 대해 `단일 사용자 시스템보다 더 많은 속성을 가져야 한다`
- 이 요구(파일 공유)를 만족시키기 위한 여러 방안이 강구 되었으나
  - 대부분의 시스템에서는 파일/디렉터리의 소유자(owner 또는 user)와 그룹(group)이라는 개념을 발전시켜 왔다
- 소유자는 파일 속성을 변경하거나 파일 접근 허용 그리고 파일 디렉터리에 대해 가장 많은 제어 권한을 가지고 있는 사용자이다
- 파일 그룹 속성은 파일에 `접근`을 공유할 수 있는 `사용자들을 정의`한다
  - 일례로, UNIX 시스템에서
    - 파일 소유자는 파일에 대한 모든 작업을 수행할 수 있지만,
    - 파일의 그룹 멤버는 단지 일부 작업만을 실행할 수 있으며, 모든 다른 사용자들은 더 적은 작업만을 행할 수 있다
    - 정확히 그룹 구성원과 다른 사용자가 수행 가능한 작업은 파일 소유자에 의해 정해진다
- 주어진 파일 또는 디렉터리의 소유자와 그룹 ID들은 다른 파일 속성과 함께 저장된다

  - 사용자가 파일 연산을 요구할 때, 사용자 ID를 소유자 속성과 비교한 후 요청 사용자가 파일의 주인인지 아닌지를 결정한다
  - 마찬가지로 그룹 ID도 비교된다
  - 그 결과는 어떤 허가를 부여할 수 있는지를 보여준다
  - 그런 후에 시스템은 요구된 연산을 허가하든지 거부한다

- 많은 시스템은 하나 또는 여러 `디스크에 많은 볼륨을 포함`하는 `다수의 로컬 파일 시스템`을 갖는다
  - 이런 경우 파일 시스템이 마운트 되기만 하면 ID 검사와 허가 확인은 간단하다
- 그러나 시스템 간에 이동할 수 있는 외장 디스크를 고려하자
  - 시스템 ID가 다른 경우 어떻게 되는가?
  - 시스템 간에 장치를 이동할 때 반드시 ID를 일치하도록 보장하거나 파일 소유권이 리셋되도록 보장해야 한다
  - 예를 들어, 기존 사용자가 실수로 파일에 액세스 할 수 없도록 새 사용자 ID를 생성하고 휴대용 디스크의 모든 파일을 해당 ID로 설정할 수 있다

## 15.5 가상 파일 시스템

- 최신 운영체제는 동시에 병렬로 여러 유형의 파일 시스템을 지원해야 한다

  - 그러나 어떻게 운영체제는 여러 유형의 파일 시스템을 하나의 디렉터리 구조로 통합되게 할 수 있는가?
  - 그리고, 어떻게 사용자는 파일 시스템 공간을 탐색하면서 이질 파일 시스템 유형 사이를 자연스럽게 왔다갔다 할 수 있는가?

- 여러 유형의 파일 시스템을 구현하는 가장 명확하고 차선의 방법은 유형별로 디렉터리와 파일 루틴을 작성하는 것이다

  - 대신 UNIX를 포함하여 대부분의 운영체제는 구현을 단순화하고, 조직화하고, 모듈화하기 위해 `객체 지향 방법을 사용`한다
  - 이러한 방법을 사용함으로써 NFS와 같은 네트워크 파일 시스템을 포함하여 크게 `다른 파일 시스템 유형이 같은 구조 안에 구현되는 것을 허용`한다
  - 사용자는 로컬 디스크의 여러 파일 시스템이나, 심지어 네트워크를 통해 이용 가능한 파일 시스템에 포함된 파일에 접근할 수도 있다

![그림15-5](./img/%EA%B7%B8%EB%A6%BC15-5.png)

- 그림 15.5 가상 파일 시스템의 개략적 모습

- 구현 세부사항으로 부터 기본 시스템 콜 기능을 격리하기 위해 자료구조와 프로시저가 사용된다
- 그러므로 파일 시스템 구현은 그림 15.5에 개략적으로 표현된 것 처럼 세 가지 주요한 계층으로 구성된다

  - 첫 번째 계층은 열기(open()), 읽기(read()), 쓰기(write()), 닫기(close()) 호출과 파일 디스크립터 기반을 둔 파일 시스템 인터페이스이다
  - 두 번째 계층은 **가상 파일 시스템(virtual file system, VFS)** 계층이라고 한다

- VFS 층은 두 가지 중요한 기능을 제공한다
  - 1. `NFS는 VFS인터페이스를 명확하게 정의`함으로써 `파일 시스템의 일반적 연산을 구현과 분리`한다
    - VFS인터페이스에 대한 다른 구현들이 같은 기계상에 공존할 수 있으므로, 다른 형태의 파일 시스템을 지역적으로 마운트함으로써 투명한 접근을 가능케 할 수 있다
  - 2. VFS는 네트워크에 속한 모든 파일을 `동일한 형태의 파일 객체로 표현`해주는 기능을 제공한다
    - 자세히 설명하면, VFS는 `vnode`라 불리는 `파일 표현 구조`에 기반을 둔다
    - vnode는 네트워크 전체에서 유일한 파일에 대한 수치 지정자(designator)를 포함하고 있다
    - (UNIX의 inode는 한 파일 시스템 내에서만 유일하다)
    - 네트워크 파일 시스템을 지원하려면 범-시스템상에서 유일해야 한다
    - 커널은 각 활성 노드(파일이나 디렉터리)에 대해 하나의 vnode 구조를 가진다
- 그러므로 VFS는 원격 파일과 로컬 파일을 구분하고, 로컬 파일들은 파일 시스템 유형에 따라 더 세부적으로 구분된다
- VFS는 특정 파일 시스템의 명령을 활성화함으로써 파일 시스템 유형에 따른 로컬 요청을 처리하며,
  - 원격 요청에 대해서는 NFS프로토콜 프로시저(또는 다른 네트워크 파일 시스템의 경우에는 다른 프로토콜 프로시저)를 호출한다
  - 파일 핸들과 관련된 vnode들로부터 구성되며, 이들 프로시저에 매개변수로 전달된다
  - 파일 시스템 유형이나 원격 파일 시스템 프로토콜을 구현하는 계층은 그 구조의 최하부(3단계) 계층이다
- 다음으로 Linux에서의 VFS 구조를 살펴보자

  - Linux VFS에서 정의한, 이 구조를 이루는 네 가지의 기본 객체 유형은 다음과 같다
    - Inode object : 각 파일을 나타냄
    - File object : 오픈 파일을 나타냄
    - Superblock object : 전체 파일 시스템을 나타냄
    - Dentry object : 각 디렉터리 엔트리를 나타냄(dentry는 directory entry의 약자)

- 파일에 대한 완전한 정의는 다음의 구조체 struct file_operations를 참고하라
  - /usr/include/linux/fs.h에 정의되어 있다(리눅스)

## 15.6 원격 파일 시스템(Remote File Systems)

- 네트워크(19장)의 출현은 원격 컴퓨터 간에 통신할 수 있게 만들었다

  - 네트워크는 캠퍼스 안에서나 또는 세계 곳곳에 퍼진 자원을 공유하는 것을 가능하게 했다
  - 공유 가능한 자원은 데이터로 이들을 파일의 형식을 가진다

- 네트워크와 파일 기술의 발전으로 파일 공유 방법은 변화해 왔다
  - 첫 번째 구현된 방법에서 사용자는 ftp같은 프로그램을 통해서 기계 간에 파일을 직접 전송하였다
  - 두 번째 주요 방법은 로컬 기계에서 원격 디렉터리에 접근할 수 있는 분산 파일 시스템(DFS)이다.
  - 세 번째 방법인 (World Wide Web)는 어떤 면에서는 첫 번째 방법을 변형한 것이다
    - 원격 파일에 접근하기 위해서는 브라우저가 필요하고, 파일 전송을 위해서는 별도의 연산(실질적으로는 ftp를 포장한(wrapper) 것)이 사용된다
    - 파일을 공유하기 위해 점점 클라우드 컴퓨팅(1.10.5절)이 사용되고 있다
- ftp는 익명 또는 인증형 접근 모두에 사용할 수 있다
  - 익명 접근(anonymous access)인 경우, 원격 시스템에 계정이 없어도 사용자가 파일을 전송할 수 있다
- WWW는 거의 전적으로 익명 파일 교환을 사용한다
- 분산 파일 시스템(DFS)은 원격 파일을 접근하는 기계와 그 파일을 제공하는 기계 사이에 훨씬 더 긴밀한 통합이 존재한다
  - 이러한 통합은 복잡성을 더하며 이 절에서 설명한다

### 15.6.1 클라이언트 서버 모델(The Client-Server Model)

- 원격 파일 시스템은 하나 이상의 원격 시스템으로부터 하나 이상의 파일 시스템을 마운트 하도록 허용한다
  - 이 경우 파일을 가지고 있는 컴퓨터를 서버라 하고
  - 파일에 접근하기를 원하는 컴퓨터를 클라이언트라고 한다
- 네트워크에 연결된 컴퓨터에서 클라이언트-서버 관계는 일반적이다

  - 일반적으로 서버는 클라이언트에게 자원이 사용 가능함을 공지하고, 정확하게 어느 자원(이 경우, 어느 파일)과 어느 클라이언트인지를 명시한다
  - 파일은 보통 파티션이나 서브 디렉터리 레벨에서 명시된다
  - 주어진 클라이언트-서버 설비의 구현 상세에 따라 서버는 여러 클라이언트에게 서비스를 제공할 수 있으며, 클라이언트 역시 여러 서버를 사용할 수 있다

- 서버는 일반적으로 볼륨이나 디렉터리 수준에서 사용 가능한 파일을 명시한다
  - 클라이언트 신원확인은 좀 더 어렵다
  - 클라이언트는 네트워크 이름이나 IP주소 같은 다른 식별자로 확인할 수 있지만, 이런 것들은 해킹(spoofing, imitation)될 수 있다
  - 허가 받지 않은 클라이언트는 스푸핑(spoofing)을 이용하여 허가된 것 처럼 위장해서 서버에 접속한다
  - 더욱 `안전한 해결 방안`은 `암호화된 키`를 통하여 `클라이언트에서 서버로 보안 인증`을 하는 것이다
  - 불행ㅏ게도 클라이언트와 서버의 호환성(같은 암호 알고리즘을 사용)과 안전한 키 값의 교환(키 값을 가로채어 허가되지 않은 클라이언트가 접근을 시도할 수도 있다) 등을 비롯한 많은 문제가 도처에 존재한다
  - 이러한 문제들을 해결하기 어렵기 때문에 대부분 불안전한 인증 방법이 사용된다
- UNIX와 UNIX 네트워크 파일 시스템(NFS)의 경우, 기본적으로 클라이언트 네트워킹 정보를 통해 인증한다
  - 이러한 방법에는 사용자 ID가 클라이언트와 서버에서 일치해야 한다
    - 그렇지 않다면 서버는 파일에 대한 접근 권한을 결정할 수 없다
    - 클라이언트에서 1000이라는 ID를 서버에서 2000이라는 ID를 가지는 사용자의 예를 생각해보자
      - 이 경우 클라이언트에서 서버로의 특정 파일 요청은 처리되지 못한다
        - 서버는 2000이라는 실제 사용자가 아니라 1000이라는 사용자가 파일 접근 권한을 접근 권한을 가지고 있는지 결정하기 때문이다
  - 접근은 정확하지 않은 인증 정보에 따라 허용되거나 거부될 수 있다
  - 서버는 클라이언트가 정확한 사용자 ID를 입력하는 것을 신뢰해야 한다
  - NFS 프로토콜은 다대다 관계를 허용한다
    - 즉, 다수의 서버가 다수의 클라이언트에게 파일을 제공한다
    - 한 시스템은 다른 NFS 클라이언트에게는 서버로 그리고 다른 NFS 서버들에게는 클라이언트 모두가 될 수 있다

### 15.6.2 분산 정보 시스템(Distributed Information Systems)

- 클라이언트-서버 서비스를 쉽게 관리하기 위해, `분산 정보 시스템` 또는 `분산 네이밍 서비스`라는 개념이 출현하였다
- 이는 `원격 컴퓨팅`을 위해 필요한 정보에 `단일화된 접근을 제공`하기 위해 고안되었다
- `도메인 네임 시스템(DNS)`은 전체 인터넷의 `호스트 이름을 네트워크 주소로 변환`하는 서비스를 제공한다
  - DNS가 발명되고 널리 쓰이기 전에는 같은 정보를 포함하는 파일이 모든 네트워크 호스트 간에 이메일이나 ftp를 사용하여 보내졌다
    - 이메일이나 ftp는 확장성이 부족하다는 단점이 있다
    - DNS에 대하여 19.3.1절에서 더 자세히 설명한다
- 다른 분산 정보 시스템은 분산 설비를 위해 사용자 이름 / 패스워드 / 사용자 ID / 그룹 ID 의 공간을 제공한다
  - UNIX 시스템은 여러 다양한 분산 정보 방법을 제공한다
    - e.g. 1. Sun Microsystems(이제는 Oracle의 자회사)
      - yellow page(network information service, NIS)를 소개하였고 대부분의 회사에서 이를 채택하였다
        - 사용자 이름, 호스트 이름, 프린트 정보 같은 정보를 중앙에 집중적으로 저장하였다
        - 불행하게도 NIS는 사용자 패스워드를 암호화하지 않은 채 보내는 것과 IP주소로 호스트를 식별하는 것을 포함한 불안전 인증 방법을 사용하였다
      - Sun의 NIS+는 NIS에 비해 더욱 안전한 방법을 제시하였으나, 훨씬 복잡하고 널리 리 채택되지 못하였다
    - e.g. 2. Microsoft의 common internet file system (CIFS)
      - 요청된 시스템에 접근을 허용할지, 거부할지를 결정하기 위해 네트워크 로그인을 사용하며,
      - 네크워크 로그인은 사용자 인증정보(사용자 이름, 패스워드)와 함께 네트워크 정보를 사용하여 생성한다
      - 이 인증방법이 유효해지려면 클라이언트, 서버 사이에 사용자 이름이 일치해야 한다(NFS와 동일)
      - Microsoft는 활성 디렉터리(active directory)를 분산 네이밍 구조로 사용하여 사용자들에게 하나의 네이밍 공간을 제공한다
      - 구축되면, 모든 클라이언트와 서버는 사용자를 Kerberos 네트워크 인증 프로토콜의 Microsoft의 버전을 사용하여 인증하기 위해 분산 네이밍 설비를 사용할 수 있다
- 산업계는 안전한 분산 네이밍 메커니즘인 경량 디렉터리 접근 프로토콜(light-weight directory-access protocol, LDAP)로 넘어가는 추세이다
  - 사실상 활성 디렉터리는 LDAP에 기반한 것이다
  - Oracle Solaris와 대부분의 다른 주요 운영체제들은 LDAP를 포함했고 사용자 인증에 이를 사용하였으며, 또한 가용 프린터를 찾는 것과 같은 시스템 전반에 걸친 정보검색에도 사용하였다
  - 하나의 분산 LDAP 디렉터리를 이용하면 한 조직 내의 모든 사용자와 모든 컴퓨터에 대한 자원 정보를 저장할 수 있다
  - 결과는 `사용자가 인증 정보를 한 번 입력`하여 안전한 사인-온(`secure single sign-on`)을 한 후에는 한 `조직 내의 모든 컴퓨터에 접속`할 수 있다
  - 이는 각 시스템의 여러 파일 또는 다른 분산 정보 서비스에 흩어져 있는 정보를 한 곳으로 병합시킴으로써 시스템 관리를 편하게 할 것이다

### 15.6.3 고장 모드(Failure Modes)

- 로컬 파일 시스템의 여러 고장 이유들
  - 파일 시스템을 포함하는 디스크의 고장
  - 디렉터리 구조 또는 다른 디스크 관리 정보(메타데이터)의 오류
  - 디스크 컨트롤러의 고장
  - 케이블 고장
  - 호스트 어댑터 고장
  - 사용자 또는 시스템 관리자 실수로 파일을 지우거나 또는 전체 디렉터리나 파티션을 지울 수 있다
  - ...
- 이러한 고장의 대다수가 장애를 발생시키며, 오류 이유가 화면에 표시되고 이는 사람의 중재를 필요하게 된다

- 원격 파일 시스템은 더 많은 오류 가능성을 가지고 있다
- 원격 파일 시스템의 오류 가능성
  - 네트워크 시스템의 복잡성과 원격 시스템 간에 요구되는 상호작동으로 인해 많은 문제가 원격 시스템의 적절한 연산을 방해한다
  - 네트워크의 경우 네트워크 오류가 두 호스트간에 발생할 수도 있다
  - 하드웨어 오류나 잘못된 구성 또는 연관된 호스트 간의 네트워크 구현 익슈로 인해 발생할 수 있다
- 몇몇 네트워크들은 각 호스트 사이에 다양한 경로를 가지는 이른바 회복 기능을 가진 것도 있지만, 대다수가 그렇지 않다
  - 어느 하나의 오류라도 DFS 명령의 흐름을 차단할 수 있다
- 오류로부터 이런 종류의 복구를 구현하기 위해 상태 정보(state information)가 클라이언트 서버 모두에 유지될 수 있다

## 15.7 일관성의 의미(Consistency Semantics)

- 일관성 의미는 파일 공유를 지원하는 파일 시스템을 평가하는 데 있어 중요한 요소이다
- 동시에 공유 파일에 접근하는 여러 사용자의 의미를 명시한다
- 이러한 의미들은 한 사용자에 의한 데이터의 변경이 언제 다른 사용자에 의해 관찰될지를 결정한다
- 이 의미는 파일 시스템의 코드로서 구현된다
- 일관성의 의미는 6장의 프로세스 동기 알고리즘과 직접 연관되어 있다
- 그러나 6장의 복잡한 알고리즘은 디스크와 네트워크의 큰 지연과 느린 전송률 때문에 파일 입출력의 경우, 구현되지 않는다
- 파일에 대한 한 사용자의 일련의 파일 접근 연산
- 열기와 닫기 연산 사이의 일련의 접근은 하나의 파일 세션이다
  - 이 개념을 설명하기 위해 일관성 의미의 여러 우수한 예를 보일 것이다

### 15.7.1 UNIX의 의미(UNIX Semantics)

- UNIX 파일 시스템(19장)은 다음과 같은 일관성 의미를 사용한다
- 열린 파일에 대한 사용자의 쓰기는 동일 파일을 연 다른 사용자에게 즉시 보일 수 있다
- 사용자들은 파일에 대한 현재 위치 포인터를 공유하는 공유 모드가 있어, 한 사용자에 의한 포인터의 전진은 공유하고 모든 모든 사용자들에게 영향을 미친다
  - 여기서 파일은 그 작업을 누가 시작했는지와 관계없이 모든 접근이 서로 엇갈려서 수행되는 단일 이미지를 가지고 있다
- 내 생각) 구글 Docs, 컨플루언트 등을 동시 작업할 때와 비슷한 것 같다

- UNIX의 의미(Semantics)에서 한 파일에는 하나의 물리 이미지가 연관되어 있고, 이 이미지는 배타적인 자원으로 접근된다
  - 이 단일 이미지에 대한 경쟁은 사용자 프로세스들이 시간적으로 지연되는 결과를 낳는다

### 15.7.2 세션 의미(Session semantics)

- Andrew 파일 시스템(Open AFS)은 다음의 일관성 의미를 사용한다
  - 열린 파일에 대한 한 사용자의 쓰기는 동시에 동일 파일을 연 다른 사용자들에게 바로 보이지 않는다
  - 일단 파일이 닫히면, 파일에 대한 변경들이 그 후에 시작되는 세션(session)에서만 보인다
    - 이미 열린 파일의 인스턴스들은 이러한 변경을 반영하지 않는다
- 한 파일은 동시에 몇 가지(서로 다를 수 있는) 이미지들과 일시적으로 연관될 수 있다
- 결과적으로 다중 사용자들은 지연 없이 그들의 파일 이미지에 대해 병행적으로 읽기와 쓰기 접근을 모두 실행할 수 있다

### 15.7.3 불변 공유 파일의 의미(Immutable-Shared Files Semantics)

- 앞의 두 방법과 다른 독특 한 접근 방법(불변 공유 파일의) 이다
- 일단 하나의 파일이 파일 생성자에 의해 공유된다고 선언되면, 이는 더는 변경될 수 없다
- 불변 파일은 두 가지 중요한 속성을 가지고 있는데, 이는 파일명이 재사용될 수 없고 파일 내용도 변경할 수 없다는 것이다
- 따라서 파일의 이름은 파일이 가변 정보가 아니라 고정된 내용을 가짐을 나타낸다
- 분산 시스템(17장)에서 이러한 의미의 구현은 아주 간단한데, 이는 공유가 매우 확실한 규칙(읽기만 가능)을 가지고 있기 때문이다

## 15.8 NFS

- 네트워크 파일 시스템은 이제 흔히 볼 수 있으며 클라이언트 시스템의 전체적인 디렉터리 구조 및 인터페이스와 통합되어있다
- NFS는 널리 쓰이는 잘 구현된 클라이언트 서버 네트워크 파일 시스템의 좋은 예이다
  - 여기서 NFS를 `네트워크 파일 시스템`의 구현 세부사항을 설명하는 예로 사용할 것이다
- NFS는 LAN(또는 WAN)을 거쳐 원격 파일에 접근하기 위한 소프트웨어 시스템의 구현과 명세 모두를 말한다
- NFS는 대부분의 UNIX업체와 몇몇 PC운영체제가 지원하는 ONC+의 한 부분이다
- 여기서 설명되는 구현은 UNIX SVR4의 변종인 Solaris 운영체제의 한 부분이다
  - 이것은 (상호 연결 네트워크에 따라) TCP 또는 UDP/IP 두 가지 중 하나를 사용한다
  - 우리 설명에서는 NFS의 명세와 구현이 서로 뒤섞여 있다
  - 세부 사항이 필요할 때 마다 Solaris 구현을 주 대상으로 하였으며, 설명이 일반적일 경우에는 그 내용이 명세에도 해당한다
- NFS에는 다수의 버전이 존재하며, 가장 최근 버전은 버전 4이다
  - 여기서 버전 3을 설명하는데, 가장 일반적으로 배포되는 버전이다

### 15.8.1 개요(Overview)

- 내 생각) NAS와 비슷한 것 같다
- `NFS`는 `서로 연결된 워크스테이션의 집합`을 `독립적인 파일 시스템을 가진` `독립적인 기계들의 집합`으로 간주한다

  - NFS의 목적인 이들 파일 시스템들 사이에서 명시적 요구에 의해 일정 수준의 공유를 투명하게 허용하는 것이다
  - 공유는 클라이언트 서버의 관계를 기반으로 한다
  - 한 시스템은 종종 동시에 클라이언트와 서버가 될 수 있다
  - 공유는 전용의 서버 시스템들 사이보다는 임의의 한 쌍의 기계 사이에서 허용된다
  - 시스템의 독립성을 위해서, `원격 파일 시스템의 공유는` 다른 시스템에는 영향을 미치지 않고 단지 `클라이언트에게만 영향`을 준다

- NFS의 설계 목표 중 하나는 서로 다른 기계들, 운영체제, 네트워크 구조로 구성된 이질적 환경에서 작동하는 것이다

  - `NFS명세`는 이들 `매체에 독립적`이기 때문에 다른 구현을 이용할 수 있게 한다
  - 이러한 독립성은 두 개의 구현 독립적 인터페이스 사이에서 사용되는 외부 자료 표현(external data representation, XDR) 프로토콜 위에 구축된 `RPC 프리미티브를 통해서` 이루어진다
  - 따라서 NFS와 정확하게 인터페이스되는 이기종 시스템과 파일 시스템으로 구성된 시스템에서는 다른 유형의 파일 시스템들도 로컬 또는 원격으로 마운트 될 수 있다

- `NFS 명세`는 `마운트 기법`에 의해 제공되는 서비스와 실제 `원격 파일 접근`(remote-file-access) 서비스를 `구분`한다
  - 따라서 이들 서비스를 위해 두 가지 다른 프로토콜이 명세되어 있다
    - 마운트 프로토콜
    - NFS 프로토콜(원격 파일 접근을 위한 프로토콜)
  - 이들 프로토콜은 RPC 집합으로 명세되어 있다
  - 이 RPC들은 투명한 원격 파일 접근의 구현을 위해 사용되는 빌딩 블록이다

### 15.8.2 마운트 프로토콜(The Mount Protocol)

- 마운트 프로토콜은 서비스와 클라이언트 사이의 초기 논리적 연결을 생성하기 위해서 사용된다
  - Solaris에서는 각 시스템은 커널 외부에 프로토콜의 기능들을 실행하는 하나의 서버 프로세스를 가진다
- `마운트 명령`은 `마운트 될 원격 디렉터리의 이름`과 `그것을 저장하는 서버 기계의 이름`을 `포함`한다
- `마운트 요구`는 `적절한 RPC로 매핑`되고 `지정된` 서버 기계상에서 수행되는 `마운트 서버로 전달`된다
- 서버는 수출 리스트를 유지하며, 이 리스트는 그들을 마운트할 수 있도록 하는 기계의 이름과 함께 마운트 가능한 로컬 파일 시스템을 지정한다

### 15.8.3 NFS 프로토콜(The NFS Protocol)

- NFS 프로토콜은 원격 파일 연산을 위한 원격 프로시저 호출의 집합을 제공한다
- 이 프로시저는 아래의 연산을 지원한다

  - 디렉터리 내의 파일 검색
  - 디렉터리 항목 집합의 읽기
  - 링크와 디렉터리들의 조작
  - 파일 속성의 접근
  - 파일 읽기와 쓰기

- 이러한 프로시저는 원격으로 마운트된 디렉터리에 대한 파일 핸들이 구축되어야만 호출할 수 있다

- 서버의 무상태 철학과 RPC의 동기성이 갖는 부가적인 의미는

  - 결과들이 클라이언트에게 반환되기 전에 변경된 자료(간접 및 상태 블록 포함)가 서버의 디스크에 기록되어야 한다는 것이다

- 하나의 NFS 쓰기 프로시저 호출은 원자성(atomic)이 보장되며, 같은 파일에 대한 다른 쓰기 호출과 혼합되지 않는다
  - 그러나 NFS 프로토콜은 병행성 제어 기법(concurrency control mechanism)을 제공하지 않는다

![그림15-8](./img/%EA%B7%B8%EB%A6%BC15-8.png)

- 그림 15.8 NFS 구조의 개략도

- NFS는 가상 파일 시스템(VFS)을 통하여 운영체제로 통합된다
- 그 구조를 설명하기 위해, 이미 오픈된 원격 파일에 대한 연산들이 어떻게 처리되는지를 그림 15.8에서 추적해보자
  - 클라이언트는 정규 시스템 콜을 통해서 연산을 시작한다
  - 운영체제 층은 이 호출을 적절한 vnode에 대한 VFS 연산으로 매핑한다
  - VFS 계층은 이 파일을 원격 파일로 인식하고 적절한 NFS 프로시저를 실행한다
  - 하나의 RPC 호출이 원격 서버 내의 NFS 서비스 계층에 대해 행해진다
  - 이 호출은 원격 시스템상의 VFS 계층으로 다시 들어가고, 원격 시스템은 그 호출이 지역에서 해결 가능함을 발견하며, 적절한 파일 시스템 연산을 실행한다
  - 이 경로를 다시 돌아가서 결과를 반환한다
- 이러한 구조의 장점은 클라이언트와 서버가 동등하므로, 시스템이 클라이언트나 서버 모두가 될 수 있다는 것이다
- 각 서버에서 실제적인 서비스는 경량 프로세스(lightweight process), 즉, 쓰레드(thread) 기법을 일시적으로 대체하는 여러 커널 프로세스들에 의해서 실행된다

### 15.8.4 경로 이름 반환(Path Name Resolution)

- NFS에서 경로 이름 반환은 /usr/local/dir1/file.txt와 같은 파일의 경로 이름을 파싱하는 것을 포함한다
- 이는 다음의 세 개의 디렉터리 엔트리로 나누어진다
  - usr, local, dir1
- 경로 이름 반환은 경로를 구성요소이름으로 분리하고, 구성요소 이름과 디렉터리 vnode의 모든 쌍에 대한 별도의 NFS 구성요소 룩업은 서버에 대한 별도의 RPC를 유발한다
- 이렇게 비용이 많이 드는 경로 이름 순회 기법이 필요한 이유는
  - 클라이언트가 어떻게 마운트를 했느냐에 따라 클라이언트의 논리적 이름 공간이 각자 다르기 때문이다

### 15.8.5 원격 연산(Remote Operations)

- 파일 오픈과 클로즈를 제외하고는 파일 연산을 위한 정규 UNIX 시스템 콜들과 NFS의 RPC 프로토콜 사이에는 거의 1:1 대응 관계가 있다
- 그러므로 원격 파일 연산은 대응 되는 RPC로 직접 변환될 수 있다
- 개념적으로 NFS는 원격 서비스 패러다임을 따르지만, 실제로는 성능 향성을 위해 버퍼링과 캐싱 기술을 사용한다
- 하나의 원격 연산과 하나의 RPC사이의 직접적인 대응관계는 존재하지 않는다
- 대신 파일 브록과 파일 속성이 RPC에 의해서 인출되며, 지역에 캐시된다
- 그 뒤의 원격 명령들은 일관성 제한이 허락하는 한, 캐시 자료를 사용할 수 있다
- 성능을 위한 시스템의 조정은 NFS의 일관성 의미를 규정하기 어렵게 만든다
  - 한 기계에서 생성된 새로운 파일은 다른 기계에서는 30초 동안 볼 수가 없다
  - 한 사이트에서 쓴 내용이 그 파일을 읽기 위해 오픈하고 있는 다른 사이트들에 보여야 하는지의 여부는 결정된 바가 없다
  - 그 파일에 대한 새로운 오픈은 서버의 디스크에 이미 반영된 내용만을 볼 수 있다
  - 그러므로 NFS는 UNIX의미를 엄격히 따르지 않을 뿐만 아니라 Andrew의 세션 의미도 제공하지 않는다
  - 이러한 단점에도 불구하고 기법의 효율과 고성능으로 인해 현재 작동 중인 다기종 분산 시스템에 널리 사용되고 있다

## 15.9 요약

- 범용 운영체제는 특수 목적에서 일반까지 다양한 파일 시스템 유형을 제공한다
- 파일 시스템이 포함된 볼륨은 컴퓨터의 파일 시스템 공간에 마운트 될 수 있다
- 운영체제에 따라 파일 시스템 공간은 결합된 표시 없이 매끄럽거나(디렉터리 구조에 통합된 마운트 된 파일 시스템) 결합 부분을 구분할 수 있다
  - 각 마운트 된 파일 시스템은 자신을 나타내는 표시가 있음
- 시스템을 시작하려면 최소한 하나의 파일 시스템은 부팅 가능해야, 즉 운영체제가 포함되어 있어야 한다
  - 부트 로더가 먼저 실행된다
  - 이 로더는 파일 시스템에서 커널을 찾아서 적재하고 실행시킬 수 있는 간단한 프로그램이다
  - 시스템에는 부팅 가능한 파티션이 여러 개 있을 수 있어서 관리자가 부팅 시 실행할 파티션을 선택할 수 있다
- 시스템의 대부분은 다중 사용자 시슽메이므로 파일 공유 및 파일 보호 방법을 제공해야 한다
  - 파일 디렉터리에는 종종 소유자, 사용자 및 그룹 액세스 권한과 같은 메타데이터가 포함된다
- 대용량 저장장치 파티션은 raw 블록 I/O 또는 파일 시스템에 사용된다
  - 각 파일 시스템은 볼륨에 상주하며 하나의 파티션 또는 볼륨 관리자를 통해 함께 작동하는 여러 개의 파티션으로 구성될 수 있다
- 다양한 파일 시스템의 구현을 간단하게 하기 위해 운영체제는 계층적 접근 방식을 사용할 수 있으며 가상 파일 시스템 인터페이스는 서로 다른 파일 시스템에 대한 접근을 구분없이 동리한 형식으로 만든다
- 원격 파일 시스템은 ftp 또는 World Wide Web의 웹 서버 및 클라이언트를 사용하여 또는 클라이언트 서버 모델을 통해 더 많은 기능을 사용하여 간단하게 구현할 수 있다
  - 승인되지 않은 액세스를 방치하려면 마운트 요청 및 사용자 ID가 인증되어야 한다
- 클라이언트-서버 기능은 기본적으로 정보를 공유하지 않지만 DNS와 같은 분상 정보 시스템을 사용하여 이러한 공유를 허용하고 통합된 사용자 네임스페이스, 암호관리 및 시스템 식별을 제공할 수 있다

  - 예를 들어, Microsoft CIFS는 Kerberos 네트워크 인증 프로토콜 버전을 사용하는 활성 디렉터리르 ㄹ 사용하여 네트워크의 컴퓨터 간에 전체 이름 지정 및 인증 서비스를 제공한다

- 파일 공유가 가능하면 일관성 있는 시맨틱 모델을 선택하여 동일한 파일에 대한 여러 동시 액세스를 조정해야 한다

  - 시멘틱 모델에는 UNIX, 세션, 불변 공유 파일 시맥틱 등이 있다

- NFS는 원격 파일 시스템의 예로서 클라이언트에게 디렉터리, 파일 및 전체 파일 시스템에 대한 완전한 액세스를 제공한다
  - 모든 기능을 갖춘 원격 파일 시스템에는 원격 작업 및 경로 이름 변환 기능과 함께 통신 프로토콜이포함되어 있다
