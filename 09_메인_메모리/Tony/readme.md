# Part 4. 메모리 관리(Memory Management)

- 컴퓨터 -> 프로그램 수행
- 프로그램 -> 메모리에 적재
- 최신 컴퓨터 시스템은 시스템 실행 중에 여러 프로세스를 메모리에 유지한다
  - 다양한 접근 방식을 반영하는 많은 `메모리 관리 기법`이 있으며 각 알고리즘의 효과는 상황에 따라 다르다
  - 시스템을 위한 메모리 관리 기법의 선택은 많은 요소, 특히 시스템의 하드웨어 설계에 따라 달라진다
  - 거의 모든 알고리즘은 일정 형태의 하드웨어 지원이 필요하다

# 9. 메인 메모리(Main Memory)

- 5장에서는 일련의 프로레스가 CPU를 공유하는 방법을 보여주었다
  - CPU 스케줄링의 결과로 CPU 이용률과 사용자에 제공하는 컴퓨터 응답속도를 모두 향상할 수 있었다
  - 그러나 이러한 성능향상을 실현하려면 많은 `프로세스를 메모리에 유지`해야 한다
  - 즉, `메모리를 공유`해야 한다
- 메모리 관리 알고리즘 : 베어머신, 페이징, ...
- 메모리 관리 방법의 선택은 하드웨어 설계에 따라 달라진다
- 시스템에서 하드웨어와 운영체제 메모리 관리를 밀접하게 통합해야 한다

#### 이 장의 목표

- 논리 주소와 물리 주소의 차이점과 주소를 변환할 때 MMU(메모리 관리 장치)의 역할을 설명한다
- 메모리를 연속적으로 할당하기 위해 최초, 최적 및 최악 접합 전략을 적용한다
- 내부 및 외부 단편화의 차이점을 설명한다
- TLB(translation look-aside buffer)가 포함된 페이징 시스템에서 논리 주소를 물리 주소로 변환한다
- 계층적 페이징, 해시 페이징 및 역 페이지 테이블을 설명한다
- IA-32, x86-64, ARMv8 아키텍처의 주소 변환에 관해 설명한다

## 9.1 배경(Background)

## 9.2 연속 메모리 할당(Contiguous Memory Allocation)

## 9.3 페이징(Paging)

## 9.4 페이지 테이블의 구조(Structure of the Page Table)

## 9.5 스와핑(Swapping)

## 9.6 사례: Intel 32비트와 64비트 구조(Example: Intel 32-bit and 64-bit Architectures)

## 9.7 사례: ARM 구조(Example: ARMv8 Architecture)

## 9.8 요약(Summary)

- 메모리는 최신 컴퓨터 시스템 작동의 중심이며 각각 고유한 주소를 가진 큰 바이트 배열로 구성된다
- 각 프로세스에 주소 공간을 할당하는 한 가지 방법은 기준 및 상한 레지스터를 사용하는 것이다
  - 기준 레지스터는 가장 작은 유효한 물리 메모리 주소를 저장하며,
  - 상한은 메모리 범위의 크기를 지정한다
- 심볼릭 주소 참조를 실제 물리 주소에 바인딩하는 작업이 발생하는 경우
  - (1) 컴파일
  - (2) 적재
  - (3) 실행시간
- CPU가 생성한 주소를 논리 주소라고 하며, 메모리 관리 장치(MMU)가 메모리의 물리 주소로 변환한다
- 메모리를 할당하는 한 가지 방법은 다양한 크기의 연속 메모리 파티션을 할당하는 것이다
  - 이러한 파티션은 세 가지 가능한 적략으로 할당될 수 있다
    - (1) 최초 적합
    - (2) 최적 적합
    - (3) 최악 적합
- 최신 운영체제는 페이징을 사용하여 메모리를 관리한다
  - 이 과정에서 `물리 메모리`는 `프레임`이라는 `고정 크기 블록`으로
  - `논리 메모리`는 `페이지` 라는 `같은 크기의 블록`으로 나뉜다
- 페이징을 사용하는 경우 논리 주소는 페이지 번호와 페이지 오프셋이라는 두 부분으로 나뉜다
  - 페이지 번호는 페이지를 저장하는 물리 메모리 프레임을 유지하는 프로세스별 페이지 테이블에 대한 인덱스 역할을 한다
  - 오프셋은 참조되는 프레임의 특정 위치이다
- TLB(translation look-aside buffer)는 페이지 테이블의 하드웨어 캐시이다
  - 각 TLB 항목에는 페이지 번호와 상응하는 프레임을 저장한다
- 페이징 시스템의 주소 변환에 TLB를 사용하려면 논리 주소에서 페이지 번호를 가져와서
  - 해당 페이지의 프레임이 TLB에 있는지 확인한다
  - 만약 있다면, 프레임은 TLB로부터 얻어진다
  - TLB에 프레임이 없으면 페이지 테이블에서 찾아야 한다
- 계층적 페이징은 논리 주소를 여러 부분으로 나누고 각 단계는 서로 다른 페이지 테이블 수준을 나타낸다
  - 주소가 32비트 이상으로 확장됨에 따라 계층 레벨 수가 커질 수 있다
  - 이 문제를 해결하는 두 가지 전략은 해시 페이지 테이블과 역 페이지 테이블이다
- 스와핑을 통해 시스템은 프로세스에 속하는 페이지를 디스크로 이동하여 다중 프로그래미어 정도를 높일 수 있다
- Intel 32비트 아키텍처에는 두 가지 수준의 페이지 테이블이 있으며 4KB 또는 4MB 페이지 크기를 지원한다
  - 이 아키텍처는 또한 페이지 주소 확장을 지원하므로 32비트 프로세서가 4GB 보다 큰 물리적 주소 공간에 액세스 할 수 있다
  - x86-64 및 ARMv8 아키텍처는 계층적 페이징을 사용하는 64비트 아키텍처이다
