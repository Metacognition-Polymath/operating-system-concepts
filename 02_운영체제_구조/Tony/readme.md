# 2. 운영체제 구조(Operating system structures)

- 운영체제는 운영체제 안에서 프로그램이 실행되는 환경을 제공해 준다
- 운영체제들의 구조는 크게 차이가 있다
- 새로운 운영체제를 설계하는 일은 대단히 큰 작업이다
- 설계를 시작하기 전에 시스템의 목표를 먼저 잘 정의하는 것이 중요하다
- 목표는 여러 가지 전략과 알고리즘 중에서 선택하는 기초가 된다
- 운영체제를 살펴보기 위한 몇 가지 유리한 관점이 있다
  - 첫 번째 관점 : 운영체제가 제공하는 `서비스`에 초점을 맞추는 것 - 사용자
  - 두 번째 관점 : 운영체제가 사용자와 프로그래머에게 제공하는 `인터페이스`에 초점을 맞추는 것 - 프로그래머
  - 세 번째 관점 : `시스템의 구성요소`와 `그들의 상호 연결`에 초점을 맞추는 것 - 운영체제 설계자
- 이번 장에서 사용자, 프로그래머, 그리고 운영체제 설계자의 관점에서 바라본 운영체제의 `세 가지 측면을 모두` 살펴본다
  - 운영체제가 제공하는 `서비스`
  - `서비스 제공 방식`
  - 이 서비스는 어떤 방식으로 제공되는지 - `서비스 제공 방식`
  - 이 서비스들은 어떻게 `디버깅`되며, 이러한 `시스템을 설계하기 위해서는 어떤 다양한 방법`들이 사용되는지 고려한다
- 내 생각) 서비스 : 운영체제가 제공하는 기능들

#### 이 장의 목표

- 운영체제에서 제공하는 서비스를 식별한다
- 운영체제 서비스를 제공하기 위해 시스템 콜을 사용하는 방법을 설명한다
- 운영체제 설계를 위한 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략을 비교 및 대조한다
- 운영체제 부팅 프로세스를 설명한다
- 운영체제 성능을 모니터링하기 위한 도구를 적용한다
- Linux 커널과 상호 작용하기 위한 커널 모듈을 설계하고 구현한다

## 2.1 운영체제 서비스(Operating System Services)

- 운영체제는 프로그램 실행환경을 제공한다
- 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다
- 운영체제 마다 제공하는 서비스는 다르지만 공통된 부류가 있다

  - 그림 2.1 다양한 운영체제 서비스에 대한 한 가지 관점과 그들의 상호 관계
  - 이러한 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 한다

- 사용자 인터페이스(user interface)

  - 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다
  - 이 인터페이스는 여러 형태로 제공될 수 있다
  - 가장 일반적으로 그래픽 사용자 인터페이스(GUI)가 사용된다
  - 인터페이스란?
    - 윈도 시스템으로 마우스와 키보드를 가지고 있다
  - 휴대전화 및 태블릿과 같은 모바일 시스템 -> 터치 스크린 인터페이스를 제공
  - CLI(Command Line Interface) : 터미널을 통해 명령어를 입력하는 방식

- 프로그램 수행(program execution)

  - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다
  - 프로그램은 정상적이든, 혹은 비정상적이든 실행을 끝낼 수 있어야 한다

- 입출력 연산(I/O operation)

  - 수행 중인 프로그램은 입출력을 요구할 수 있다
  - 이러한 입출력에는 파일 혹은, 입출력 장치가 연관될 수 있다
  - 특정 장치에 대해서는 특수한 기능(네트워크 인터페이스에서 읽거나 파일 시스템에 쓰기 등)이 요구될 수 있다
  - 효율과 보호를 위해 사용자들은 입출력 장치를 직접 제어할 수 없다
  - 운영체제가 입출력 수행의 수단을 제공해야 한다
    - 내 생각) 키보드, 마우스 연결하면 운영체제가 이를 인식하고, 사용자가 입력한 내용을 읽어들인다

- 통신(communication)

  - 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 상황이 있다
  - 이러한 통신을 수행하는 두 가지 중요한 방법
    - 1. 동일한 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
    - 2. (네트워크에 의해 묶여있는)다른 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
  - 통신 구현 방법
    - 1. 공유 메모리
    - 2. 메시지 전달(message passing) 기법
      - `정보의 패킷`들이 운영체제에 의해 `프로세스들 사이를 이동`한다
      - 내 생각) HTTP와 비슷하네, 네트워크로 연결된 컴퓨터들이 HTTP 방식으로 패킷을 주고 받는 것과 비슷한 것 같다
        - 메시지 전달 기법 또는 공유 메모리도 어떤 규약(protocol)을 따르는 것인가?

- 오류 탐지(error detection)
  - 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다
  - 오류는 CPU, 메모리, 입출력 장치, 사용자 프로그램에서 일어날 수 있다
  - 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 해야 한다
  - 디버깅 설비는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상 시킨다

#### 사용자에 도움을 주는 것이 목적이 아니라 `시스템 자체의 효율적인 동작을 보장`하기 위한 운영체제 기능들도 존재한다

- 자원 할당(resource allocation)

  - 다수의 프로세스나 다수의 작업이 `동시에 실행`될 때, 그들 각각에 `자원을 할당`해 주어야 한다
  - 운영체제가 관리하는 여러가지 자원 관리 예시
    - CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야할 프로세스들(우선순위), CPU의 처리 코어의 개수와 다른 요인들을 고려하도록 해야 한다
    - 프린터, USB 저장장치 및 다른 주변 장치를 할당하는 루틴

- 기록 장성(logging)

  - 우리는 어떤 프로그램이 어떤 종류의 컴퓨터 `자원`을 얼마나 많이 `사용`하는지를 `추적`할 수 있길 원한다
  - 로깅은 사용 예
    - 회계 - 사용자들에게 청구서를 보내기 위해
    - 사용 통계
      - 사용통계는 시스템을 재구성하고자 하는 시스템 관리자에게 귀중한 자료가 될 수 있다

- 보호(protection)와 보안(security)
  - 정보 소유자는 그 정보의 사용을 통제하길 원한다
  - 서로 다른 여러 프로세스가 병행하게 수행될 때, 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 된다
  - `보호`는 시스템 자원에 대한 모든 `접근이 통제`되도록 보장하는 것을 필요로 한다
  - 보안 - 사용자가 인증하는 것으로 부터 시작
    - 일반적으로 비밀번호를 이용
    - 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다
  - 비유 : 사슬의 내구성은 사슬 중 가장 약한 연결고리의 내구성과 같다
    - 운영체제는 시스템의 보호를 위해 모든 자원에 대한 접근을 통제해야 한다
    - 운영체제는 시스템의 보안을 위해 모든 접근을 기록해야 한다

## 2.2 사용자와 운영체제 인터페이스(User and Operating System Interface)

- 사용자와 운영체제가 접촉하는 방식 중 3가지 기본적인 방법에 대해 알아본다
  - 명령어 인터프리터(Command Interpreter) - 명령어를 직접 입력
  - 그래픽 기반 사용자 인터페이스(Graphical User Interface) - 운영체제와 접촉하게 함
  - 터치스크린 인터페이스(Touchscreen Interface) - 운영체제와 접촉하게 함

### 2.2.1 명령 인터프리터 (Command Interpreter)

- 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다
- 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 인터프리터는 `셸(Shell)`이라고 불린다
  - 내 생각) 책에선 `해석기`라고 번역했는데, `인터프리터`가 더 적절한 것 같다
- 예를 들면, UNIX나 Linux에서는 Bourne shell, C shell, Bourne Again shell, Korn shell 등을 포함하여 사용자가 선택할 수 있는 여러 셸이 제공된다
  - macOS의 bash(Bourne-Again Shell) 셸 명령 인터프리터
- 대부분 셸은 유사한 기능을 제공하며, 사용자가 어느 셸을 사용할 것인가를 결정하는 것은 개인적 취향에 따라 달라진다

---

- `명령 인터프리터`의 중요한 기능은 `사용자가 지정한 명령`을 가져와서 그것을 `수행`하는 것이다
- 이때 제공된 많은 명령은 파일을 조작한다
- 즉, 생성, 삭제, 리스트, 프린트, 복사, 실행 등을 한다
- 이 명령어들은 두 가지 일반적인 방식으로 구현될 수 있다

---

#### 명령어 구현 방식

- 한 가지 방법은 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우이다
  - 예를 들면, 한 파일을 삭제하기 위한 명령은 명령 인터프리터가 자신의 코드의 한 부분으로 분기하고,
    - 그 코드 부분이 매개변수를 설정하고 적절한 시스템 콜을 한다
- 다른 대안의 접근 방법(UNIX에 의해 사용됨)
  - 다른 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다
  - 이러한 경우 명령 인터프리터는 전혀 그 명령을 알지 못한다
  - 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다
    - https://glanceyes.com/entry/Linux-Shell-Command-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%89%98-%EB%AA%85%EB%A0%B9%EC%96%B4
  - 따라서 파일을 삭제하는 다음의 UNIX 명령은 `rm {파일명.확장자}`이다
    - `rm fileName.txt`
    - rm 이라 불리는 파일을 찾아서, 그 파일을 메모리에 적재하고, 그것을 매개변수 fileName.txt로 수행한다
    - rm 명령과 관련된 로직은 rm이라는 파일 내의 코드로 완전하게 정의된다
  - 이러한 방법으로, 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다
  - 명령 인터프리터 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다

### 2.2.2 그래픽 기반 사용자 인터페이스(Graphical User Interface, GUI)

- 운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식이다
- 이 방식에서는 CLI를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 `데스크톱`이라고 특정지어지는 마우스를 기반으로하는 윈도 메뉴 시스템을 사용한다
- 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의 이미지(아이콘)에 위치시킨다
- 마우스 포인터의 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나 파일 혹은 디렉터리(폴더)를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 잡아당길 수도 있다

### 2.2.3 터치스크린 인터페이스(Touchscreen Interface)

- 대부분의 모바일 시스템에는 CLI나 마우스 및 키보드 시스템이 실용적이지 않기 때문에 터치스크린 인터페이스를 사용한다
  - 터치, 스와이프 등의 제스처

### 2.2.4 인터페이스의 선택(Choice of interface)

- CLI 또는 GUI를 사용할 것인지는 개인의 선호에 달려있다
- 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 CLI를 사용한다
  - 그들은 하고자 하는 작업에 더 빨리 접근할 수 있으므로 CLI가 더 효율적이다
- 사실 몇몇 시스템에서는 GUI를 통해서는 시스템 기능의 일부만 이용할 수 있고 자주 쓰이지 않는 나머지 기능은 CLI를 사용할 수 있는 사용자만이 이용할 수 있다
- 게다가 CLI는 보통 반복적으로 해야하는 작업을 쉽게 할 수 있게 하는데, 프로그래밍이 가능하기 때문이다

  - 예를 들면, 자주 사용되는 작업이 command-line의 여러 절차가 필요로 하다면, 이 절차를 파일로 저장하고, 이 파일을 프로그램을 실행하는 것 처럼 이용할 수 있다
  - 이러한 프로그램은 실행 가능한 기계어 코드로 컴파일 되지는 않지만 CLI에 의해 번역되면서 실행될 수 있다
  - 이러한 셸 스크립트(Shell Script)는 UNIX와 Linux와 같이 CLI에 기반을 둔 시스템에서는 매우 흔한 형태이다

- 반면 대부분의 Windows 사용자들은 Windows GUI환경에서 작업하기를 원하며 셸 인터페이스는 거의 사용하지 않는다
  - 최신 버전의 Windows 운영체제는 데스크톱 및 일반 랩톱용 표준 GUI와 태블릿용 터치스크린을 모두 제공한다
- Macintosh운영체제가 겪은 다양한 변화는 대조적인 면을 보여준다

  - 역사적으로 Mac OS는 GUI를 통해서만 운영체제와 상호작용하게 하면서 CLI를 제공하지 않았다
  - 그러나 macOS(부분적으로 UNIX 커널을 이용하여 구현됨)의 출시와 더불어 현재는 Aqua GUI와 CLI를 함께 제공한다
  - 그림 2.4는 macOS의 GUI의 화면을 보여준다

- iOS 및 Android 모바일 시스템에 CLI를 제공하는 앱이 있지만 거의 사용되지 않는다
  - 대신 거의 모든 모바일 시스템 사용자가 터치 스크린 인터페이스를 사용하여 장치와 상호 작용한다

---

- 사용자 인터페이스는 시스템마다 심지어 한 시스템의 사용자마다 다를 수 있다
- 그러나 통상 실제 시스템 구조에서는 제외되었다
- 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것은 운영체제의 직접적인 기능은 아니다
- 이 책에서는, 사용자 프로그램에 적절한 서비스를 제공하는 데 있어서 근본적인 문제점들에 초점을 맞춘다
- `운영체제의 관점`에서, 우리는 `사용자 프로그램과 시스템 프로그램`을 `구별하지 않는다`

## 2.3 시스템 콜

- 커널에 요청하여 커널 모드에서 처리하고 그 결과를 사용자 모드의 프로그램에게 전달하는 것이 바로 시스템 콜이다.
  - https://namu.wiki/w/%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%BD%9C
- `시스템 콜`은 운영체제에 의해 사용 가능하게 된 `서비스에 대한 인터페이스`를 제공한다
- 특정 저수준 작업(예를 들면 하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 `호출`은 일반적으로 `C와 C++언어로 작성된 함수 형태로 제공`된다

### 2.3.1 예제(Example)

#### 시스템콜 사용 예

- 파일 데이터를 읽어서 다른 파일로 복사하는 프로그램

- 파일 복사 방법 1
  - 프로그램이 필요로 하는 첫 번째 입력 : 두 개의 파일 이름 - 입력 파일과 출력 파일
  - 이 이름들은 운영체제 설계에 따라 여러 가지 방법으로 지정할 수 있다

```
# 입력 파일 in.txt를 출력 파일 out.txt
cp in.txt out.txt
```

- 파일 복사 방법 2
  - 프로그램이 사용자에게 이름을 요청하는 것
  - 대화형 시스템에서 이 방법은 일련의 `시스템 콜이 필요`하다
    - 화면에 프롬프트(prompt:사용자의 명령을 받아들일 준비가 되었음을 모니터에 나타내는 표시) 메시지를 작성한 다음
    - 키보드에서 두 파일의 이름을 지정하는 문자를 읽는다
    - 마우스 기반 및 아이콘 기반 시스템에서 파일 이름 메뉴는 일반적으로 창에 표시된다
    - 그런 다음 사용자는 마우스를 사용하여 소스 이름을 선택할 수 있으며 대상 이름을 지정할 수 있는 창을 열 수 있다
    - 이 일련의 작업을 위해서 `I/O 시스템 콜`이 필요하다
- 책에 이어서 나온 시스템콜의 다양한 종류들이 나오는 데 이쯤 되니 시스템콜을 사용하지 않는 작업은 거의 없는 것 같다
  - 사용자 -> 시스템콜 -> 운영체제 -> 하드웨어

### 2.3.2 응용 프로그래밍 인터페이스(Application Programming Interface)

- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하게 된다
- 종종 초당 수천 개의 시스템 콜을 수행하게 된다
- 사용자 대부분은, 이러한 정도의 상세를 결코 알지 못한다
- 대부분의 어플리케이션 개발자들은 API(application programming interface)에 따라 프로그램을 설계한다
- API는 운영체제의 기능을 제공하는 함수의 집합이다
  - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다
- 어플리케이션 개발자가 사용 가능한 가장 흔한 세 가지 API는
  - 1. Windows 시스템을 위한 Windows API
  - 2. POSIX 기반 시스템을 위한 POSIX API(거의 모든 버전의 UNIX, Linux 및 Mac OS X를 포함한다)
    - POSIX(portable operating system interface) : 이식 가능 운영 체제 인터페이스
      - https://ko.wikipedia.org/wiki/POSIX
  - 3. JVM(Java Virtual Machine)에서 실행될 수 있는 프로그램을 위한 Java API이다
- 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통하여 API를 활용한다
- UNIX와 Linux 시스템에서 C언어로 작성된 프로그램을 위해서 제공되는 라이브러리는 `libc`로 불린다
- 특별히 언급하지 않는 한 이 책에서 사용되는 시스템 콜의 이름은 일반적인 예 이다
- 모든 운영체제는 고유의 시스템 콜 이름을 가진다
- API를 구성하는 함수들은 어플리케이션 개발자를 대신하여 실제 시스템 콜을 호출한다
  - 예를 들면 Windows 함수 CreateProcess()는 실제로 Windows 커널의 NTCreateProcess() 시스템 콜을 호출한다
    - CreateProcess() : 프로세스를 생성하는 함수
- 어플리케이션 프로그래머는 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍하는 것을 왜 선호하는 가?
  - 프로그램의 호환성 때문
    - API에 따라 프로그램을 설계하는 어플리케이션 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서든 컴파일되고 실행된다는 것을 기대할 수 있다
      - 현실적으로는 컴퓨터 구조의 차이 때문에 보이는 것보다 쉽지는 않다

#### 표준 API의 예

- 표준 API의 예로서 UNIX와 Linux 시스템에서 제공되는 read() 함수를 고려하자
- 이 함수에 대한 API는 명령어 라인에 다음 명령어를 입력하여 출력되는 man 페이지에서 얻을 수 있다

```c
# include <unistd.h>
ssize_t read(int fd, void *buf, size_t count)
```

- read() 함수를 사용하는 프로그램은 unistd.h 헤더 파일을 포함시켜야 하는데,
- 이 파일은 무엇보다도 ssize_t와 size_t 데이터 유형이 정의되어 있다
- read() 함수에게 전달되는 인자는 다음과 같다

  - int fd : 파일 디스크립터
  - void \*buf : 읽어들인 데이터를 저장할 버퍼
  - size_t count : 버퍼로 읽어들일 수 있는 최대 바이트 수

- 읽기가 성공한 경우 읽어 들인 바이트 수가 반환된다
  - 반환 값이 0인 경우는 파일의 끝에 도달했다는 것을 의미한다
- 읽기가 실패한 경우 -1이 반환된다

#### 실행시간 환경(Run-Time Environment)

- https://ko.wikipedia.org/wiki/%EB%9F%B0%ED%83%80%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C
- 시스템 콜을 처리하는 데 있어 중요한 또 다른 요소는 `실행 시간 환경(RTE)`이다
  - 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 `응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군`과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다
- RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 `시스템 콜 인터페이스를 제공`한다
- 호출자는 시스템콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다
- 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다
- 따라서 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 RTE에 의해 관리된다

#### 운영체제에 매개변수를 전달하기 위한 방법

- 매개 변수를 레지스터 내에 전달하는 것
- (레지스터보다 더 많은 매개변수 ->)매개변수를 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소가 레지스터 내에 매개변수로 전달된다
- Linux는 이러한 접근 법을 조합하여 사용한다
  - 5개 이하의 매개변수가 있으면 레지스터가 사용된다
  - 매개변수가 5개를 넘으면 블록 방법이 사용된다
- 매개변수는 프로그램에 의해 스택(stack)에 넣어질(push) 수 있고, 운영체제에 의해 꺼내진다(pop off)
- 일부 운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다

### 2.3.3 시스템 콜의 유형(Types of System Calls)

- 시스템콜은 다섯 가지의 중요한 범주, 즉 프로세스 제어, 파일 조작, 장치 조작, 정보 유지보수, 통신, 보호 등으로 묶을 수 있다

#### 그림 2.8 시스템 콜의 유형

- 프로세스 제어(Process Control)
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성, 프로세스 종료
  - 프로세스 속성(attributes) 획득, 프로세스 속성 설정
  - 시간을 기다림
  - 이벤트를 기다림(wait event), 이벤트를 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작(File Manipulation)
  - 파일 생성, 파일 삭제
  - 열기, 닫기
  - 읽기, 쓰기, 위치 변경(reposition)
  - 파일 속성 획득 및 설정
- 장치 관리(Device Management)
  - 장치를 요구, 장치를 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착 또는 분리
- 정보 유지(Information Maintenance)
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신(Communication)
  - 통신 연결의 생성, 제거
  - 메시지의 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착(attach) 및 분리(detach)
- 보호(Protection)
  - get file permission
  - set file permission

#### 2.3.3.1 프로세스 제어(Process Control)

- 실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다
- 만약 현재 실행 중인 프로그램을 비정상으로 중지하기 위해 `시스템 콜`이 호출되거나
  - 프로그램에 문제가 발생해 오류 `트랩(trap)`을 유발할 경우,
    - 트랩 : 프로세스가 특정 시스템 기능을 사용하려고 할 때 그 기능을 운영체제에게 요청하는 방법 - 소프트웨어적 `<->` 인터럽트 : 하드웨어적
      - https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%A9_(%EC%BB%B4%ED%93%A8%ED%8C%85)
  - 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다
- 이 덤프는 특별한 로그 파일이나 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다
- 정상이거나 비정상인 상황에서, 운영체제는 명령 인터프리터로 제어를 전달해야 한다
- 대화식 시스템에서 명령 인터프리터는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다
  - GUI 시스템에서는 팝업 윈도가 사용자에게 오류를 알리고 지시를 기다린다
- 한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(load())하고 실행(execute()) 하기를 원할 수 있다
- 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스 클릭(click)을 통하여 지시된 프로그램을 실행하는 것을 허용한다
- 여기에서 흥미있는 질문은 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐 하는 것이다
  - 이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련 있다
  - 만약 새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다
    - 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다
  - 만약 두 프로그램이 병행하게 수행된다면, 우리는 다중 프로그래밍 될 새로운 프로세스를 생성한 것이다
    - 종종, 이런 특정 목적을 위한 시스템 콜이 있다(Windows: create_process() ~ Unix: fork())
  - 만약 우리가 새로운 잡이나 프로세스, 혹은 잡들이나 프로세스들의 집합을 생성한다면, 우리는 그들의 실행을 제어할 수 있어야 한다
    - 이러한 제어는 잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 잡 혹은 프로세스의 속성을 결정하고 재설정(reset)할 수 있는 능력이 필요하다
      - get_process_attributes(), set_process_attributes()
    - 또한 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다(terminate_process())
  - ...
- 병행 프로세스들의 조정(coordination)을 처리하는 이런 유형의 시스템 콜은 6장과 7장에서 상세히 논의된다
- 프로세스 제어는 너무 많은 측면과 다양성이 있으므로 이러한 개념들을 명확히 하기 위해 단일 태스킹 시스템과 다중 태스킹 시스템의 두 예를 사용할 것이다
  - Arduino는 마이크로 컨트롤러와 다양한 이벤트에 반응하는 입력 센서로 구성된 간단한 하드웨어 플랫폼이다
    - Arduino 플랫폼은 운영체제를 제공하지 않는다
    - 대신 `부트 로더`로 불리는 작은 소프트웨어가 스케치(USB연결을 통해 컴파일된 프로그램)를 Arduino에 적재(load)한다
    - Arduino는 한 순간에 하나의 스케치만 메모리에 존재할 수 있으므로 단일 태스킹 시스템으로 간주된다
  - FreeBSD(Berkeley UNIX로부터 비롯됨)는 다중 태스킹 시스템의 예이다
    - 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행한다
    - FreeBSD는 다중 태스킹 시스템이기 때문에 명령 인터프리터는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있다
    - 새로운 프로세스를 시작하기 위해 셸은 fork() 시스템 콜을 실행한다
    - ...

#### 2.3.3.2 파일 관리(file management)
