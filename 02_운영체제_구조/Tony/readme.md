# 2. 운영체제 구조(Operating system structures)

- 운영체제는 운영체제 안에서 프로그램이 실행되는 환경을 제공해 준다
- 운영체제들의 구조는 크게 차이가 있다
- 새로운 운영체제를 설계하는 일은 대단히 큰 작업이다
- 설계를 시작하기 전에 시스템의 목표를 먼저 잘 정의하는 것이 중요하다
- 목표는 여러 가지 전략과 알고리즘 중에서 선택하는 기초가 된다
- 운영체제를 살펴보기 위한 몇 가지 유리한 관점이 있다
  - 첫 번째 관점 : 운영체제가 제공하는 `서비스`에 초점을 맞추는 것 - 사용자
  - 두 번째 관점 : 운영체제가 사용자와 프로그래머에게 제공하는 `인터페이스`에 초점을 맞추는 것 - 프로그래머
  - 세 번째 관점 : `시스템의 구성요소`와 `그들의 상호 연결`에 초점을 맞추는 것 - 운영체제 설계자
- 이번 장에서 사용자, 프로그래머, 그리고 운영체제 설계자의 관점에서 바라본 운영체제의 `세 가지 측면을 모두` 살펴본다
  - 운영체제가 제공하는 `서비스`
  - `서비스 제공 방식`
  - 이 서비스는 어떤 방식으로 제공되는지 - `서비스 제공 방식`
  - 이 서비스들은 어떻게 `디버깅`되며, 이러한 `시스템을 설계하기 위해서는 어떤 다양한 방법`들이 사용되는지 고려한다
- 내 생각) 서비스 : 운영체제가 제공하는 기능들

#### 이 장의 목표

- 운영체제에서 제공하는 서비스를 식별한다
- 운영체제 서비스를 제공하기 위해 시스템 콜을 사용하는 방법을 설명한다
- 운영체제 설계를 위한 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략을 비교 및 대조한다
- 운영체제 부팅 프로세스를 설명한다
- 운영체제 성능을 모니터링하기 위한 도구를 적용한다
- Linux 커널과 상호 작용하기 위한 커널 모듈을 설계하고 구현한다

## 2.1 운영체제 서비스(Operating System Services)

- 운영체제는 프로그램 실행환경을 제공한다
- 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다
- 운영체제 마다 제공하는 서비스는 다르지만 공통된 부류가 있다

  - 그림 2.1 다양한 운영체제 서비스에 대한 한 가지 관점과 그들의 상호 관계
  - 이러한 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 한다

- 사용자 인터페이스(user interface)

  - 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다
  - 이 인터페이스는 여러 형태로 제공될 수 있다
  - 가장 일반적으로 그래픽 사용자 인터페이스(GUI)가 사용된다
  - 인터페이스란?
    - 윈도 시스템으로 마우스와 키보드를 가지고 있다
  - 휴대전화 및 태블릿과 같은 모바일 시스템 -> 터치 스크린 인터페이스를 제공
  - CLI(Command Line Interface) : 터미널을 통해 명령어를 입력하는 방식

- 프로그램 수행(program execution)

  - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다
  - 프로그램은 정상적이든, 혹은 비정상적이든 실행을 끝낼 수 있어야 한다

- 입출력 연산(I/O operation)

  - 수행 중인 프로그램은 입출력을 요구할 수 있다
  - 이러한 입출력에는 파일 혹은, 입출력 장치가 연관될 수 있다
  - 특정 장치에 대해서는 특수한 기능(네트워크 인터페이스에서 읽거나 파일 시스템에 쓰기 등)이 요구될 수 있다
  - 효율과 보호를 위해 사용자들은 입출력 장치를 직접 제어할 수 없다
  - 운영체제가 입출력 수행의 수단을 제공해야 한다
    - 내 생각) 키보드, 마우스 연결하면 운영체제가 이를 인식하고, 사용자가 입력한 내용을 읽어들인다

- 통신(communication)

  - 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 상황이 있다
  - 이러한 통신을 수행하는 두 가지 중요한 방법
    - 1. 동일한 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
    - 2. (네트워크에 의해 묶여있는)다른 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
  - 통신 구현 방법
    - 1. 공유 메모리
    - 2. 메시지 전달(message passing) 기법
      - `정보의 패킷`들이 운영체제에 의해 `프로세스들 사이를 이동`한다
      - 내 생각) HTTP와 비슷하네, 네트워크로 연결된 컴퓨터들이 HTTP 방식으로 패킷을 주고 받는 것과 비슷한 것 같다
        - 메시지 전달 기법 또는 공유 메모리도 어떤 규약(protocol)을 따르는 것인가?

- 오류 탐지(error detection)
  - 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다
  - 오류는 CPU, 메모리, 입출력 장치, 사용자 프로그램에서 일어날 수 있다
  - 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 해야 한다
  - 디버깅 설비는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상 시킨다

#### 사용자에 도움을 주는 것이 목적이 아니라 `시스템 자체의 효율적인 동작을 보장`하기 위한 운영체제 기능들도 존재한다

- 자원 할당(resource allocation)

  - 다수의 프로세스나 다수의 작업이 `동시에 실행`될 때, 그들 각각에 `자원을 할당`해 주어야 한다
  - 운영체제가 관리하는 여러가지 자원 관리 예시
    - CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야할 프로세스들(우선순위), CPU의 처리 코어의 개수와 다른 요인들을 고려하도록 해야 한다
    - 프린터, USB 저장장치 및 다른 주변 장치를 할당하는 루틴

- 기록 장성(logging)

  - 우리는 어떤 프로그램이 어떤 종류의 컴퓨터 `자원`을 얼마나 많이 `사용`하는지를 `추적`할 수 있길 원한다
  - 로깅은 사용 예
    - 회계 - 사용자들에게 청구서를 보내기 위해
    - 사용 통계
      - 사용통계는 시스템을 재구성하고자 하는 시스템 관리자에게 귀중한 자료가 될 수 있다

- 보호(protection)와 보안(security)
  - 정보 소유자는 그 정보의 사용을 통제하길 원한다
  - 서로 다른 여러 프로세스가 병행하게 수행될 때, 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 된다
  - `보호`는 시스템 자원에 대한 모든 `접근이 통제`되도록 보장하는 것을 필요로 한다
  - 보안 - 사용자가 인증하는 것으로 부터 시작
    - 일반적으로 비밀번호를 이용
    - 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다
  - 비유 : 사슬의 내구성은 사슬 중 가장 약한 연결고리의 내구성과 같다
    - 운영체제는 시스템의 보호를 위해 모든 자원에 대한 접근을 통제해야 한다
    - 운영체제는 시스템의 보안을 위해 모든 접근을 기록해야 한다

## 2.2 사용자와 운영체제 인터페이스(User and Operating System Interface)

- 사용자와 운영체제가 접촉하는 방식 중 3가지 기본적인 방법에 대해 알아본다
  - 명령어 인터프리터(Command Interpreter) - 명령어를 직접 입력
  - 그래픽 기반 사용자 인터페이스(Graphical User Interface) - 운영체제와 접촉하게 함
  - 터치스크린 인터페이스(Touchscreen Interface) - 운영체제와 접촉하게 함

### 2.2.1 명령 인터프리터 (Command Interpreter)

- 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다
- 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 인터프리터는 `셸(Shell)`이라고 불린다
  - 내 생각) 책에선 `해석기`라고 번역했는데, `인터프리터`가 더 적절한 것 같다
- 예를 들면, UNIX나 Linux에서는 Bourne shell, C shell, Bourne Again shell, Korn shell 등을 포함하여 사용자가 선택할 수 있는 여러 셸이 제공된다
  - macOS의 bash(Bourne-Again Shell) 셸 명령 인터프리터
- 대부분 셸은 유사한 기능을 제공하며, 사용자가 어느 셸을 사용할 것인가를 결정하는 것은 개인적 취향에 따라 달라진다

---

- `명령 인터프리터`의 중요한 기능은 `사용자가 지정한 명령`을 가져와서 그것을 `수행`하는 것이다
- 이때 제공된 많은 명령은 파일을 조작한다
- 즉, 생성, 삭제, 리스트, 프린트, 복사, 실행 등을 한다
- 이 명령어들은 두 가지 일반적인 방식으로 구현될 수 있다

---

#### 명령어 구현 방식

- 한 가지 방법은 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우이다
  - 예를 들면, 한 파일을 삭제하기 위한 명령은 명령 인터프리터가 자신의 코드의 한 부분으로 분기하고,
    - 그 코드 부분이 매개변수를 설정하고 적절한 시스템 콜을 한다
- 다른 대안의 접근 방법(UNIX에 의해 사용됨)
  - 다른 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다
  - 이러한 경우 명령 인터프리터는 전혀 그 명령을 알지 못한다
  - 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다
    - https://glanceyes.com/entry/Linux-Shell-Command-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%89%98-%EB%AA%85%EB%A0%B9%EC%96%B4
  - 따라서 파일을 삭제하는 다음의 UNIX 명령은 `rm {파일명.확장자}`이다
    - `rm fileName.txt`
    - rm 이라 불리는 파일을 찾아서, 그 파일을 메모리에 적재하고, 그것을 매개변수 fileName.txt로 수행한다
    - rm 명령과 관련된 로직은 rm이라는 파일 내의 코드로 완전하게 정의된다
  - 이러한 방법으로, 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다
  - 명령 인터프리터 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다

### 2.2.2 그래픽 기반 사용자 인터페이스(Graphical User Interface, GUI)

- 운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식이다
- 이 방식에서는 CLI를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 `데스크톱`이라고 특정지어지는 마우스를 기반으로하는 윈도 메뉴 시스템을 사용한다
- 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의 이미지(아이콘)에 위치시킨다
- 마우스 포인터의 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나 파일 혹은 디렉터리(폴더)를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 잡아당길 수도 있다

### 2.2.3 터치스크린 인터페이스(Touchscreen Interface)

- 대부분의 모바일 시스템에는 CLI나 마우스 및 키보드 시스템이 실용적이지 않기 때문에 터치스크린 인터페이스를 사용한다
  - 터치, 스와이프 등의 제스처

### 2.2.4 인터페이스의 선택(Choice of interface)

- CLI 또는 GUI를 사용할 것인지는 개인의 선호에 달려있다
- 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 CLI를 사용한다
  - 그들은 하고자 하는 작업에 더 빨리 접근할 수 있으므로 CLI가 더 효율적이다
- 사실 몇몇 시스템에서는 GUI를 통해서는 시스템 기능의 일부만 이용할 수 있고 자주 쓰이지 않는 나머지 기능은 CLI를 사용할 수 있는 사용자만이 이용할 수 있다
- 게다가 CLI는 보통 반복적으로 해야하는 작업을 쉽게 할 수 있게 하는데, 프로그래밍이 가능하기 때문이다

  - 예를 들면, 자주 사용되는 작업이 command-line의 여러 절차가 필요로 하다면, 이 절차를 파일로 저장하고, 이 파일을 프로그램을 실행하는 것 처럼 이용할 수 있다
  - 이러한 프로그램은 실행 가능한 기계어 코드로 컴파일 되지는 않지만 CLI에 의해 번역되면서 실행될 수 있다
  - 이러한 셸 스크립트(Shell Script)는 UNIX와 Linux와 같이 CLI에 기반을 둔 시스템에서는 매우 흔한 형태이다

- 반면 대부분의 Windows 사용자들은 Windows GUI환경에서 작업하기를 원하며 셸 인터페이스는 거의 사용하지 않는다
  - 최신 버전의 Windows 운영체제는 데스크톱 및 일반 랩톱용 표준 GUI와 태블릿용 터치스크린을 모두 제공한다
- Macintosh운영체제가 겪은 다양한 변화는 대조적인 면을 보여준다

  - 역사적으로 Mac OS는 GUI를 통해서만 운영체제와 상호작용하게 하면서 CLI를 제공하지 않았다
  - 그러나 macOS(부분적으로 UNIX 커널을 이용하여 구현됨)의 출시와 더불어 현재는 Aqua GUI와 CLI를 함께 제공한다
  - 그림 2.4는 macOS의 GUI의 화면을 보여준다

- iOS 및 Android 모바일 시스템에 CLI를 제공하는 앱이 있지만 거의 사용되지 않는다
  - 대신 거의 모든 모바일 시스템 사용자가 터치 스크린 인터페이스를 사용하여 장치와 상호 작용한다

---

- 사용자 인터페이스는 시스템마다 심지어 한 시스템의 사용자마다 다를 수 있다
- 그러나 통상 실제 시스템 구조에서는 제외되었다
- 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것은 운영체제의 직접적인 기능은 아니다
- 이 책에서는, 사용자 프로그램에 적절한 서비스를 제공하는 데 있어서 근본적인 문제점들에 초점을 맞춘다
- `운영체제의 관점`에서, 우리는 `사용자 프로그램과 시스템 프로그램`을 `구별하지 않는다`

## 2.3 시스템 콜

- `시스템 콜`은 운영체제에 의해 사용 가능하게 된 `서비스에 대한 인터페이스`를 제공한다
- 특정 `저수준 작업`(예를 들면 하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 `호출`은 일반적으로 `C와 C++언어로 작성된 함수 형태로 제공`된다

### 2.3.1 예제(Example)

- 운영체제가 어떻게 시스템콜을 사용할 수있게 만드는지에 대해 논의하기 전에 시스템 콜이 어떻게 사용되는지를 설명하는 예를 보도록 하자
