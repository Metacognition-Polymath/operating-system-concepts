# 2. 운영체제 구조(Operating system structures)

- 운영체제는 운영체제 안에서 프로그램이 실행되는 환경을 제공해 준다
- 운영체제들의 구조는 크게 차이가 있다
- 새로운 운영체제를 설계하는 일은 대단히 큰 작업이다
- 설계를 시작하기 전에 시스템의 목표를 먼저 잘 정의하는 것이 중요하다
- 목표는 여러 가지 전략과 알고리즘 중에서 선택하는 기초가 된다
- 운영체제를 살펴보기 위한 몇 가지 유리한 관점이 있다
  - 첫 번째 관점 : 운영체제가 제공하는 `서비스`에 초점을 맞추는 것 - 사용자
  - 두 번째 관점 : 운영체제가 사용자와 프로그래머에게 제공하는 `인터페이스`에 초점을 맞추는 것 - 프로그래머
  - 세 번째 관점 : `시스템의 구성요소`와 `그들의 상호 연결`에 초점을 맞추는 것 - 운영체제 설계자
- 이번 장에서 사용자, 프로그래머, 그리고 운영체제 설계자의 관점에서 바라본 운영체제의 `세 가지 측면을 모두` 살펴본다
  - 운영체제가 제공하는 `서비스`
  - `서비스 제공 방식`
  - 이 서비스는 어떤 방식으로 제공되는지 - `서비스 제공 방식`
  - 이 서비스들은 어떻게 `디버깅`되며, 이러한 `시스템을 설계하기 위해서는 어떤 다양한 방법`들이 사용되는지 고려한다
- 내 생각) 서비스 : 운영체제가 제공하는 기능들

#### 이 장의 목표

- 운영체제에서 제공하는 서비스를 식별한다
- 운영체제 서비스를 제공하기 위해 시스템 콜을 사용하는 방법을 설명한다
- 운영체제 설계를 위한 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략을 비교 및 대조한다
- 운영체제 부팅 프로세스를 설명한다
- 운영체제 성능을 모니터링하기 위한 도구를 적용한다
- Linux 커널과 상호 작용하기 위한 커널 모듈을 설계하고 구현한다

## 2.1 운영체제 서비스(Operating System Services)

- 운영체제는 프로그램 실행환경을 제공한다
- 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다
- 운영체제 마다 제공하는 서비스는 다르지만 공통된 부류가 있다

  - 그림 2.1 다양한 운영체제 서비스에 대한 한 가지 관점과 그들의 상호 관계
  - 이러한 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 한다

- 사용자 인터페이스(user interface)

  - 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다
  - 이 인터페이스는 여러 형태로 제공될 수 있다
  - 가장 일반적으로 그래픽 사용자 인터페이스(GUI)가 사용된다
  - 인터페이스란?
    - 윈도 시스템으로 마우스와 키보드를 가지고 있다
  - 휴대전화 및 태블릿과 같은 모바일 시스템 -> 터치 스크린 인터페이스를 제공
  - CLI(Command Line Interface) : 터미널을 통해 명령어를 입력하는 방식

- 프로그램 수행(program execution)

  - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다
  - 프로그램은 정상적이든, 혹은 비정상적이든 실행을 끝낼 수 있어야 한다

- 입출력 연산(I/O operation)

  - 수행 중인 프로그램은 입출력을 요구할 수 있다
  - 이러한 입출력에는 파일 혹은, 입출력 장치가 연관될 수 있다
  - 특정 장치에 대해서는 특수한 기능(네트워크 인터페이스에서 읽거나 파일 시스템에 쓰기 등)이 요구될 수 있다
  - 효율과 보호를 위해 사용자들은 입출력 장치를 직접 제어할 수 없다
  - 운영체제가 입출력 수행의 수단을 제공해야 한다
    - 내 생각) 키보드, 마우스 연결하면 운영체제가 이를 인식하고, 사용자가 입력한 내용을 읽어들인다

- 통신(communication)

  - 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 상황이 있다
  - 이러한 통신을 수행하는 두 가지 중요한 방법
    - 1. 동일한 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
    - 2. (네트워크에 의해 묶여있는)다른 컴퓨터에서 수행되고 있는 프로세스들 간의 통신
  - 통신 구현 방법
    - 1. 공유 메모리
    - 2. 메시지 전달(message passing) 기법
      - `정보의 패킷`들이 운영체제에 의해 `프로세스들 사이를 이동`한다
      - 내 생각) HTTP와 비슷하네, 네트워크로 연결된 컴퓨터들이 HTTP 방식으로 패킷을 주고 받는 것과 비슷한 것 같다
        - 메시지 전달 기법 또는 공유 메모리도 어떤 규약(protocol)을 따르는 것인가?

- 오류 탐지(error detection)
  - 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다
  - 오류는 CPU, 메모리, 입출력 장치, 사용자 프로그램에서 일어날 수 있다
  - 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 해야 한다
  - 디버깅 설비는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상 시킨다

#### 사용자에 도움을 주는 것이 목적이 아니라 `시스템 자체의 효율적인 동작을 보장`하기 위한 운영체제 기능들도 존재한다

- 자원 할당(resource allocation)

  - 다수의 프로세스나 다수의 작업이 `동시에 실행`될 때, 그들 각각에 `자원을 할당`해 주어야 한다
  - 운영체제가 관리하는 여러가지 자원 관리 예시
    - CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야할 프로세스들(우선순위), CPU의 처리 코어의 개수와 다른 요인들을 고려하도록 해야 한다
    - 프린터, USB 저장장치 및 다른 주변 장치를 할당하는 루틴

- 기록 장성(logging)

  - 우리는 어떤 프로그램이 어떤 종류의 컴퓨터 `자원`을 얼마나 많이 `사용`하는지를 `추적`할 수 있길 원한다
  - 로깅은 사용 예
    - 회계 - 사용자들에게 청구서를 보내기 위해
    - 사용 통계
      - 사용통계는 시스템을 재구성하고자 하는 시스템 관리자에게 귀중한 자료가 될 수 있다

- 보호(protection)와 보안(security)
  - 정보 소유자는 그 정보의 사용을 통제하길 원한다
  - 서로 다른 여러 프로세스가 병행하게 수행될 때, 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 된다
  - `보호`는 시스템 자원에 대한 모든 `접근이 통제`되도록 보장하는 것을 필요로 한다
  - 보안 - 사용자가 인증하는 것으로 부터 시작
    - 일반적으로 비밀번호를 이용
    - 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다
  - 비유 : 사슬의 내구성은 사슬 중 가장 약한 연결고리의 내구성과 같다
    - 운영체제는 시스템의 보호를 위해 모든 자원에 대한 접근을 통제해야 한다
    - 운영체제는 시스템의 보안을 위해 모든 접근을 기록해야 한다

## 2.2 사용자와 운영체제 인터페이스(User and Operating System Interface)

- 사용자와 운영체제가 접촉하는 방식 중 3가지 기본적인 방법에 대해 알아본다
  - 명령어 인터프리터(Command Interpreter) - 명령어를 직접 입력
  - 그래픽 기반 사용자 인터페이스(Graphical User Interface) - 운영체제와 접촉하게 함
  - 터치스크린 인터페이스(Touchscreen Interface) - 운영체제와 접촉하게 함

### 2.2.1 명령 인터프리터 (Command Interpreter)

- 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다
- 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 인터프리터는 `셸(Shell)`이라고 불린다
  - 내 생각) 책에선 `해석기`라고 번역했는데, `인터프리터`가 더 적절한 것 같다
- 예를 들면, UNIX나 Linux에서는 Bourne shell, C shell, Bourne Again shell, Korn shell 등을 포함하여 사용자가 선택할 수 있는 여러 셸이 제공된다
  - macOS의 bash(Bourne-Again Shell) 셸 명령 인터프리터
- 대부분 셸은 유사한 기능을 제공하며, 사용자가 어느 셸을 사용할 것인가를 결정하는 것은 개인적 취향에 따라 달라진다

---

- `명령 인터프리터`의 중요한 기능은 `사용자가 지정한 명령`을 가져와서 그것을 `수행`하는 것이다
- 이때 제공된 많은 명령은 파일을 조작한다
- 즉, 생성, 삭제, 리스트, 프린트, 복사, 실행 등을 한다
- 이 명령어들은 두 가지 일반적인 방식으로 구현될 수 있다

---

#### 명령어 구현 방식

- 한 가지 방법은 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우이다
  - 예를 들면, 한 파일을 삭제하기 위한 명령은 명령 인터프리터가 자신의 코드의 한 부분으로 분기하고,
    - 그 코드 부분이 매개변수를 설정하고 적절한 시스템 콜을 한다
- 다른 대안의 접근 방법(UNIX에 의해 사용됨)
  - 다른 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다
  - 이러한 경우 명령 인터프리터는 전혀 그 명령을 알지 못한다
  - 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다
    - https://glanceyes.com/entry/Linux-Shell-Command-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%89%98-%EB%AA%85%EB%A0%B9%EC%96%B4
  - 따라서 파일을 삭제하는 다음의 UNIX 명령은 `rm {파일명.확장자}`이다
    - `rm fileName.txt`
    - rm 이라 불리는 파일을 찾아서, 그 파일을 메모리에 적재하고, 그것을 매개변수 fileName.txt로 수행한다
    - rm 명령과 관련된 로직은 rm이라는 파일 내의 코드로 완전하게 정의된다
  - 이러한 방법으로, 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다
  - 명령 인터프리터 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다

### 2.2.2 그래픽 기반 사용자 인터페이스(Graphical User Interface, GUI)

- 운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식이다
- 이 방식에서는 CLI를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 `데스크톱`이라고 특정지어지는 마우스를 기반으로하는 윈도 메뉴 시스템을 사용한다
- 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의 이미지(아이콘)에 위치시킨다
- 마우스 포인터의 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나 파일 혹은 디렉터리(폴더)를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 잡아당길 수도 있다

### 2.2.3 터치스크린 인터페이스(Touchscreen Interface)

- 대부분의 모바일 시스템에는 CLI나 마우스 및 키보드 시스템이 실용적이지 않기 때문에 터치스크린 인터페이스를 사용한다
  - 터치, 스와이프 등의 제스처

### 2.2.4 인터페이스의 선택(Choice of interface)

- CLI 또는 GUI를 사용할 것인지는 개인의 선호에 달려있다
- 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 CLI를 사용한다
  - 그들은 하고자 하는 작업에 더 빨리 접근할 수 있으므로 CLI가 더 효율적이다
- 사실 몇몇 시스템에서는 GUI를 통해서는 시스템 기능의 일부만 이용할 수 있고 자주 쓰이지 않는 나머지 기능은 CLI를 사용할 수 있는 사용자만이 이용할 수 있다
- 게다가 CLI는 보통 반복적으로 해야하는 작업을 쉽게 할 수 있게 하는데, 프로그래밍이 가능하기 때문이다

  - 예를 들면, 자주 사용되는 작업이 command-line의 여러 절차가 필요로 하다면, 이 절차를 파일로 저장하고, 이 파일을 프로그램을 실행하는 것 처럼 이용할 수 있다
  - 이러한 프로그램은 실행 가능한 기계어 코드로 컴파일 되지는 않지만 CLI에 의해 번역되면서 실행될 수 있다
  - 이러한 셸 스크립트(Shell Script)는 UNIX와 Linux와 같이 CLI에 기반을 둔 시스템에서는 매우 흔한 형태이다

- 반면 대부분의 Windows 사용자들은 Windows GUI환경에서 작업하기를 원하며 셸 인터페이스는 거의 사용하지 않는다
  - 최신 버전의 Windows 운영체제는 데스크톱 및 일반 랩톱용 표준 GUI와 태블릿용 터치스크린을 모두 제공한다
- Macintosh운영체제가 겪은 다양한 변화는 대조적인 면을 보여준다

  - 역사적으로 Mac OS는 GUI를 통해서만 운영체제와 상호작용하게 하면서 CLI를 제공하지 않았다
  - 그러나 macOS(부분적으로 UNIX 커널을 이용하여 구현됨)의 출시와 더불어 현재는 Aqua GUI와 CLI를 함께 제공한다
  - 그림 2.4는 macOS의 GUI의 화면을 보여준다

- iOS 및 Android 모바일 시스템에 CLI를 제공하는 앱이 있지만 거의 사용되지 않는다
  - 대신 거의 모든 모바일 시스템 사용자가 터치 스크린 인터페이스를 사용하여 장치와 상호 작용한다

---

- 사용자 인터페이스는 시스템마다 심지어 한 시스템의 사용자마다 다를 수 있다
- 그러나 통상 실제 시스템 구조에서는 제외되었다
- 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것은 운영체제의 직접적인 기능은 아니다
- 이 책에서는, 사용자 프로그램에 적절한 서비스를 제공하는 데 있어서 근본적인 문제점들에 초점을 맞춘다
- `운영체제의 관점`에서, 우리는 `사용자 프로그램과 시스템 프로그램`을 `구별하지 않는다`

## 2.3 시스템 콜

- 커널에 요청하여 커널 모드에서 처리하고 그 결과를 사용자 모드의 프로그램에게 전달하는 것이 바로 시스템 콜이다.
  - https://namu.wiki/w/%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%BD%9C
- `시스템 콜`은 운영체제에 의해 사용 가능하게 된 `서비스에 대한 인터페이스`를 제공한다
- 특정 저수준 작업(예를 들면 하드웨어를 직접 접근해야 하는 작업)은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 `호출`은 일반적으로 `C와 C++언어로 작성된 함수 형태로 제공`된다

### 2.3.1 예제(Example)

#### 시스템콜 사용 예

- 파일 데이터를 읽어서 다른 파일로 복사하는 프로그램

- 파일 복사 방법 1
  - 프로그램이 필요로 하는 첫 번째 입력 : 두 개의 파일 이름 - 입력 파일과 출력 파일
  - 이 이름들은 운영체제 설계에 따라 여러 가지 방법으로 지정할 수 있다

```
# 입력 파일 in.txt를 출력 파일 out.txt
cp in.txt out.txt
```

- 파일 복사 방법 2
  - 프로그램이 사용자에게 이름을 요청하는 것
  - 대화형 시스템에서 이 방법은 일련의 `시스템 콜이 필요`하다
    - 화면에 프롬프트(prompt:사용자의 명령을 받아들일 준비가 되었음을 모니터에 나타내는 표시) 메시지를 작성한 다음
    - 키보드에서 두 파일의 이름을 지정하는 문자를 읽는다
    - 마우스 기반 및 아이콘 기반 시스템에서 파일 이름 메뉴는 일반적으로 창에 표시된다
    - 그런 다음 사용자는 마우스를 사용하여 소스 이름을 선택할 수 있으며 대상 이름을 지정할 수 있는 창을 열 수 있다
    - 이 일련의 작업을 위해서 `I/O 시스템 콜`이 필요하다
- 책에 이어서 나온 시스템콜의 다양한 종류들이 나오는 데 이쯤 되니 시스템콜을 사용하지 않는 작업은 거의 없는 것 같다
  - 사용자 -> 시스템콜 -> 운영체제 -> 하드웨어

### 2.3.2 응용 프로그래밍 인터페이스(Application Programming Interface)

- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하게 된다
- 종종 초당 수천 개의 시스템 콜을 수행하게 된다
- 사용자 대부분은, 이러한 정도의 상세를 결코 알지 못한다
- 대부분의 어플리케이션 개발자들은 API(application programming interface)에 따라 프로그램을 설계한다
- API는 운영체제의 기능을 제공하는 함수의 집합이다
  - API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다
- 어플리케이션 개발자가 사용 가능한 가장 흔한 세 가지 API는
  - 1. Windows 시스템을 위한 Windows API
  - 2. POSIX 기반 시스템을 위한 POSIX API(거의 모든 버전의 UNIX, Linux 및 Mac OS X를 포함한다)
    - POSIX(portable operating system interface) : 이식 가능 운영 체제 인터페이스
      - https://ko.wikipedia.org/wiki/POSIX
  - 3. JVM(Java Virtual Machine)에서 실행될 수 있는 프로그램을 위한 Java API이다
- 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통하여 API를 활용한다
- UNIX와 Linux 시스템에서 C언어로 작성된 프로그램을 위해서 제공되는 라이브러리는 `libc`로 불린다
- 특별히 언급하지 않는 한 이 책에서 사용되는 시스템 콜의 이름은 일반적인 예 이다
- 모든 운영체제는 고유의 시스템 콜 이름을 가진다
- API를 구성하는 함수들은 어플리케이션 개발자를 대신하여 실제 시스템 콜을 호출한다
  - 예를 들면 Windows 함수 CreateProcess()는 실제로 Windows 커널의 NTCreateProcess() 시스템 콜을 호출한다
    - CreateProcess() : 프로세스를 생성하는 함수
- 어플리케이션 프로그래머는 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍하는 것을 왜 선호하는 가?
  - 프로그램의 호환성 때문
    - API에 따라 프로그램을 설계하는 어플리케이션 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서든 컴파일되고 실행된다는 것을 기대할 수 있다
      - 현실적으로는 컴퓨터 구조의 차이 때문에 보이는 것보다 쉽지는 않다

#### 표준 API의 예

- 표준 API의 예로서 UNIX와 Linux 시스템에서 제공되는 read() 함수를 고려하자
- 이 함수에 대한 API는 명령어 라인에 다음 명령어를 입력하여 출력되는 man 페이지에서 얻을 수 있다

```c
# include <unistd.h>
ssize_t read(int fd, void *buf, size_t count)
```

- read() 함수를 사용하는 프로그램은 unistd.h 헤더 파일을 포함시켜야 하는데,
- 이 파일은 무엇보다도 ssize_t와 size_t 데이터 유형이 정의되어 있다
- read() 함수에게 전달되는 인자는 다음과 같다

  - int fd : 파일 디스크립터
  - void \*buf : 읽어들인 데이터를 저장할 버퍼
  - size_t count : 버퍼로 읽어들일 수 있는 최대 바이트 수

- 읽기가 성공한 경우 읽어 들인 바이트 수가 반환된다
  - 반환 값이 0인 경우는 파일의 끝에 도달했다는 것을 의미한다
- 읽기가 실패한 경우 -1이 반환된다

#### 실행시간 환경(Run-Time Environment)

- https://ko.wikipedia.org/wiki/%EB%9F%B0%ED%83%80%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C
- 시스템 콜을 처리하는 데 있어 중요한 또 다른 요소는 `실행 시간 환경(RTE)`이다
  - 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 `응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군`과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다
- RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 `시스템 콜 인터페이스를 제공`한다
- 호출자는 시스템콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다
- 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다
- 따라서 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 RTE에 의해 관리된다

#### 운영체제에 매개변수를 전달하기 위한 방법

- 매개 변수를 레지스터 내에 전달하는 것
- (레지스터보다 더 많은 매개변수 ->)매개변수를 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소가 레지스터 내에 매개변수로 전달된다
- Linux는 이러한 접근 법을 조합하여 사용한다
  - 5개 이하의 매개변수가 있으면 레지스터가 사용된다
  - 매개변수가 5개를 넘으면 블록 방법이 사용된다
- 매개변수는 프로그램에 의해 스택(stack)에 넣어질(push) 수 있고, 운영체제에 의해 꺼내진다(pop off)
- 일부 운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다

### 2.3.3 시스템 콜의 유형(Types of System Calls)

- 시스템콜은 다섯 가지의 중요한 범주, 즉 프로세스 제어, 파일 조작, 장치 조작, 정보 유지보수, 통신, 보호 등으로 묶을 수 있다

#### 그림 2.8 시스템 콜의 유형

- 프로세스 제어(Process Control)
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성, 프로세스 종료
  - 프로세스 속성(attributes) 획득, 프로세스 속성 설정
  - 시간을 기다림
  - 이벤트를 기다림(wait event), 이벤트를 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작(File Manipulation)
  - 파일 생성, 파일 삭제
  - 열기, 닫기
  - 읽기, 쓰기, 위치 변경(reposition)
  - 파일 속성 획득 및 설정
- 장치 관리(Device Management)
  - 장치를 요구, 장치를 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착 또는 분리
- 정보 유지(Information Maintenance)
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신(Communication)
  - 통신 연결의 생성, 제거
  - 메시지의 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착(attach) 및 분리(detach)
- 보호(Protection)
  - get file permission
  - set file permission

#### 2.3.3.1 프로세스 제어(Process Control)

- 실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다
- 만약 현재 실행 중인 프로그램을 비정상으로 중지하기 위해 `시스템 콜`이 호출되거나
  - 프로그램에 문제가 발생해 오류 `트랩(trap)`을 유발할 경우,
    - 트랩 : 프로세스가 특정 시스템 기능을 사용하려고 할 때 그 기능을 운영체제에게 요청하는 방법 - 소프트웨어적 `<->` 인터럽트 : 하드웨어적
      - https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%A9_(%EC%BB%B4%ED%93%A8%ED%8C%85)
  - 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다
- 이 덤프는 특별한 로그 파일이나 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다
- 정상이거나 비정상인 상황에서, 운영체제는 명령 인터프리터로 제어를 전달해야 한다
- 대화식 시스템에서 명령 인터프리터는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다
  - GUI 시스템에서는 팝업 윈도가 사용자에게 오류를 알리고 지시를 기다린다
- 한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(load())하고 실행(execute()) 하기를 원할 수 있다
- 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스 클릭(click)을 통하여 지시된 프로그램을 실행하는 것을 허용한다
- 여기에서 흥미있는 질문은 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐 하는 것이다
  - 이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련 있다
  - 만약 새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다
    - 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다
  - 만약 두 프로그램이 병행하게 수행된다면, 우리는 다중 프로그래밍 될 새로운 프로세스를 생성한 것이다
    - 종종, 이런 특정 목적을 위한 시스템 콜이 있다(Windows: create_process() ~ Unix: fork())
  - 만약 우리가 새로운 잡이나 프로세스, 혹은 잡들이나 프로세스들의 집합을 생성한다면, 우리는 그들의 실행을 제어할 수 있어야 한다
    - 이러한 제어는 잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 잡 혹은 프로세스의 속성을 결정하고 재설정(reset)할 수 있는 능력이 필요하다
      - get_process_attributes(), set_process_attributes()
    - 또한 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다(terminate_process())
  - ...
- 병행 프로세스들의 조정(coordination)을 처리하는 이런 유형의 시스템 콜은 6장과 7장에서 상세히 논의된다
- 프로세스 제어는 너무 많은 측면과 다양성이 있으므로 이러한 개념들을 명확히 하기 위해 단일 태스킹 시스템과 다중 태스킹 시스템의 두 예를 사용할 것이다
  - Arduino는 마이크로 컨트롤러와 다양한 이벤트에 반응하는 입력 센서로 구성된 간단한 하드웨어 플랫폼이다
    - Arduino 플랫폼은 운영체제를 제공하지 않는다
    - 대신 `부트 로더`로 불리는 작은 소프트웨어가 스케치(USB연결을 통해 컴파일된 프로그램)를 Arduino에 적재(load)한다
    - Arduino는 한 순간에 하나의 스케치만 메모리에 존재할 수 있으므로 단일 태스킹 시스템으로 간주된다
  - FreeBSD(Berkeley UNIX로부터 비롯됨)는 다중 태스킹 시스템의 예이다
    - 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행한다
    - FreeBSD는 다중 태스킹 시스템이기 때문에 명령 인터프리터는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있다
    - 새로운 프로세스를 시작하기 위해 셸은 fork() 시스템 콜을 실행한다
    - ...

#### 2.3.3.2 파일 관리(file management)

- 파일 시스템은 13장부터 15장까지 더 자세히 논의 될 것이다
- 여기서는 파일을 다루는 몇 가지 공통적인 시스템 콜을 알아보자
- crate()
- delete()
- open()
- read()
- write()
- reposition()
- rewind()
- close()
- move()
- copy()
- ...

#### 2.3.3.3 장치 관리

- 프로세스는 작업을 계속 수행하기 위해 추가 자원이 필요할 수 있다
- 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에 접근 등이 될 수 있다

- request() : 그 장치 요청
- release() : 장치 사용이 끝나면 장치를 해제
- read() : 장치를 읽음
- write() : 장치에 씀
- ...

#### 2.3.3.4 정보 유지 관리(Information Maintenance)

- 많은 `시스템 콜`은 단순히 `사용자 프로그램`과 `운영체제 간`의 `정보 전달`을 위해 존재한다
- time() : 현재 시간을 반환
- date() : 현재 날짜를 반환
- ...

#### 통신(Communication)

- 통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다
- 메시지 전달 모델
  - 두 프로세스가 정보를 교환하기 위하여 서로 메시지를 주고 받는다
  - get_hostid()
  - get_processid()
  - ...
- 공유 메모리 모델

  - 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 특별한 시스템 콜을 사용한다
  - shared_memory_create()
  - shared_memory_attach()
  - ...
  - 정상적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막으려 한다 -> 그래서 동의가 필요

- 프로세스는 동일한 위치에 쓰지 않도록 보장할 책임을 진다 -> 6장
- 스레드(프로세스의 변형 모델, 디폴트로 메모리를 공유) -> 4장

- 메시지 전달 모델, 공유 메모리 모델은 보편적이며, 대부분 둘 다 구현한다
- 공유 메모리는 메모리 전송ㅅ혹도로 수행할 수 있으므로 최대 속도와 편리한 통신을 허용한다
  - 그렇지만 보호와 동기화 부분에서 여러 문제점을 갖고 있다

#### 2.3.3.6 보호(Protection)

- 보호는 컴퓨터 `시스템이 제공하는 자원`에 대한 `접근을 제어`하기 위한 기법을 지원한다
- 파일과 디스크와 같은 자원의 허가 권한을 설정
  - set_permission(), get_permission()
- 특정 사용자가 지정된 자원에 대해 접근이 허가 혹은 불허되었는지를 명시
  - allow_user(), deny_user()
- 17장 : 보호
- 16장 : 보안 - 외부 위협에 대응하기 위해 보호를 사용하는 훨씬 더 큰 문제인 보안에 대해 다룬다

## 2.4 시스템 서비스(System Services)

- 컴퓨터 구조

  - 1. 하드웨어
  - 2. 운영체제
  - 3. 시스템 서비스
  - 4. 응용 프로그램

- 시스템 서비스

  - = 시스템 유틸리티
  - 프로그램 개발과 실행을 위해 더 편리한 환경을 제공
  - 몇몇 시스템서비스는 단순히 시스템 콜에 대한 사용자 인터페이스이지만
  - 나머지 시스템서비스는 훨씬 더 복잡하다

- 시스템 서비스의 분류
  - 파일 관리
    - 파일과 디렉토리를 생성, 삭제, 복사, 이름변경, 인쇄, 열거, 그리고 일반적으로 조작한다
  - 상태 정보
    - 어떤 프로그램들은 단순히 시스템에게 날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수, 혹은 이와 비슷한 상태정보를 묻는다
    - 어떤 프로그램들은 상세 성능, 로딩 및 디버깅 정보를 제공
    - 몇몇 시스템은 환경 설정 정보를 저장하고 검색할 수 있는 등록(registry) 기능을 지원하기도 한다
  - 파일 변경
    - 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 text editor를 사용할 수 있다
    - 파일의 내용을 검색하거나 변환하기 위한 특수 명령어가 제공되기도 한다
  - 프로그래밍언어 지원
    - 일반적인 프로그래밍 언어들(C, C++, Java, Python 등)에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운 받을 수 있다
  - 프로그램 적재와 수행
    - 프로그램이 수행되려면 메모리에 적재되어야 하는데 이를 도와주는 서비스가 필요하다
    - 시스템은 절대 로더(absolute loader), 재배치 가능 로더(relocatable loader), 링키지 에디터(linkage editor)와 중첩 로더(overlay loader) 등을 제공할 수 있다
    - 또한 고급어나 기계어를 위한 디버깅 시스템도 필요하다
  - 통신
    - 프로세스, 사용자 그리고 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다
    - 예시
      - 사용자가 다른 사용자 화면으로 메시지를 전송
      - 웹 페이지 이곳저곳을 읽기
      - 전자 우편 메시지를 보내기
      - 원거리에서 로그인
      - 한 끼계에서 다른 기계로 파일을 전송
  - 백그라운드 서비스
    - 모든 범용 시스템은 부트할 때 특정 시스템을 시작 시킬 수 있는 방법을 가지고 있다
    - 이러한 프로세스 중 일부는 자신들의 할 일을 완수하면 종료하는 반면,
    - 일부 시스템이 정지될 때까지 계속해서 실행되는 프로세스도 존재한다
    - 항상 실행되는 시스템 프로그램 프로세스는 서비스, 시스템, 또는 디먼으로 알려져 잇따
- 운영체제 대부분은 시스템 프로그램과 함께 일반적인 문제점을 해결하거나 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공한다
  - 응용 프로그램
    - 웹 브라우저, 스프레드 시트, 데이터베이스 시스템, 게임 등이 포함된다

## 2.5 링커와 로더(Linkers and loaders)

- 그림 2.11 링커와 로더의 역할
- CPU에서 실행 : 프로그램 -> 메모리 -> 프로세스
- 로더 : (이진) 실행 파일을 메모리에 적재
- 소스파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 됨
  - 소스파일 -> 컴파일러 -> 오브젝트 파일(임의의 물리 메모리 위치에 적재되도록 설계됨, 재배치 가능한 오브젝트 파일)
- 링커 : 재배치 가능한 `오브젝트 파일`을 하나의 `이진 실행 파일로` 결합
- 재배치 : 프로그램에 `최종 주소를 할당`하고 프로그램 코드와 데이터를 해당 `주소와 일치하도록 조정`하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다

- 윈도우 예시
  - DLL(Dynamic Link Library) : 동적 링크 라이브러리
  - 프로그램이 적재될 때 라이브러리를 동적으로 링크할 수 있게 한다
    - 메모리 사용 절약
    - 내 생각) 트리쉐이킹과 비슷한 개념인듯
- 오브젝트 파일 및 실행 파일은 일반적으로 표준화된 형식을 가진다
  - 이 표준 형식은 컴파일 된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에 대한 `메타데이터를 포함하는 기호 테이블을 포함`한다
  - UNIX 및 Linux 시스템의 경우 이 표준 형식을 ELF(Executable and Linkable Format)라고 한다
  - 재배치 가능 파일과 실행 파일 각각을 위한 별도의 ELF 형식이 사용된다
  - 메타 데이터
    - ELF 파일의 정보 중 하나는 프로그램의 시작점이며,
    - 프로그램을 실행할 때 실행할 첫 번째 명령어의 주소가 저장되어 있다
  - Windows 시스템은 PE(Portable Executable)라는 표준 형식을 사용한다
  - macOS 시스템은 Mach-O(Mach Object)라는 표준 형식을 사용한다

#### ELF 형식

- Linux는 ELF 파일을 식별하고 분석하기 위한 다양한 명령을 제공한다
  - 예를 들어, file 명령은 파일 유형을 결정한다
  - main.o가 오브젝트 파일이고 main이 실행 파일인 경우
  - 명령 `file name.o` 는 main.o가 ELF 재배치 가능 파일이라고 보고하며,
  - 명령 `file main`은 main이 ELF 실행 파일이라고 보고한다
  - ELF 파일은 여러 섹션으로 구분되며 readelf 명령을 사용하여 분석할 수 있다

## 2.6 응용 프로그램이 운영체제마다 다른 이유(Why Applications are Operating-system specific)

- 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없다
- 각 운영체제는 고유한 시스템 콜 집합을 제공한다
  - 시스템 콜은 응용 프로그램이 사용할 수 있도록 운영체제가 제공하는 서비스 집합의 일부이다
- 만약 여러분이 여러 종류의 운영체제를 사용해 온 경우, 동일한 응용프로그램을 다른 운영체제에서 사용했다면 어떻게 가능했던 걸까?
- 다음 세 가지 방법 중 한 가지를 사용하여 응용 프로그램이 여러 운영체제에서 실행될 수 있게 만들 수 있다

#### 응용 프로그램이 여러 운영체제에서 실행 방법 1

- 운영체제마다 인터프리터가 제공되는 인터프리터 언어(Python 또는 Ruby)로 작성될 수 있다
  - 내 생각) 그렇다면 C언어는 인터프리터언어가 아닌 것 같은 데 운영체제 마다 시스템 콜을 다르게 사용해서 맞춰주는 것인가?
- 인터프리터는 소스 프로그램의 각 라인을 읽고, 상응하는 기계어 명령을 실행하고, 해당 운영체제의 시스템 콜을 호출한다
- 기계어 코드로 구성된 응용 프로그램에 비해 `성능이 떨어지고`, 인터프리터는 `각 운영체제 기능의 일부만 제공`하므로 관련 응용 프로그램의 기능도 제한될 수 있다

#### 응용 프로그램이 여러 운영체제에서 실행 방법 2

- 응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다
- 가상 머신은 언어의 RTE(Run-time Environment) 중 일부이다
- 이 방법의 예로 Java를 들 수 있다
- Java는 로더, 바이트코드 검증기 및 Java 응용 프로그램을 Java 가상머신으로 적재하는 기타 구성요소를 RTE로 가지고 있다
  - 이 RTE는 메인 프레임에서 스마트폰에 이르기까지 많은 운영체제에 이식 또는 개발되었으며 이론적으로 모든 Java앱은 RTE가 제공되는 어디서나 실행될 수 있다
- 이러한 종류의 시스템은 위에서 설명한 인터프리터 시스템과 유사한 단점을 가진다

#### 응용 프로그램이 여러 운영체제에서 실행 방법 3

- 응용 프로그래머 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용할 수 있다
- 응용 프로그램은 실행될 각 운영체제로 이식되어야 한다
- 이 이식은 많은 시간이 소요될 수 있으며, 많은 시험과 디버깅을 거쳐 응용 프로그램의 새 버전마다 수행되어야 한다
- 가장 잘 알려진 예는 다양한 UNIX 운영체제 변종 간의 소스 코드 호환성을 유지하기 위한 POSIX API와 표준 집합이다

### 크로스 플랫폼 응용 프로그램을 개발

#### 크로스 플랫폼 응용 프로그램을 개발 시 어려운 점

- 여전히 크로스 플랫폼 응용 프로그램을 개발하는것은 어려운 작업이다
  - 응용프로그램의 이동성이 부족한데에는 여러가지 원인이 있다
- 어려운 점 1
  - 각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다
  - 이러한 구성요소는 명시된 구조 형태로 실행 파일 내의 특정 위치에 있어야 운영체제가 파일을 열고 응용 프로그램을 적재하여 올바르게 실행할 수 있다
- 어려운 점 2
  - CPU는 다양한 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다
- 어려운 점 3
  - 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 활동을 요청할 수 있는 시스템 콜을 제공한다
  - 이러한 시스템 콜은 사용되는 피연산자, 피연산자 순서, 응용 프로그램이 시스템 콜을 호출하는 방법, 시스템 콜 번호, 의미 및 반환 결과를 포함하여 여러 측면에서 운영체제마다 다르다

#### 크로스 플랫폼 응용 프로그램을 개발

- 이러한 구조적 차이점을 완전히 해결하진 못했지만 해결하는 데 도움이 되는 몇 가지 방법이 있다
- Linux와 거의 모든 UNIX 시스템에서 이진 실행 파일은 ELF 형식을 채택하였다
  - 그렇지만 ELF형식은 특정 컴퓨터 아키텍처와 연관되어 있지 않으므로 실행 파일이 다른 하드웨어 플랫폼에서 실행될 것이라는 보장은 없다
- ABI(Application Binary Interface)는 응용 프로그램이 운영체제와 상호 작용하는 방법을 정의한다
  - ABI는 주소 길이, 시스템 콜에 매개변수를 전달하는 방법, 런타임 스택 구성, 시스템 라이브러리 이진 형식 및 데이터 유형의 크기 등 하위 수준의 세부 정보를 명시한다
  - 따라서 ABI는 아키텍처 수준이 API 수준이다
  - 그러나 특정 아키텍처에서 실행되는 특정 운영체제에 대해 ABI가 정의되어 있기 때문에 ABI는 플랫폼 간 호환성은 거의 제공하지 않는다

#### 요약

- 각 운영체제에 맞게 응용 프로그램을 개발하는 것은 어렵다
- 각 운영체제에 맞는 인터프리터가 필요하다

## 2.7 운영체제 설계 및 구현(Operating System Design and Implementation)

- 운영체제를 설계하고 구현할 때 우리가 당면하는 문제점을 논의한다
- 이런 설계 문제점에 대한 완전한 해결책은 없지만 성공적인 접근 방법들이 있다

### 2.7.1 설계 목표(Design Goals)

- 시스템을 설계하는 데 첫 문제점은 시스템의 목표와 명세를 정의하는 일이다
- 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형(일괄처리, 시분할, 단일 사용자, 다중 사용자, 분산, 실시간 혹은, 범용)의 선택에 의해 영향을 받을 것이다
- 운영체제의 명세와 설계는 매우 창조적인 일이다
- 어떤 교재도 이런 문제점을 해결하는 방법을 알려줄 수는 없지만, 그러나 소프트웨어 공학 분야에 의해 개발된, 특별히 운영체제에 적용 가능한 일반적인 원칙들이 존재한다

### 2.7.2 기법과 정책(Mechanisms and Policies)

- 한 가지 중요한 원칙은 기법(mechanism)으로부터 정책을 분리하는 것이다
- 기법은 어떤 일을 어떻게 할 것인가를 결정하는 것이고,
- 정책은 무엇을 할 것인가를 결정하는 것이다
- 예를 들면, 타이머 구조(1.4.3절 참조)는 CPU 보호를 보장하기 위한 기법이지만,
  - 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할지를 결정하는 것은 정책적 결정이다
- 정책과 기법의 분리는 융통성을 위해 아주 중요하다

  - 정책은 장소가 바뀌거나 시간이 지남에 따라 변경될 수 있다
    - 최악의 경우, 정책의 각 변경이 저변에 깔린 기법의 변경을 요구하게 된다
  - 여러 정책에서 사용되기에 충분한 융통성이 있는 일반적인 기법이 더 바람직하다
    - 예시 1. 한 유형의 프로그램이 다른 유형의 프로그램보다 높은 우선순위를 가지도록 하는 기법
      - 만일 기법이 정책으로 부터 적절하게 분리되면, 입출력 중심 프로그램이 CPU 중심 프로그램보다 높은 우선순위를 가지도록 하는 정책을 지원하거나 그 반대 정책을 지원할 수 있다

- 마이크로 커널 기반 운영체제(2.8.3절에서 논의)는 프리미티브 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다
  - 이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다
- 반면 Windows 운영체제는 전체적인 모양과 느낌을 통일하기 위해 기법과 정책이 밀접해지도록 인코딩하였다
  - 인터페이스 자체가 커널 및 시스템 라이브러리에 내장되어 있으므로 모든 응용 프로그램의 인터페이스는 비슷하다
  - Apple은 macOS 및 iOS 운영체제에 유사한 전략을 채택하였다
- 정책 결정은 모든 자원할당 문제에 있어 중요하다
  - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책을 결정해야 한다
  - 질문이 무엇(what)이 아니라, 어떻게(how)일 때마다, 반드시 결정되어야 하는 것은 기법이다

### 2.7.3 구현(implementation)

- 운영체제의 설계가 완료되면 구현되어야 한다
- 운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에 구현 방법에 대해 일반적인 언급을 하는 것은 어렵다

- 초기 운영체제는 어셈 블리언어로 작성되었다
- 이제 대부분 운영체제는 C또는 C++와 같은 고급언어로 작성되었으며, 극히 일부의 시스템이 어셈블리 언어로 작성된다
- 커널 최하위 레벨 -> 어셈블리 언어 및 C
- 커널 상위 레벨 -> C, C++, Java, Python, Go, Rust, Swift, Kotlin, JavaScript, Ruby, PHP, Perl, C#, Objective-C, Scala, Haskell, Lisp, Erlang, Prolog, F#, Clojure, D, Julia, R, MATLAB, Fortran, Ada, Pascal, Cobol, BASIC, Assembly, etc.
- 안드로이드 OS 예

  - 커널은 대부분 약간의 어셈블리 언어를 사용하고 대부분 C로 작성되었다
  - 대부분의 Android 시스템 라이브러리는 C또는 C++로 작성되었으며
  - 개발자 인터페이스를 제공하는 응용 프로그램 프레임워크는 대부분 Java로 작성된다
  - 2.8.5.2절에서 안드로이드의 구조를 더 자세히 다룬다

- 운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료구조와 알고리즘의 결과일 가능성이 크다
  - 소량의 코드만이 고성능이 중요하다
    - 인터럽트 핸들러
    - 입출력 관리자
    - 메모리 관리자
    - CPU 스케줄러
    - ...

## 2.8 운영체제의 구조

- 현대 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 한다
- 일반적인 접근 방법은 한 개의 일관된 시스템보다는 `태스크를 작은 구성요소로 분할`하는 것이다
  - 이들 모듈 각각은 신중히 정의된 인터페이스와 기능을 가진, 시스템의 잘 정의된 부분이어야 한다
  - main() 함수에 모든 코드를 배치하는 대신 로직을 여러 함수로 분리하고 매개변수와 반환 값을 명확하게 표현한 다음 main() 함수에서 해당 함수를 호출한다
    - 내 생각) 디자인 패턴을 잘 적용해서 모듈화해야될 것 같다
- 1장에서 알아본 구성요소들이 어떤 방법으로 상호 연결되고 하나의 커널로 결합되는지를 알아본다

### 2.8.1 모놀리식 구조(Monolithic Structure)

- 가장 간단한 방법, 구조가 아에 없는 것
- 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것

#### 최초 UNIX 운영체제 구성

- 커널
  - 여러 인터페이스
  - 장치 드라이버
- 시스템 프로그램

- 그림 2.12 전통적인 UNIX 시스템 구조
  - 커널
    - 시스템 콜 인터페이스
    - 하드웨어 인터페이스
- 커널은 시스템콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 그리고 여러 기능을 제공

  - 커널에서 제공하는 기능은 하나의 주소 공간으로 결합하기에는 엄청나게 많은 기능이다

#### Linux 운영체제

- Linux 운영체제는 UNIX에 기반을 두고 있다
- 응용 프로그램은 일반적으로 커널에 대한 시스템 콜 인터페이스와 통신할 때, glibc (표준 C 라이브러리)를 사용한다
- Linux 커널은 단일 주소 공간에서 커널모드로 전부 실행된다는 점에서 모놀리식이지만, 2.8.4에서 볼 수 있듯 런타임 중에 커널을 수정할 수 있는 모듈식 설계를 갖추고 있다
- 모놀리식 커널의 명백한 단순성에도 불구하고 이 구조는 구현 및 확장이 어렵다
- 그러나 모놀리식 커널은 성능 면에서 뚜렷한 이점이 있다
  - 시스템 콜 인터페이스에는 오버헤드가 거의 없고 커널 안에서의 통신 속도가 빠르다
  - 따라서 모놀리식 커널의 단점에도 불구하고, 속도와 효율성은 이 구조의 증거를 여전히 UNIX, Linux 및 Windows 운영체제에서 발견할 수 있는 이유를 설명한다

### 2.8.2 계층적 접근(Layered Approach)

- 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있으므로 `모놀리식` 접근법은 종종 `밀접하게 결합된 시스템`으로 불린다
- 대안 -> 느슨하게 결합된 시스템
  - 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성요소로 나뉜다
  - 이 모든 구성요소가 합쳐져 커널을 구성한다
  - 이 모듈 방식의 장점은 한 구성요소의 변경이 해당 구성요소에만 영향을 미치고 다른 구성요소에는 영향을 미치지 않으므로 시스템 구현자가 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다는 것이다
- 시스템은 다양한 방식으로 모듈화 될 수 있다
  - 한 가지 방식이 계층적 접근 방식인데 이 방식에서는 운영체제가 여러 개의 층으로 나누어진다
    - 내 생각) OSI 7계층과 비슷한 느낌
- 그림 2.14 계층 구조의 운영체제
  - 최하위 층은(층 0) 하드웨어이고 최상위 층(층 N)은 사용자 인터페이스이다
  - 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상 객체의 구현이다
- 전형적인 운영체제 층(편의상 층 M이라고 하자)은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다
  - 층 M은 다시 하위층에 대한 연산을 호출할 수 있다
- 계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다
  - 각 층들은 `자신의 하위층`들의 서비스와 기능(연산)들만을 사용하도록 선택된다
  - 이러한 접근 방법은 시스템의 검증과 `디버깅 작업을 단순화` 한다
- 계층화된 시스템은 컴퓨터 네트워크(예 : TCP/IP) 및 웹 응용 프로그램에서 성공적으로 사용됐다
  - 그럼에도 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다
    - 한 가지 이유는 각 계층의 기능을 적절히 정의해야 하는 문제와 관련이 있다
    - 또한 이러한 시스템의 전반적인 성능은 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드로 인해 열악하다
    - 그러나 어느정도의 계층화는 현대 운영체제에서 공통적이다

### 2.8.3 마이크로 커널(Micro kernels)

- 초기 UNIX는 모놀리식 구조를 가진다
- 모노리식 구조는 커널이 커지면서 관리하기 힘들어졌다
- 마이크로 커널 접근 방식을 사용하여 커널은 모듈화한 Mach라 불리는 운영체제를 개발하였다

  - 이 방법은 모든 중요치 않은 구성요소를 커널로 부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다
  - 즉, 더 작은 커널이다
  - 어느 서비스가 커널에 남아야 하고 어느 서비스가 사용자 공간에 구현되어야 할지에 대해서는 의견이 일치하지 않는다

- 그림 2.15 전형적인 마이크로 커널의 구조
  - 하드웨어 `<->` 커널 모드 - 마이크로 커널(프로세스간 통신, 메모리 관리, CPU 스케줄링) `<- (메시지) ->` 사용자 모드(응용 프로그램, 파일 시스템, 장치 드라이버)
- 마이크로 커널의 장점
  - 운영체제의 확장이 쉽다
    - 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널을 변경할 필요가 없다
  - 한 하드웨어로부터 다른 하드웨어로 이식이 쉽다
    - 마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문
    - 더욱 높은 보안성과 신뢰성을 제공
      - 만약 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다
- 마이크로 커널의 예
  - macOS 및 iOS 운영체제의 커널 구성요소인 Darwin 이다
    - Darwin은 두 개의 커널로 구성되며
      - 그중 하나는 Mach 마이크로 커널이다
  - 또 다른 예는 실시간 운영체제인 QNX이다
    - QNX Neutrino 마이크로 커널은 메시지 전달과 프로세스 스케줄링을 위한 서비스를 제공한다
- 안타깝게도 마이크로 커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다
  - 두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다
  - 또한 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다
    - 메시지복사 및 프로세스 전환과 관련된 오버헤드는 마이크로 커널 기반 운영체제의 성장에 가장 큰 장애였다
      - Windows NT
        - Windows XP가 설계될 때까지 Windows 구조는 마이크로 커널보다는 모놀리식에 가까운 구조였다

### 2.8.4 모듈(Modules)

- 운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 아마도 적재가능 커널 모듈(loadable kernel modules, LKM) 기법의 사용일 것이다
  - 이 접근법에서는 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다
  - 이러한 유형의 설계는 Linux, Mac OS X, Solaris 및 Windows 등의 현대 UNIX를 구현하는 일반적인 추세이다
- 설계 주안 점
  - 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다
  - 서비스를 동적으로 링크(실행할 파일을 생성하는 것)하는 것은 새로운 기능을 직접 커널에 추가하는 것보다 바람직하다
    - 새로운 기능을 직접 추가하는 것은 수정 사항이 생길 때마다 커널에 직접 구현하고 다양한 파일 시스템을 지원하는 것은 적재 가능 모듈을 통하여 구현할 수 있다
- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다
  - 그러나 모듈에서 임의의 `다른 모듈을 호출할 수 있다`는 점에서 `계층 구조보다 유연`하다
- 중심모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하다
  - 그러나 통신하기 위하여 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다
- 리눅스는 주로 장치 드라이버와 파일 시스템을 지원하기 위해 `적재가능 커널 모듈(LKM)`을 사용한다
- LKM(Loaderable Kernel Modules)은 시스템이 시작(또는 부팅)되거나 USB 장치가 실행중인 시스템에 접속되는 경우와 같이 런타임 중에 커널에 삽입될 수 있다
- LKM은 런타임 중에 커널에서 제거될 수도 있다
- 리눅스의 경우 LKM은 동적 모듈식 커널을 허용하면서 모놀리식 시스템의 성능 이점을 유지한다
- 이 장의 마지막 부분에서 LKM을 작성하는 몇 가지 프로그래밍 연습을 다룬다

### 2.8.5 하이브리드 시스템(Hybrid Systems)

- 사실 엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다
- 대신 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다
- 예를 들어, 리눅스는 모놀리식 구조이다
  - 그러나 이 운영체제들은 모듈을 사용하기 때문에 새로운 기능을 동적으로 커널에 추가할 수 있다
- 성능상의 이유로 Windows도 대체적으로 모놀리식 구조라 할 수 있다
  - 그러나 사용자 모드 프로세스에서 실행되는 분리된 서브시스템을 지원하는 전형적인 마이크로 커널의 형태를 유지하고 있다
- Widnows 시스템 또한 LKM을 지원한다
  - 20장, 21장에서 사례를 다뤄본다

#### 2.8.5.1 macOS와 iOS

- 이 두 시스템의 일반적인 아키텍처(그림 2.16)

  - 응용 프로그램
  - 사용자 경험
  - 응용 프로그램 프레임워크
    - Cocoa, Cocoa touch 프레임 워크 포함
    - 프로그래밍 언어(Object-C, Swift)에 대한 API를 제공
  - 코어 프레임워크
    - Quicktime 및 OpenGL을 포함한 그래픽 미디어를 지원하는 프레임워크를 정의
  - 커널 환경(Darwin)
    - Mach 마이크로 커널과 DBS, UNIX 커널이 포함된다

- 응용 프로그램 -> 사용자 경험 또는 우회 -> 응용프램 프레임 워크 또는 핵심 프레임 워크와 직접 상호 작용하도록 설계될 수 있다
- 또한 응용 프로그램은 프레임워크를 완전히 버리고 커널 환경과 직접 통신할 수 있다

  - POSIX 시스템 콜을 수행하도록 작성된 C 프로그램

- macOS -> Intel 아키텍처에서 실행되도록 컴파일 됨
- iOS -> ARM 기반 아키텍처용으로 컴파일 됨

  - 내 생각) M1 칩은 ARM 기반? 그래서 응용 프로그램 설치 시 구분해서 설치하는 것 같다

- Darwin

  - Mach 마이크로 커널과 BSD UNIX 커널로 구성된 계층화된 시스템
    - BSD UNIX 커널 : BSD 계열의 UNIX 운영체제에서 사용되는 커널
      - https://ko.wikipedia.org/wiki/BSD

- 그림 2.17 Darwin의 구조
  - 응용 프로그램
  - 라이브러리 인터페이스
  - Mach 트랩 / BSD(POSIX) 시스템 콜
  - Mach 커널
    - iokit
    - kexts
    - 스케줄링
    - IPC
    - 메모리 관리

#### 2.8.4.2 Android

- 안드로이드는 Open Handset Alliance (Google이 주도)가 설계하였으며
- Android 스마트폰과 태블릿을 위해 개발되었다
- Android는 애플과 달리 오픈소스이다
- 그림 2.18 Google Android의 구조
  - 응용 프로그램
  - ART VM / Android 프레임워크 / JNI(Java Native Interface)
  - Bionic / 네트워크 라이브러리 / HAL
    - 네트워크 라이브러리 : SQLite, openGL, webkit, surfacee manager, SSL, media framework
      - 네트워크 소켓 : TCP, UDP, ICMP, IP, ARP, DHCP, DNS, HTTP, HTTPS, FTP, SMTP, POP3, IMAP, SSL, TLS
  - Linux 커널
  - 하드웨어
- Android 장치의 소프트웨어 설계자는 Java로 응용 프로그램을 개발하지만 일반적으로 표준 Java API를 사용하지 않는다
  - Google은 Java 개발을 위해 별도의 Android API를 설계하였다
- 안드로이드 맨 아래 Linux 커널이 있다
  - 전원관리와 같은 모바일 시스템의 특수한 지원을 위해 다양한 영역에서 ANdroid에서 사용되는 Linux 커널을 수정하였다
  - 또한 메모리 관리 및 할당을 변경했으며 Binder로 알려진 새로운 형태의 IPC를 추가하였다(3.8.2.1에서 다룸)

## 2.9 운영체제 빌딩과 부팅(Building and Booting an Operating System)

- 운영체제는 하나의 특정 기기보단 일반적으로 다양한 주변 장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계된다

#### Linux를 위한 Windows 서브 시스템

- 윈도우는 다른 운영체제 환경을 에뮬레이트 하기 위해 서브시스템을 제공하는 하이브리드 구조를 사용한다
- 이러한 사용자 모드 서비스시트메은 실제 서비스를 제공하기 위해 Widnows 커널과 통신한다
- Windows10에는 Linux용 Windows 서브시스템(WSL : Windows Subsystem for Linux)
  - https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9A%A9_%EC%9C%88%EB%8F%84%EC%9A%B0_%ED%95%98%EC%9C%84_%EC%8B%9C%EC%8A%A4%ED%85%9C
  - bash.exe를 시작
  - Linux를 실행하는 bash 셸을 사용자에게 제시한다
  - WSL은 init 프로세스로 구성된 Linux 인스턴스를 생성하고 네이티브 리눅스 응용 프로그램 /bin/bash를 실행하는 bash 셸 프로세스를 생성한다
  - 이러한 각 프로세스는 Windows Pico 프로세스에서 실행된다
- 책 101쪽 참고

### 2.9.1 운영체제 생성(Operating System Generation)

- 운영체제 설치
- 운영체제를 처음부터 생성(또는 빌딩)하는 경우 다음 절차를 밟아야 한다
  - 운영체제 소스 코드를 작성한다
  - 운영체제가 실행될 시스템의 운영체제를 구성한다
  - 운영체제를 컴파일 한다
  - 운영체제를 설치한다
  - 컴퓨터와 새 운영체제를 부팅한다

### 2.9.2 시스템 부트

- 하드웨어는 커널의 위치 또는 커널을 적재하는 방법을 어떻게 알 수 있을까?
- 커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅이라고 한다
- 시스템 대부분에서 부팅 과정
  - 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾는다
  - 커널이 메모리에 적재되고 시작된다
  - 커널은 하드웨어를 초기화 한다
  - 루트 파일 시스템이 마운트 된다

#### 컴퓨터 부팅 과정

- BIOS라고 하는 비휘발성 펌웨어에 있는 소형 부트 로더가 실행된다
  - 많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 UEFI(Unified Extensible Firmware Interface)로 대체하였다
    - BIOS : Basic Input/Output System
      - https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%EC%98%A4%EC%8A%A4
- 부트 스트랩 프로그램은 BIOS에서 부팅하든 UEFI에서 부팅하든 다양한 작업을 수행
  - 커널 프로그램이 포함된 파일을 메모리에 적재
  - 진단 실시
    - 메모리와 CPU를 점검
    - 장치 검색과 같은 시스템 상태를 확인
- 대부분의 운영체제는 복구모드 또는 단일 사용자 모드로 부팅할 수 있는 기능을 제공

## 2.10 운영체제 디버깅(Operating System Debugging)

- 디버깅 : 시스템의 오류를 발견하고 수정하는 행위
  - 병목 현상 제거 -> 성능 조정
  - 하드웨어 디버깅은 이 책의 범위를 벗어난다
  - 이 장에서는 커널과 프로세스 오류 및 성능 문제의 디버깅에 관해 탐구한다

### 2.10.1 장애 분석(Failure Analysis)

- 프로세스 실패 -> 로그 파일에 기록
- 운영체제는 프로세스가 사용하던 메모리를 캡처한 코어 덤프(core dump)를 취하고 차후 분석을 위해 파일로 저장
  - 초기엔 메모리를 "코어"라 불렀다
- 실행중인 프로그램과 코어 덤프는 디버거에 의해 검사될 수 있으며,
  - 이는 장애 발생 시 프로그래머가 프로세스의 코드와 메모리를 분석할 수 있도록 한다
- 사용자 수준 프로세스 코드를 디버깅하는 것은 도전적인 일이다
  - 커널의 크기와 복잡도, 하드웨어 제어 및 사용자 수준 디버깅 도구가 없기 때문에 운영체제 커널을 디버깅하는 것은 훨씬 복잡하다
  - 커널 장애는 크래시(crach)라고 불린다
  - 프로세스 장애와 마찬가지로 오류정보가 로그 파일에 저장되고 메모리의 상태가 크래시 덤프에 저장된다
- 운영체제 디버깅 프로세스와 디버깅은 종종 태스크의 근본적인 차이에 의해 서로 다른 도구와 기법을 사용
  - 파일 시스템 코드 때문에 발생한 커널 장애
    - 재부팅 전에 커널의 상태를 파일 시스템에 저장하려는 시도를 위험하게 한다
    - 일반적인 기법은 커널의 메모리 상태를 이 용도를 위해 예약도니 파일 시스템을 가지지 않은 디스크의 특정 부분에 저장하는 것
    - 커널이 복구 불가능한 오류를 탐지하면 메모리의 전체 내용 또는 재부팅이 되면 프로세스는 이 영역으로부터 데이터를 수집하고 분석을 위해 파일 시스템의 크래시 덤프 파일에 기록한다
    - 이런 전략은 보통의 사용자 프로세스를 디버깅 할 때는 필요하지 않다

### 2.10.2 성능 관찰 및 조정

- 선응 조정은 처리 병목 지점을 제거함으로써 성능을 향상시키려 한다
- 프로세스별 도구 시스템 전체의 관찰을 측정하고 표시할 수 있는 방법을 가지고 있어야 한다

#### 2.10.2.1 카운터(Counters)

- 운영체제는 일련의 `카운터`를 통해 `호출된 시스템 콜 횟수` 또는 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 `시스템 활동을 추적`한다
- 카운터를 사용하는 Linux 도구의 예

  - 프로세스별
    - ps : 하나의 프로세스 또는 선택된 프로세스에 대한 정보를 보고한다
    - top : 현재 프로세스에 대한 실시간 통계를 보고한다
  - 시스템 전체
    - vmstat : 메모리 사용량 통계를 보고한다
    - entstat : 네트워크 인터페이스에 대한 통계를 보고한다
    - iostat : 디스크의 I/O 사용량을 보고한다

- 내 생각) 리눅스 명령어는 다양하게 존재하는데 그 중에 위 명령어들은 디버깅과 관련된 명령어였다

- Windows 시스템은 작업관리자를 제공

#### Kernighan's 법칙

- 애초에 디버깅은 코드를 작성하는 것보다 두 배 어렵다
- 그러므로 여러분이 가능한 영리하게 코드를 작성한다면, 정의에 따라 디버깅할 만큼 똑똑할 수는 없다

### 2.10.3 추적(Tracing)

- 카운터 기반 도구는 커널에서 유지 관리하는 특정 통계의 현재 값에 대해 문의 하는 반면,
- 추적 도구는 시스템 콜과 관련된 단계와 같은 특저 이벤트에 대한 데이터를 수집한다

- Linux 추적 도구의 예
  - strace : 프로세스에 의해 호출된 시스템 콜을 추적한다
  - gdb : 소스 레벨 디버거
- 시스템 전체

  - perf : 리눅스 성능 도구 모음
  - tcpdump : 네트워크 패킷을 수집한다

### 2.10.4 BCC(성능 모니터링, 네트워킹 등을위한 동적 추적 도구)

- BCC는 유용한 커널 추적 및 조작 프로그램을 만들기위한 강력한 도구 및 예제 파일 세트입니다.
- Linux 에서 동적 커널 추적을 위한 툴킷인 BCC(BPF Compiler Collection)에 대해 설명한다

  - BPF (Berkeley Packet Filters)를 사용
  - 참고 : https://ko.linux-console.net/?p=1876#gsc.tab=0

- 사용자 수준과 커널 코드의 상호 작용을 디버깅하는 것은 양쪽의 코드를 이해하고 상호작용을 계측할 수 있는 도구의 집합 없니느 거의 불가능하다
- 그런 도구 집합이 유용하려면 시스템의 어느 부분도 디버깅할 수 있어야 하며
  - 시스템 안정성을 해치지 않고
  - 성능에 미치는 영향을 최소로 해야한다

## 2.11 요약

- 운영체제는 사용자 및 프로그램에 서비스를 제공하여 프로그램 실행 환경을 제공한다
- 운영체제와 상호작용하기 위한 세 가지 주요 접근 방식
  - 명령 인터프리터
  - 그래픽 사용자 인터페이스
  - 터치 스크린 인터페이스
- 시스템 콜은 운영체제에서 제공하는 서비스에 대한 인터페이스를 제공한다
  - 프로그래머는 시스템 콜 서비스에 댁세스 하기 위해 시스템 콜의 API를 사용한다
- 시스템 콜은 6가지 주요 범주로 나눌 수 있다
  - 프로세스 제어
  - 파일 관리
  - 장치 관리
  - 정보 유지 관리
  - 통신
  - 보호
- 표준 C 라이브러리는 UNIX 및 Linux 시스템을 위한 시스템 콜 인터페이스를 제공한다
- 운영체제에는 사용자에게 유틸리티를 제공하는 시스템 프로그램 모음도 포함되어 있다
- 링커는 재배치 가능한 여러 오브젝트 모듈을 하나의 이진 실행 파일로 결합한다
- 로더는 실행 파일을 메모리에 적재하여 사용가능한 CPU에서 실행할 수 있게 한다
- 응용 프로그램이 운영체제에 따라 달리지는 몇 가지 이유가 있다
  - 여기에는 프로그램 실행 파일에 대한 서로 다른 이진 형식, CPU에 따라 다른 명령 집합 및 운영체제 마다 다른 시스템 콜이 포함된다
- 운영체제는 특정 목표를 ㅇ염두에 두고 설계되었다
  - 이러한 목표를 궁극적으로 운영체제 정책을 결정한다
  - 운영체제는 특정 기법을 통해 이러한 정책을 구현한다
- 모놀리식 운영체제는 구조가 없다
  - 모든 기능은 하나의 주소 공간에서 실행되는 단일 정적 바이너리 파일로 제공된다
  - 이러한 시스템을 수정하기는 어렵지만 주요 이점을 효율성이다
- 계층화된 운영체제는 여러 개의 개별 층으로 나뉜다
  - 여기서 하위층인 하드웨어 인터페이스이고 최상위층은 사용자 인터페이스이다
  - 계층화된 소프트웨어 시스템이 어느 정도 성공을 거두었ㅈ디만 이 방법은 일반적으로 성능 문제로 인해 운영체제를 설계하는 데 적합하지 않다
- 운영체제 설계를 위한 마이크로 커널 접근 방식은 최소한의 커널을 사용한다
  - 대부분의 서비스는 사용자 수준 응용 프로그램으로 실행된다
  - 메시지 전달을 통해 통신이 이루어진다
- 운영체제 설계를 위한 모듈식 접근 방식은 실생 시간 중에 적재 및 제거할 수 있는 모듈을 통해 운영체제 서비스를 제공한다
  - 현대의 많은 운영체제는 모놀리식 커널과 모듈의 조합을 사용하여 하이브리드 시스템으로 구성된다
- 부트로더는 운영체제를 메모리에 적재하고 초기화를 수행하며 시스템 실행을 시작한다
- 카운터 또는 추적을 사용하여 운영체제의 성능을 관찰할 수 있따
  - 카운터는 시스템 전체 또는 프로세스별 통계의 모음인 반면
  - 추적은 운영체제를 통한 프로그램의 실행을 추적한다

## 연습 문제

- 2.1 시스템 콜의 목적은 무엇인가?
- 2.2 명령 인터프리터의 목적은 무엇인가?
  - 통상 커널에 포함되지 않는 이유는 무엇인가?
- 2.3 UNIX 시스템에서 새 프로세스를 시작하기 위해 명령 인터프리터나 셸에서 어떤 시스템 콜이 실행되어야 하는가?
  - fork() 시스템 호출과 exec() 시스템 호출을 수행
- 2.4 시스템 프로그램의 목적은 무엇인가?
- 2.5 시스템 설계 시 계층화된 접근 방식의 주요 장점은 무엇인가?
  - 계층화된 접근 방식의 단점은 무엇인가?
- 2.6 운영체제에서 제공하는 5가지 서비스를 나열하고 각 서비스가 사용자에게 편의를 제공하는 방법을 설명하다
  - 사용자 수준 프로그램이 이러한 서비스를 제공할 수 없는 경우는 언제인가?
- 2.7 일부 시스템은 운영체제를 펌웨어에 저장하고 다른 시스템은 디스크에 저장하는 이유는 무엇인가?
- 2.8 부팅할 운영체제를 선택할 수 있도록 시스템을 설계하는 방법은 무엇인가?
  - 부트스트랩 프로그램이 해야할 일은 무엇인가?
