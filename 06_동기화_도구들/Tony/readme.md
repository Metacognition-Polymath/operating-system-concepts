# Part 3. 프로세스 동기화(Process Synchronization)

- 시스템은 일반적으로 병행하게 또는 병렬로 실행되는 수백 개 또는 수천 개의 스레드로 구성된다
- 스레드는 종종 사용자 데이터를 공유한다
- 한편, 운영체제는 다양한 자료구조를 지속적으로 업데이트하여 여러 스레드를 지원한다
- 공유 데이터에 대한 액세스가 제어되지 않으면 `경쟁 조건`이 존재하여 `데이터 값이 손상`될 수 있다
- 프로세스 동기화는 경쟁 조건을 피하고자 공유 데이터에 대한 `액세스를 제어하는 도구`를 사용한다
- 이러한 도구를 잘못 사용하면 교착 상태를 포함한 시스템 성능이 저하될 수 있으므로 주의해서 사용해야 한다

# 6. 동기화 도구들(Synchronization Tools)

- 협력적 프로세스 : 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 영향을 받는 프로세스
  - 논리 주소 공간(코드 및 데이터)을 직접 공유하거나 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다
- 그러나 공유데이터를 동시에 접근하면 데이터의 일관성을 망칠 수 있다
- 이 장에서는 놀리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하여, 이를 통해 데이터의 일관성을 유지하는 다양한 메커니즘을 논의한다

#### 이 장의 목표

- `임계구역 문제(Critical-Section Problem, CSP)`를 설명하고 `경쟁 조건(Race Condition)`을 설명한다
- `메모리 장벽`, `compare-and-swap 연산` 및 `원자적 변수`를 사용하여 `임계구역 문제에 대한 하드웨어 해결책`을 설명한다
- `Mutex 락`, `세마포`, `모니터` 및 `조건 변수`를 사용하여 `임계구역 문제를 해결하는 방법`을 보인다
- 적은, 중간 및 심한 경쟁 시나리오에서 임계구역 문제를 해결하는 도구를 평가한다

## 6.1 배경

#### count의 현재 값은 5이고 생산자와 소비자는 count++과 count--를 "병행"하게 실행한다고 가정

- T0: producer execute register1 = count {register = 5} // 시작
- T1: producer execute register1 = register1 + 1 {register = 6}
- T2: consumer execute register2 = count {register = 5} // 동시 시작
- T3: consumer execute register2 = register2 - 1 {register = 4}
- T4: producer execute count = register1 {count = 6}
- T5: consumer execute count = register2 {count = 4}

#### 경쟁 상황, 경쟁 조건(race condition)

- 프로세스가 공유 데이터에 병행하게 접근할 때 발생하며 최종 결과는 병행 접근이 발생한 특정 순서에 따라 다르다

#### Java로 동기화 문제 보기

- RaceCondition.java

## 6.2 임계구역 문제(The Critical-Section Problem)

- 임계구역(critical section)

  - `공유 데이터`가 조작될 수 있으며, 경쟁 조건이 발생할 수 있는 코드 영역

#### 임계구역 프로세스

```c
// pseudocode
while (true) {
  // entry section : 진입 구역

  // critical section : 임계 구역

  // exit section : 퇴출 구역

  // remainder section : 나머지 구역
}
```

- 그림 6.1 전형적인 프로세스의 일반적인 구조

- 진입 구역(entry section)

  - 임계 구역으로 진입하려면 진입허가 요청을 해야하는데, 이러한 요청을 구현하는 코드 부분

- 퇴출 구역(exit section)

  - 임계 구역을 빠져나오려면 퇴출 요청을 해야하는데, 이러한 요청을 구현하는 코드 부분

- 나머지 구역(remainder section)

  - 코드의 나머지 부분

#### 임계구역 문제

- 임계 구역 문제는 데이터를 협력적으로 공유하기 위해 자신의 활동을 동기화하는 프로토콜을 설계하는 것이다
- 임계구역 문제에 대한 해결책은
  - (1) 상호 배제(mutual exclusion)
  - (2) 진행(progress)
  - (3) 한정된 대기(bounded waiting)
  - 의 세 가지 요구 사항을 충족해야 한다
- 상호 배제(mutual exclusion)
  - 한 번에 하나의 프로세스만 임계구역에서 활성화된다
- 진행(progress)
  - 프로그램들이 다음에 어떤 프로세스가 임계구역에 들어갈 것인지 협력적으로 결정하리라는 것을 보장한다
- 한정된 대기(bounded waiting)
  - 프로그램이 자신의 임계구역에 들어가기 전에 대기하는 시간을 제한한다

## 6.3 Peterson의 해결안(Peterson's Solution)

- 고전적인 소프트웨어 기반 해결책
- 현대 컴퓨터 구조가 load와 store같은 기본적인 기계어를 수행하는 방식 때문에 Peterson의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수는 없다
- 그러나 임계구역 문제를 해결하기 위한 좋은 알고리즘적인 설명을 제공하고

  - 상호 배제, 진행, 한정적 대기의 요구 조건을 중점으로 다루는 소프트웨어를 설계하는 데 필요한 복잡성을 잘 설명한다

- Peterson의 해결안은 임계구역과 나머지 구역을 번갈아가며 실행하는 두 개의 프로세스로 한정된다
- Peterson은 두 프로세스가 두 개의 데이터 항목을 공유하도록 하여 해결한다

  - `int turn`
  - `boolean flag[2]`

```c
while(true) {
  flag[i] = true;
  turn = j;
  while (flag[j] && turn == j) {
    // busy wait
  }
  // critical section
  flag[i] = false;
  // remainder section
}
```

- Peterson.java

- Peterson의 해결안은 `최신 컴퓨터 아키턱쳐`에서 작동한다고 `보장되지 않는다`
  - 주된 이유는 시스템 성능을 향상하기 위해 프로세서 및 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 `재정렬` 할 수 있기 때문이다
- 응용 프로그램의 경우 최종 결과가 예상한 것과 일치하기 때문에 프로그램의 정확성 측면에서 재정렬은 중요하지 않다
  - 이것은 수표책의 잔액을 맞추는 것과 유사하다. 최종 잔액은 달라지지 않을 것이기 때문에 입금 및 출금의 실제 순서는 중요하지 않다
- 그러나 데이터를 공유하는 다중 스레드 응용 프로그램의 경우 명령 순서가 바뀌게 되면 데이터의 일관성이 깨지거나 예기치 못한 결과를 낳을 수 있다
- 상호 배제를 유지하는 유일한 방법은 적절한 동기화 도구를 사용하는 것이다 -> `하드웨어 지원 필요`
  - 이러한 도구에 대한 논의는 하드웨어 프리미티브(primitive, 원시적인) 지원에서 시작하여 커널 개발자와 응용 프로그램 프로그래머 모두가 사용할 수 있는 추상적인 고수준 소프트웨어 기반 API 순서로 진행된다

## 6.4 동기화를 위한 하드웨어 지원(Hardware support for Synchronization)

- 6.3에서 소프트웨어 기반의 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있다
- 이 절에서 임계 구역문제를 해결하기 위한 지원을 제공하는 세 가지 하드웨어 명령을 제시한다
  - `이러한 primitive 연산`은 동기화 도구로 직접 사용될 수 있거나 `더 추상적인 동기화 기법의 기초 형태로 사용될 수 있다`

### 6.4.1 메모리 장벽(Memory Barriers)

- 메모리 모델 : 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식
- 메모리 모델 범주
  - 강한 순서 : 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보임
  - 약한 순서 : 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음

```c
x = 100;
memory_barrier(); // flag에 배정하기 전에 x에 대한 배정이 먼저 실행되도록 한다
flag = true;
```

- 메모리 장벽은 매우 낮은 수준의 연산으로 상호 배제를 보장하는 특수 코드를 작성할 때 커널 개발자만 사용한다

### 6.4.2 하드웨어 명령어(Hardware Instructions)

- 특정 원자적 명령어를 정의하고 해당 명령어가 원자적으로 실행되게 한다

  - 해당 명령어가 실행될 때 명령어 안에 짜여진 코드는 순서대로 실행되는 것이 보장된다
  - e.g.
    - test_and_set(boolean \*target)
    - compare_and_swap(int \*target, int old, int new)

### 6.4.3 원자적 변수(Atomic Variables)

```c
void increment(atomic_int *v) {
  int temp;
  do {
    temp = *v; // atomic_int *v : 원자적 변수
  } while (temp != compare_and_swap(v, temp, temp + 1));
}
```

- 원자적 변수(atomic variable) : 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다

  - 원자적 변수는 카운터가 증가할 때와 같이 갱신되는 동안 단일 변수에 대한 데이터 경쟁이 있을 수 있는 상황에서 상호 배제를 보장하는데 사용할 수 있다.
  - 원자적 갱신을 제공하는 변수
  - 원자적 갱신 : 원자적 변수의 갱신이 완료되기 전에는 다른 프로세서가 해당 변수를 읽을 수 없다

- 일반적으로 `하드웨어 명령어`는 직접 사용되지 않는다
- 오히려 임계 구역 문제를 해결하는 `다른 도구를 구축하기 위한 기본 구성요소로 사용`된다
- 그런 `기본 구성요구를 위한 도구 중 하나가 원자적 변수`이다
- 원자적 변수는 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다
- 원자적 변수는 운영체제 및 변행 응용 프로그램에서 일반적으로 사용되지만 카운터 및 시퀀스 생성기 같은 공유 데이터 한 개의 갱신에만 제한되는 경우가 많다
- 일반적인 상황에서 경쟁 조건을 해결하는 더 강력한 도구를 살펴본다

## 6.5 뮤텍스 락(Mutex Locks)

- 6.4절의 `하드웨어 기반 임계구역 해결책`은 복잡하고 `응용 프로그래머는 사용할 수 없다`
- 운영체제 설계자들은 임계구역 문제를 해결하기 위한 `상위 수준 소프트웨어 도구`를 개발한다
  - 가장 간단한 도구 : mutex lock(뮤텍스 락)
- Mutex lock = mutual(상호간의) + exclusion(제외) lock
  - 임계구역을 보호하고 들어가기 전에 반드시 락을 획득해야 하고 임계구역을 빠져나올 때 락을 반환해야 한다
- Mutex lock

  - 프로세스가 임계구역에 `들어가기 전에 락을 획득`하고 임계구역에서 `나올 때 락을 해제`할 것을 요구함으로써 상호 배제를 제공한다

```c
// pseudocode
acquire() {
  while (!available) {
    // busy wait
  }
  available = false;
}

release() {
  available = true;
}

while (true) {
  // entry section
  acquire();

  // critical section

  // exit section
  release();

  // remainder section
}

```

- mutext_lock.c

#### busy waiting(바쁜 대기)

- 지금까지 설명한 구현 방식의 단점은 바쁜 대기(busy waiting)를 해야 한다는 것이다
- 프로세스가 임계 구역에 있는 동안 임계구역에 들어가기를 원하는 다른 프로세스들은 acquire() 함수를 호출하는 반복문을 계속 실행해야 한다
- 이러한 계속된 루프의 실행은 하나의 CPU 코어가 여러 프로세스에서 공유되는 다중 프로그래밍 시스템에서 문제가 된다(CPU 주기 낭비)

  - 6.6절에서 대기 프로세스를 일시적으로 휴면 상태로 전환 후 락을 사용할 수 있게 되면 깨워서 바쁜 대기를 피하는 전략을 검토한다

- mutex락 유형을 스핀락(spinlock)이라고도 한다(=바쁜 대기, busy wait)
  - 스핀락은 프로세스가 락을 기다려야하지만 문맥 교환에 상당한 시간이 소요될 때 문맥 교환이 필요하지 않다는 장점이 있다
  - 다중 코어 시스템의 특정 상황에서는 실제로 락이 필요할 때 스핀락이 선호된다
  - 잠깐 동안 락을 유지해야 하는 경우 다른 스레드가 하나의 코어에서 임계구역을 실행하는 동안 스레드는 다른 처리 코어에서 스핀하고 있을 수 있다
- 최신 다중 코어 컴퓨팅 시스템에서 스핀락은 많은 운영체제에서 널리 사용된다
- 7장에서 고전적인 동기화 문제를 해결하기 위해 mutex락과 스핀락을 사용하는 방법에 대해 검토한다

## 6.6 세마포(Semaphores)

- mutex는 동기화 도구의 가장 간단한 형태이다
- mutex와 유사하게 동작하지만 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공하는 강력한 도구를 설명한다 -> 세마포
- 세마포(S)는 정수 변수로서, 초기화를 제외하고 단지 두 개의 표준 원자적 연산 wait()와 signal()로만 접근할 수 있다
  - wait()
    - 네덜란드어 proveren(검사하다) => P
  - signal()
    - 네덜란드어 verhogen(증가하다) => V

```c
// S : 세마포 변수(정수)
wait(S) {
  while (S <= 0) {
    // busy wait
  }
  S--;
}

signal(S) {
  S++;
}
```

- wait()과 signal() 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 원자적으로 수행되어야 한다
- 즉, 한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없다

### 6.6.1 세마포 사용법(Semaphore Usage)

- 세마포 구분

  - 카운팅(counting)
  - 이진(binary)

- 카운팅 세마포 : 제한 없는 영역(domain)을 갖는다
- 이진 세마포 : 0, 1 사이의 값만 가능하다
  - 이진 세마포는 mutex락과 유사하게 동작한다

### 6.6.2 세마포 구현(Semaphore Implementation)

- 6.5절에서 mutex락은 바쁜 대기(busy wait)를 해야 했다
- 지금 설명한 세마포 연산 wait()과 signal()의 정의 역시 같은 문제를 가지고 있다
- 이 문제를 극복하기 위해 wait()과 signal()의 세마포 연산의 정의를 다음과 같이 변경할 수 있다

```c
typedef struct {
  int value;
  struct process *list;
} semaphore;

wait(semaphore *S) {
  S->value--; // -> 는 접근 연산자이다
  if (S->value < 0) { // busy wait 대신 대기 큐에 넣고 프로세스의 상태를 대기 상태로 전환한다
    add this process to S -> list;
    sleep();
  }
}

signal(semaphore *S) {
  S->value++;
  if (S->value <= 0) { // 프로세스의 상태를 대기상태에서 준비 완료 상태로 변경한다(ready queue)
    remove a process P from S->list;
    wakeup(P);
  }
}
```

- 세마포를 원자적으로 실행되어야 한다는 것은 매우 중요하다
  - wait()과 signal() 연산이 동시에 실행할 수 없도록 반드시 보장해야 한다
  - 단순히 wait()과 signal() 연산이 실행되는 동안 인터럽트를 금지함으로써 간단히 해결할 수 있다
  - 하지만 다중 코어 환경에서는 모든 처리 코어에서 인터럽트를 금지해야 한다
    - 모든 코어에서 인터럽트를 금지하는 것은 매우 어려운 작업일 수 있으며 성능을 심각하게 감소시킨다
    - 따라서 SMP(symmetric multiprocessing, 대칭 다중 프로세서) 시스템에서는 세마포를 원자적으로 실행되어야 한다는 것을 보장하기 위해 스핀락과 같은 다른 기법을 제공해야 한다
      - 우리는 wait()과 signal()에서 busy wait를 완전하게 제거하지 못했다는 것을 인정하는 것이 중요하다

### 요약

- Mutex락과 같이 세마포를 사용하여 상호 배제를 제공할 수도 있다
  - 그러나 `mutex 락`은 락의 사용 여부를 나타내는 `이진 값`을 가지지만
  - 세마포는 정수 값을 가지므로 다양한 동기화 문제를 해결하는 데 사용될 수 있다
  - semaphores.c -> mac에서는 동작하지 않는다
- e.g. 헬스장에서 여러개의 락커룸이 있고 각 락커룸에 대한 열쇠를 카운터에서 하나씩 가지고 있는 것

## 6.7 모니터(Monitors)

- 세마포는 편리하고 효과적으로 쓰일 수 있지만 자칫 잘못 사용하면 발견하기 어려운 타이밍 오류를 발생시킬 수 있다
  - e.g. 락커룸 하나에 대한 여러개의 열쇠
- 이러한 오류를 처리하기 위한 전략은 간단한 동기화 도구를 통하여 `고급 언어 구조물을 제공`하는 것이다

  - 이 절에서는 근본적인 고급 언어 구조물 중 하나인, 모니터(monitors) 형을 설명한다

- `모니터 형`은 `추상화된 데이터 형(abstract data type, ADT)`이다

  - `추상화된 데이터 형(abstract data type, ADT)` : 데이터와 해당 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다
  - ~= 클래스, 라이브러리

#### java에서 제공하는 모니터

- synchronized 키워드
  - SynchExample.java
- wait() and notify()
  - 어떤 쓰레드가 어떤 객체의 wait() 메소드를 호출하면
    - 해당 객체의 모니터락을 획득하기 위해 대기 상태로 진입함
  - 쓰레드가 어떤 객체의 notify() 메소드를 호출하면
    - 해당 객체 모니터에 대기중인 쓰레드 하나를 깨움
  - notifyAll()
    - 해당 객체 모니터에 대기중인 모든 쓰레드를 깨움

### 요약

- 모니터
  - 프로세스 동기화의 높은 수준의 형태를 제공하는 추상 데이터 유형이다
  - 모니터는 프로세스가 특정 조건이 true가 될 때까지 대기(wait)할 수 있게 하고 조건이 true가 되면 서로에게 신호(signal)를 보낼 수 있게 허용하는 조건변수를 사용한다
    - e.g. java
      - wait() and notify()

## 6.8 라이브니스(Liveness)

- 임계 구역에 대한 접근을 조정하기 위해 동기화 도구를 사용하는 것의 한 가지 결과는

  - 프로세스가 더 이상 진행되지 않는 교착 상태(deadlock)가 발생할 수 있다는 것이다

- 라이브니스는 `프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성`
  - 무기한 대기는 라이브니스 실패의 한 예이다

### 6.8.1 교착 상태(Deadlock) - 라이브니스 실패로 이어질 수 있는 상황 1

- 교착 상태(deadlock)
  - 두 개 이상의 프로세스들이, 대기상태에서 무한정 기다리는 상황
  - 교착 상태 뿐만 아니라 다양한 라이브니스 실패 처리 -> 8장
    - 8.4절 교착상태 처리 방법
      - 교착 상태 예방
      - 교착 상태 회피
      - 교착 상태 허용 후 복구

### 6.8.2 우선순위 역전(Priority Inversion) - 라이브니스 실패로 이어질 수 있는 상황 2

- 높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스 또는 연속된 낮은 우선순위 프로세스들에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 발생한다
- 커널 데이터는 락에 의해 보호되기 때문에 낮은 우선순위 프로세스가 자원의 사용을 마칠 때 까지 높은 우선순위 프로세스가 기다려야 한다
- e.g.
  - L < M < H
    - L이 공유자원을 사용하고 있다가 끝나면 H가 아닌 M이 공유자원을 사용하게 되는 현상
- 우선순위 역전문제는 `우선순위 상속 프로토콜(priority-inheritance protocol)을 구현하여 해결`한다
  - 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날 때 까지 더 높은 우선순위를 상속받는다
  - 자원 사용이 끝나면 원래 우선순위로 되돌아간다
  - L이 임시로 H의 우선순위를 상속받게 하고, 따라서 프로세스 M이 L의 실행을 선점하는 것을 방지한다
  - 자원 사용이 끝나면 L은 원래 우선순위로 돌아가고
  - 공유자원은 가용 상태가 되었기 때문에 M이 아닌 H가 공유자원을 사용하게 된다

### 요약

- 임계구역 문제에 대한 해결책은 교착 상태(deadlock)를 포함한 라이브니스(liveness) 문제를 겪을 수 있다
- 8장에서 교착 상태 뿐만 아니라 다른 형태의 라이브니스 실패를 처리하는 다양한 기법들에 대해 설명한다

## 6.9 평가(Evaluation)

- 임계구역 문제를 해결하고 프로세스 활동을 `동기화`하는 데 사용될 수 있는 `여러 도구는 다양한 경합 정도에 따라` 평가할 수 있다
- 일부 도구는 특정 경합 상황(race condition)에서 다른 도구들보다 더 잘 작동한다
  - 카운터와 같은 공유 변수에 대한 단일 업데이트에는 `원자적 정수`가 훨씬 가볍기 때문에 mutex나 semaphore 보다 더 적합하다
  - `mutex락`은 세마포보다 간단하고 오버헤드가 적으며 임계구역에 대한 접근을 보호하는 용도로 이진 세마포보다 선호된다
  - 그러나 한정된 수의 자원에 접근을 제어하는 것과 같은 일부 용도의 경우 mutex락보다 `카운트 세마포`가 더 적합하다
- 다음 장에서는 개발자가 사용할 수 있는 다양한 운영체제 및 API가 이 장에서 제시된 동기화 도구를 어떻게 구현하는지 살펴본다
