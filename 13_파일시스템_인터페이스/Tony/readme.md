# Part 6. 파일 시스템(File system)

- `파일`은 작성자가 정의한 연관된 `정보의 모음`이다
- 파일은 운영체제에서 물리적 대용량 저장장치로 매핑된다
- `파일 시스템`은
  - `파일`이 `물리적 장치에 매핑`되는 방법과
  - 사용자와 프로그램이 `파일을 액세스하고 조작`하는 방법을 설명한다
- 물리적 저장장치에 대한 액세스 속도가 느릴 수 있으므로 효율적인 액세스를 목표로 파일 시스템을 설계해야 한다
- 파일 공유 및 파일에 대한 원격 액세스 지원을 포함하여 다른 요구 사항도 중요할 수 있다

# 13. 파일 시스템 인터페이스(File system interface)

- 파일 시스템은 가장 많이 노출되는 범용 운영체제의 부분이다
  - 온라인으로 저장하고 접근하는 기법 제공
- 파일 시스템의 두 부분
  - 정보 자료를 저장하는 실제적인 파일의 집합체
  - 시스템 내의 모든 파일 정보를 제공하는 디렉터리 구조
- 파일 시스템은 저장장치상에 구현된다
- 이번장에서 파일의 다양한 면과 주된 디렉터리 구조에 관해서 살펴보고
- 다중 프로세스, 사용자 그리고 컴퓨터 간에 파일을 공유하는 의미(semantics)를 알아본다
- 마지막으로, 다수의 사용자가 파일을 사용할 경우에 파일을 어떻게 보호할 것인가에 대한 보호 방법에 관하여 살펴본다

#### 이 장의 목표

- 파일 시스템의 기능을 설명한다
- 파일 시스템 인터페이스의 특징을 기술한다
- 접근 방법, 파일 공유, 파일 락, 디렉터리 구조를 포함하는 파일 시스템 설계 절충에 관해서 논한다
- 파일 시스템 보호에 대해서 고려해본다

## 13.1 파일 개념(File concept)

- 컴퓨터는 정보를 각기 다른 저장 매체에 저장할 수 있다
  - 저장 매채 : NVM 장치, HDD, 자기 디스크, 자기 테이프, 광디스크, ...
- 운영체제가 저장 정보에 대한 일과된 논리적 관점을 제공하고, 저장장치의 물리적 특성을 추상화하여 논리적 저장 단위, 즉 `파일`을 정의한다
- 파일은 운영체제에 의해 물리장치와 매핑된다
  - 저장장치들은 일반적으로 비휘발성이기 때문에 시스템이 재부팅 되어도 저장된 내용은 영구히 존속된다
- `파일`은 `보조저장장치에 기록된 관련 정보의 집합`으로 정의할 수 있다
  - 사용자 관점에소 볼 때 파일은 논리적 보조저장장치의 가장 작은 할당 요소이다
- 소스 또는 실행 프로그램, 숫자 또는 텍스트, 사진, 음악 비디오 등 다양한 정보들이 파일 내에 저장되고, 유형에 따라 특별히 정의된 구조를 가진다
  - 텍스트 파일 : 행들로 구성되는 연속된 문자들
  - 소스 파일 : 함수들의 연속, 각 함수는 선언과 실행문의 순서로 구성
  - 실행 파일 : 로더가 메모리로 가져와 실행시킬 수 있는 연속된 코드 부분들

### 13.1.1 파일 속성(File attributes)

- 파일은 운영체제마다 다른 속성을 갖지만 전형적으로 다음과 같은 속성들을 가진다
  - 이름 : 기호형 파일의 이름은 사람이 읽을 수 있는 형태로 유지된 유일한 정보이다
  - 식별자(identifier) : 이 고유의 꼬리표는 통상 하나의 숫자로 파일 시스템 내에서 파일을 확인한다
    - 식별자는 우리가 읽을 수 없는 파일의 이름이다
  - 유형 : 이 정보는 여러 유형을 제공하는 시스템을 위해 필요하다
  - 위치 : 이 정보는 파일이 존재하는 장치와 그 장치 내의 위치에 대한 포인터이다
  - 크기 : 파일의 현재 크기(바이트, 워드 혹은 블록들로 나타낸다)와 최대 허용 가능한 크기가 이 속성에 포함된다
  - 보호 : 접근 제어 정보는 누가 읽기, 쓰기, 실행 등을 할 수 있는가를 제어한다
  - 타임스탬프와 사용자 식별 : 이 정보는 생성, 최근 변경, 최근 사용 등을 유지하고, 이들 자료는 보호, 보안 및 사용자 감시를 위해 사용된다
- 디렉터리는 파일의 휘발성과 일치해야 하므로, 파일과 같이 장치에 저장되어야 하고, 필요할 때 마다 메모리로 조금씩 반입된다

### 13.1.2 파일 연산(File operations)

- 파일이란 추상적인 데이터 유형이다
- 파일을 적절히 정의하기 위해 파일에 대해 실행할 수 있는 연산을 고려해 볼 필요가 있다
- 운영체제는 파일을 위해 아래 시스템 콜들을 제공한다
  - 파일 생성
  - 열기
  - 쓰기
  - 읽기
  - 위치 재설정
  - 삭제
  - 절단
- 위 7개의 파일 연산에 대해 운영체제가 해야 할 일이 무서인가를 알아보자

#### 1. 파일 생성

- 파일 생성을 위해 2단계가 필요
  - 첫째, 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾아야 한다
    - 14장에서 파일을 위한 공간 할당 방법을 기술하고 있다
  - 둘째, 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야한다

#### 2. 파일 열기

모든 파일 연산에서 파일 이름을 지정하게 하면 운영체제가 이름을 검사하고,

접근 권한을 확인하는 등의 작업을 매번 수행해야 하므로 생성과 삭제를 제외한 모든 연산을 하기 전에 반드시 파일을 open() 해야 한다

성공하면 open 콜은 다른 콜의 인자로 사용되는 파일 핸들을 반환한다

#### 3. 파일 쓰기

- 파일을 쓰기 위해서는 `열린 파일 핸들`과 `피일에 기록될 정보를 명시`하는 시스템 콜을 실행한다
- 시스템은 파일 내의 다음 순차적 쓰기가 일어날 위치를 가리키는 쓰기 포인터(write pointer)를 유지하고 있어야 한다
- 쓰기 포인터는 쓰기가 일어날 때마다 갱신되어야 한다

#### 4. 파일 읽기

- 파일을 읽기 위해서 파일 핸들과 파일이 읽혀야 할 블록의 위치(메모리 내)를 기술하는 시스템 콜을 사용한다
- 시스템은 순차적 읽기가 일어날 때 파일 안의 위치를 가리키는 읽기 포인터(read pointer)를 유지할 필요가 있다
- 프로세스는 일반적으로 파일 읽기나 파일 쓰기 중 하나를 하고 있기 때문에,
  - 대부분의 `시스템`은 `하나의` `현재 파일 위치 포인터(current file position pointer)`를 가진다
- 읽기와 쓰기 연산 모두 이 포인터를 사용함으로써 공간을 절약하고 시스템의 복잡성을 감소시킨다

#### 5. 파일 안에서의 위치 재설정(reposition)

- 열린 파일의 현재 파일 위치를 주어진 값으로 설정한다
- 파일 내에서 위치의 재설정을 위해 실제로 입출력할 필요는 없으며, 이 파일 연산은 파일 탐색(seek)으로도 알려져 있다

#### 6. 파일 삭제

- 파일을 삭제하기 위해 지정된 파일을 디렉터리에서 찾는다
- 해당 디렉터리 항목을 찾으면 다른 파일에서 재사용 할 수 있도록 모든 파일 곤간을 해제하고 디렉터리 항목을 지우거나 사용가능으로 표시한다
- 일부 시스템은 동일한 파일에 대해 여러 개의 이름(디렉터리 항목)이 존재할 수 있는 하드 링크를 허용한다
  - 이 경우 실제 파일 내용은 마지막 링크가 삭제될 때까지 삭제되지 않는다

#### 7. 파일 절단

- 사용자가 파일의 내용은 지우고 다만 그 파일의 속성은 그대로 남기기를 원할 때 사용한다
- 사용자가 파일을 삭제하고 파일을 재생성하게 하는 것이 아니라, 이 기능은 파일의 길이를 제외한 모든 속성은 그대로 유지하게 한다
- 파일의 길이가 0으로 재설정되며, 파일이 가지고 있던 공간으 해제될 수 있다

#### 파일 연산 정리

- 위 7개의 연산은 파일 조작에 필요한 최소 연산
- 이들 기본적인 조작 연산은 다른 조작 연산을 실행하기 위해 결합할 수도 있다
- 파일 복사 예시
  - 새로운 `파일을 생성`하고 `기존 파일을 읽어` `새로운 파일에 기록`함으로써 파일의 복사본을 생성할 수 있다

#### 열린 파일 테이블(Open-file table)

- 운영체제는 모든 열린파일에 대한 정보를 갖는 `열린 파일` 테이블을 유지한다
- 임의의 파일 연산이 요구되면, 이 테이블에 대한 인덱스로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않다
- 파일이 더 사용되지 않으면 프로세스에 의해 닫히고 운영체제는 열린 파일 테이블에 있는 항목을 제거하며, 락을 해제할 가능성이 있다
  - create()과 delete()는 열린 파일보다는 닫힌 파일을 대상으로 동작하는 시스템 콜이다
- open() 시스템콜은 열린파일 테이블 항목에 대한 포인터를 리턴한다

  - 실제 파일명이 아닌 포인터를 입출력 연산에 사용함으로써 더 이상의 탐색 과정을 피하고 시스템 콜 인터페이스를 단순화한다

- 여러 개의 프로세스가 동시에 파일을 열 수 있는 환경
- 보통 운영체제는 두 단계 내부 테이블, 즉 `프로세스 별 테이블`과 `범 시스템 테이블`을 사용한다
  - `프로세스별 테이블`은 각 프로세스가 연 모든 파일을 기록한다
    - 이 테이블에 저장된 내용은 프로세스가 파일을 어떻게 사용하는가에 관한 정보이다
    - 예. 각 파일에 대한 현재 파일 포인터는 여기에 있으며, 다음에 수행될 읽기 또는 쓰기 시스템 콜이 영향을 미칠 파일의 위치를 나타낸다
  - 범 시스템 테이블
    - 프로세스별 테이블의 각 항목(entry)은 다시 범 시스템 열린 파일 테이블들을 가리킨다
    - 범 시스템 테이블은 프로세스에 독립적인 정보. 즉, 디스크 상의 파일 위치, 접근 날짜, 그리고 파일 크기와 같은 정보들을 갖고 있다
    - 일반적으로 열린 파일 테이블은 파일을 연 프로세스 수를 가리키는 열린 계수(open count)를 각 파일에 연관해 두고 있다

#### 열린 파일 관련 정보 요약

- 파일 포인터

  - 읽기와 쓰기 시스템 콜의 일부분으로 파일 오프셋(offset)을 포함하지 않는 시스템은 현재 파일 위치 포인터로서 가장 최근의 읽기/쓰기 위치를 추적해야한다
  - 이 포인터는 파일 연산을 수행하는 각 프로세스에 대해 유일하게 하나씩 만들어지므로 디스크상의 파일 속성들과는 분리되어 유지되어야 한다

- 파일 열린 계수(open count)

  - 이 계수는 파일의 총 open()과 close()의 수를 추적하며, 이 계수 값이 0에 도달하면, 그때 시스템은 항목을 제거할 수 있다

- 파일의 위치

  - 대부분의 파일 연산들은 시스템에서 파일 내의 데이터를 읽거나 쓰도록 요구
  - `파일의 위치(대용량 저장장치, 네트워크를 통한 파일서버 혹은 RAM 드라이브 등)를 찾기 위한 정보`는 연산마다 디렉터리 구조에서 읽는 것을 피하고자 `메모리에 저장`된다

- 접근 권한
  - 각 프로세스는 한 파일의 하나의 접근 모드로 연다
  - 이 접근 권한에 대한 정보는 프로세스 별 테이블에 저장되며, 이 정보로 후속 요구를 허용하거나 불허하는 데 사용할 수 있다

#### 락킹(locking)

- 몇몇 운영체제는 열린 파일(또는 파일의 섹션)을 락킹(locking)할 수 있는 기능을 제공한다
- 파일 락은 하나의 프로세스가 파일을 잠그고 다른 프로세스들이 그것에 대한 접근을 막는데 사용될 수 있다
- 시스템 로그파일과 같이 공유되는 파일들에 유용하다
- 공유락(shared lock) : 여러 프로세스가 동시에 락을 획득할 수 있다는 점에서 읽기 락과 비슷하다
- 배타적 락(exclusive lock) : 한 번에 한 프로세스만 락을 획득할 수 있다는 점에서 쓰기 락(writer lock)과 비슷하게 행동한다
- 강제적 락(mandatory lock) : 어떤 프로세스가 배타적 락을 획득하면 운영체제는 다른 프로세스가 잠겨진 파일에 접근하는 것을 막는다
  - 예. 한 프로세스가 system.log 파일에 배타적 락을 획득, 운영체제는 배타적 락이 해제될 때까지 접근을 막는다
  - 락 무결성을 안전하게 보장
- 권고적(advisory) 락
  - 락이 적절히 획득되고 해제되는 것에 대한 보장은 소프트웨어 개발자의 몫
- Windows : 강제적 락
- Linux : 권고적 락

### 13.1.3 파일 유형

- 파일 유형 지원 -> 파일에 대해 합리적 연산을 수행할 수 있다
  - 예. 텍스트 파일과 목적 코드 파일을 다르게 인식
    - 엉뚱한 시도를 막을 수 있다
- 흔히 알려진 파일 이름의 한 부분이 파일 유형으로 나타내도록 하는 것
  - 파일 이름이 마침표로 구분되는 이름과 확장자(extension) 두 부분으로 나뉨
- 시스템 파일 유형에 따라 파일 연산을 결정한다

  - 예. .com, .exe, .sh 확장자를 가진 파일들은 수행파일로서 이 확장자를 가진 파일만이 실행가능하다

- 셸 스크립트
  - .sh 확장자를 가진 파일
  - 운영체제에 전달되는 명령을 ASCII형식으로 저장하고 있다
- 확장자는 운영체제가 지원하는 것은 아님
- 확장자는 응용 프로그램이 동작하는 파일들에 대한 '힌트'로 생각될 수 있다

| 파일 유형       | 일반적 확장자                | 기능                                                                  |
| --------------- | ---------------------------- | --------------------------------------------------------------------- |
| 실행 가능       | exe, com, bin 혹은 없는 경우 | 수행 가능 기계어 프로그램                                             |
| 목적            | obj, o                       | 연결(link)되지 않은 상태의 컴파일된 기계 언어                         |
| 소스 코드       | c, cc, java, perl, asm       | 다양한 언어로 된 소스 코드                                            |
| 배치            | bat, sh                      | 명령 해석기에 대한 명령                                               |
| 마크업          | xml, html, tex               | 텍스트 데이터, 서류                                                   |
| 워드프로세서    | xml, rtf, docx               | 다양한 워드프로세서 형식                                              |
| 라이브러리      | lib, a, so, dll              | 프로그래머들을 위한 라이브러리 루틴                                   |
| 인쇄나 뷰(view) | gif, pdf, jpg                | 인쇄 출력용 파일로서 ASCII 혹은, 이진 파일 형식                       |
| 백업, 보관      | rar, zip, tar                | 관련된 파일들을 하나로 묶어서 보관하는 것으로 저장을 위해 압출도 가능 |
| 멀티미디어      | mpeg, mov, mp3, mp4, avi     | 오디오나 비디오 정보를 포함하는 이진 파일                             |

- 그림 13.3 일반적인 파일 유형

- macOS에서 .app(응용 프로그램의 경우)와 같은 파일 유형을 가지며,
  - 각 파일은 자신을 생성한 프로그램의 이름을 파일의 속성으로 가진다
- UNIX 시스템은 일부 이진 파일의 시작 부분에 저장된 매직 넘버(magix number)를 사용하여 파일의 데이터 유형(예, 이미지 파일 형식)을 나타낸다
  - 매직 넘버 및 기타 컴퓨터 전문 용어에 대한 자세한 내용 참고 링크
    - http://www.catb.org/esr/jargon/
  - 모든 파일이 매직 넘버를 갖고 있는 것은 아니다
  - UNIX는 파일 이름 확장자 힌트를 허용하지만 이러한 확장자는 운영체제에 의해 강제되거나 운영체제가 이에 의존하지 않는다
    - 주로 사용자가 파일에 포함된 콘텐츠 유형을 결정하는 데 도움을 주려는 것이다
- 확장자는 응용 프로그램에서 사용되거나 무시될 수 있지만 응용 프로그램의 프로그래머에게 달려있다

### 13.1.4 파일 구조

- 어떤 운영체제들은 파일 형태, 구조에 대해 제한을 거의 두지 않는다(UNIX, Windows)
  - UNIX는 파일을 단순히 8비트 바이트들의 단순한 집합으로 보기 때문에 그 내용이나 구조에 대하여 관여하지 않는다
  - 유연성 극대화
  - 응용 프로그램들이 각자의 프로그램에서 파일들에 대한 적절한 해석과 운용을 책임져야 한다
- 모든 운영체제는 반드시 프로그램을 로딩하고 실행할 수 있는 실행 파일구조를 지원한다

### 13.1.5 파일의 내부 구조(Internal File Structure)

- 한 파일 내이 어떤 위치를 찾는 것은 복잡할 수 있다

  - 디스크 시스템 : 섹터의 크기에 의해 결정되는 블록 크기를 가진다
  - 모든 디스크 I/O는 한 블록 단위로 수행되며, 모든 디스크 블록들은 동일한 크기를 가진다
  - 논리 레코드의 길이는 매우 다양하며, 여러 논리 레코드를 하나의 물리 레코드에 팩킹(packing)하는 것이 일반적이다

- 예를 들면, UNIX 운영체제는 앞에서 소개한 것과 같이 모든 파일을 바이트들의 연속된 열(stream)이라고 간단하게 정의한다
  - UNIX 파일 내의 각 바이트는 시작부터 몇 번째 바이트 위치라고 부르는 오프셋에 의해 위치 지정이 가능하다
- 디스크가 공간이 항상 블록 단위로 할당되기 때문에 각 파일의 마지막 블록의 일부는 낭비된다
  - 내부 단편화(internal fragmentation)라고 한다
  - 블록의 크기가 클수록 내부 단편화가 커진다

## 13.2 접근 방법(Access Methods)

- 파일은 정보를 저장한다
- 파일이 `사용될 때`는 이 정보가 반드시 접근되어 컴퓨터 `메모리로` 읽혀야 한다

### 13.2.1 순차 접근(Sequential Access)

- 가장 간단한 접근 방법
- 디스크에 있는 파일을 카세트테이프를 재생하는 방식처럼 접근한다(저장되어 있는 레코드 순서로 접근한다)
- 이 접근 모드는 가장 일반적이며, 편집기나 컴파일러는 보통 이러한 형식으로 파일에 접근한다
- 파일에 대한 대부분의 연산은 읽기(read)와 쓰기(write)이다
- 읽기는 파일의 다음 부분부터 차례로 읽어 나간다
- 읽으면 자동으로 현재 위치를 추적하는 파일 포인터(offset)가 자동으로 증가한다
- 마찬가지로 쓰기 작업은 파일의 끝에 추가하며, 새로운 파일의 끝으로 파일 포인터가 이동한다

### 13.2.2 직접 접근(Direct Access)

- 직접 접근(또는 상대 접근)
- 파일은 고정 길이의 논리 레코드의 집합으로 정의되고 직접 접근 파일은 어떠한 블록이라도 직접 액세스할 수 있다
- 직접 접근 방법은 파일의 디스크 모델에 기반하며, 이는 디스크가 임의의 파일 블록에 임의적 접근을 허용하기 때문이다
- 직접 접근 파일은 임의의 블록을 읽거나 쓸 수 있게 한다
  - 예. 블록 14 -> 블록 53 -> 블록7
- 직접 접근 파일에는 읽기나 쓰기의 순서에 제약이 없다
- 직접 접근 파일은 대규모의 정보를 다루는 데 아주 유용하며, 대규모 데이터베이스가 이러한 유형일 수 있다
- 직접 접근 방법을 위해서 블록 파라미터를 포함
  - 블록 번호(block number) : 블록의 위치를 나타내는 숫자
  - 상대 블록번호(relative block number) : 블록의 위치를 파일의 시작부터의 오프셋으로 나타내는 숫자
  - 블록 크기(block size) : 블록의 크기
  - 상대적 블록 번호 -> 할당 문제
    - 14장에서 논의
    - 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막을 수 있게 한다
- 시스템 파일의 N번째 레코드에 대한 요청
  - 레코드 길이 : L
  - N번째 레코드에 대한 요청은 파일의 L \* (N)의 위치로 부터 L(byte)에 대한 요청이 된다

### 13.2.3 기타 접근 방법(Other Access Methods)

- 직접 접근 파일이 있으면 그것을 기반으로 여러가지 다른 파일 접근 방법을 제공할 수 있다
- 색인(index) : 책의 맨 뒷부분에 나오는 것과 같이 여러 부분에 대한 포인터를 제공하는 것
  - 찾고자 하는 레코드가 있으면 먼저 이 색인부터 찾아 그에 대응하는 포인터를 얻는다
  - 그 포인터를 사용하여 파일을 직접 접근하고 원하는 레코드를 찾는다
- 2차 색인 ~ 내 생각 : 메모리의 페이징과 비슷한 것 같다

## 13.3 디렉터리 구조(Directory Structure)

- 디렉터리는 파일 이름을 상응하는 파일 제어 블록으로 바꾸어주는 심볼 테이블(symbol table)로 볼 수 있다
- 디렉터리 시스템의 논리적 구조를 정의하는 몇몇 체계를 살펴보자

  - 파일 찾기
    - 디렉터리 탐색 - 특정 패턴과 일치하는 이름을 갖는 모든 파일을 찾을 수 있어야 할 것이다
  - 파일 생성
    - 새로운 파일을 생성하여 디렉터리에 첨가한다
  - 파일 삭제
    - 더는 필요하지 않은 파일을 디렉터리에서 삭제한다
  - 디렉터리 나열
    - 디렉터리에 존재하는 파일을 나열
    - 삭제는 디렉터리 구조에 hole을 남기고 파일 시스템에는 디렉터리 구조의 단편화를 없애는 방법이 나을 수 있다
  - 파일의 재명명
    - 파일의 이름을 변경할 수도 있어야 한다
    - 만약 변경된 이름이 기존의 이름보다 커져 디렉터리 항목에 반영될 수 없는 경우에는
      - 디렉터리 구조 내에서 항목의 위치가 변경되어야 하는 예도 있을 것이다
  - 파일 시스템의 순회(traverse)
    - 디렉터리 순회 - 파일을 볼 수 있게 해줌
    - 신뢰성을 고려하면 주기적으로 다른 시스템 또는 클라우드에 저장하는 것이 좋다(백업)

- 다음 절에서는 디렉터리의 논리적 구조를 정의하는 가장 일반적인 체계를 기술한다

### 13.3.1 1단계 디렉터리

- 모든 디렉터리 구조가 1단계
- 파일이 많아지거나 사용자가 사용하는 시스템에서는 심각한 제약을 가지고 있다
  - 같은 디렉터리에 모든 파일이 존재하므로 각 파일들은 유일한 이름을 가져야 한다

### 13.3.2 2단계 디렉터리

- 1단계 디렉터리에서 각 사용자에게 서로 다른 디렉터리를 만들어주는 것
  - UFD(user file directory)
- 시스템에 사용자가 로그인(login)하면 시스템은 마스터 파일 디렉터리(MFD, master file directory)에서 사용자의 UFD를 찾는다
- 사용자 디렉터리르 위한 디스크 공간 할당은 14장에서 논의될 파일 자신을 위한 기법으로 처리될 수 있다
- 파일 이름 충돌은 해결하였지만 파일을 공유할 수 없는 문제가 발생한다

- 사용자 이름과 파일 이름은 루트(MFD)로 부터 leaf(특정 파일)까지 경로를 정의한다
  - 이 모든 파일이름은 모든 파일이 가지고 있는 경로명(path name)이 된다
- 2단계 디렉터리에서 특정 파일을 지칭하기 위해서는 파일 이름과 파일명을 사용해서 경로명(path name)을 써야 한다
- e.g.
  - 사용자 A, text.tsx
  - 사용자 B, /user/test/tsx
- 시스템마다 볼륨을 위해 다른 구문을 쓰기도 한다
  - e.g.
    - Windows : C:\user\test\text.tsx
      - 콜론(:)은 볼륨을 나타내는 구분자
    - Unix : /user/test/text.tsx
      - UNIX와 Linux에선 파티션 이름을 디렉터리 이름 일부로 취급한다

### 13.3.3 트리 구조 디렉터리

- 여러 단계로 확장하는 일반적인 방법
- 사용자들에게 자신의 서브디렉터리(subdirectory)를 얼마든지 만들 수 있도록 해준다
- 트리구조 디렉터리에서 디렉터리는 특별 취급을 받는 파일이라고 생각할 수 있다

  - 한 비트를 사용하여 그 항목이 파일(0) 인지 디렉터리(1) 파일 인지를 구분한다

- 경로명에는 절대 경로명과 상대 경로명 두 가지가 있다
  - 절대 경로명 : 루트 디렉터리에서 시작하는 경로명
    - e.g. /user/test/text.tsx
  - 상대 경로명 : 현재 디렉터리에서 시작하는 경로명
    - e.g. ./user/test/text.tsx

### 13.3.4 비순환 그래프 디렉터리(Acyclic Graph Directory)

- 디렉터리들이 서브디렉터리들과 파일들을 공유할 수 있도록 허용하는 구조
- 비순환 그래프는 트리구조 디렉터리 방식을 일반화한 것이다
- 어떤 파일을 여러 디렉터리에 존재할 수도 있다

- 공유 파일(공유 디렉터리)은 여러 방법으로 구현한다

  - 일반적인 방법(UNIX)으로 링크(link)라 불리는 새로운 디렉터리 항목을 만드는 것으로 링크는 다른 파일이나 서브디렉터리를 가리키는 포인터이다
  - 이러한 링크는 절대 혹은 상대 경로명으로 구현될 수 있다
  - 운영체제가 디렉터리 트리를 순회할 때는 시스템의 비순환 구조를 유지하기 위해 이들 링크를 무시한다

- 공유의 다른 방법으로 복사가 있다

  - 링크는 원래의 디렉터리와는 완연히 다른 것
  - 복사는 원래 것이 구분이 안 된다
  - 복사본을 수정하면 원본도 수정되어야 하는 일관성 문제가 발생한다

- 심볼릭 링크로 공유를 구현하는 시스템

  - 링크가 가리키는 파일이 지워지면 이 링크는 존재하지 않는 파일의 이름을 가리키는 링크가 된다
  - 이러한 링크를 탐색하고 삭제할 수 있지만, 파일마다 연관된 링크의 목록을 유지하지 않으면, 이 탐색에 소모되는 비용이 커지는 단점이 있다
  - 링크파일이 삭제되고 동일한 이름의 다른 파일이 생성될 때, 그 이름에 대한 심볼릭 링크를 어떻게 처리할 것인지에 대해서 신중히 고려해야 한다
    - UNIX, Windows의 경우 심볼릭 링크는 그대로 내버려둔다

- UNIX 하드 링크
  - 참조하는 링크가 0이 되면 파일은 삭제될 수 있다

### 13.3.5 일반 그래프 디렉터리

- `비순환 그래프 트리 구조`에 있어서 중요한 문제점은 `순환이 발생하지 않도록` 어떻게 `보장`하느냐는 것이다
- 성능상의 이슈로 공유 부분을 두 번 순회하는 것을 원하지 않는다
  - 잘못 설계된 알고리즘은 순환적으로 계속 탐색하고 종료하지 않는 무한루프에 빠질 수 있다
    - 해결 책 예시 1. 한번에 검색할 수 있는 디렉터리의 숫자를 임의로 제한하는 것
- 마지막 참조가 제거되고 디스크 공간이 재할당될 수 있을 때를 결정하기 위해 `가비지 수집(garbage-collection)` 기법을 사용해야 한다

  - 가비지 컬렉션은 전체 파일 시스템을 검색하고, 접근 가능한 모든 것을 표시한다
  - 그 후 두 번째 탐색에서 표시되지 않은 것들을 수집하고 사용 가능한 공간 리스트에 추가한다
    - 검색하는 동안 파일시스템의 모든 것을 한 번만 검색할 수 있다는 것을 보장하게 사용될 수 있다
  - 그러나 디스크 기반의 파일 시스템에서 가비지 컬렉션은 존재하면 `시간을 매우 많이 소모`하므로, 좀처럼 이용되지는 않는다

- 가비지 컬렉션은 그래프에 순환이 생길 경우에만 필요하기 때문에 비순환 그래프는 다루기 훨씬 쉽다
  - 새로운 링크가 디렉터리 구조에 추가될 때 순환이 생기지 않도록 하는 것이 주된 일이다
  - 새로운 링크가 순환을 만들지 어떻게 알 수 있을까?
    - 그래프에 순환이 존재하는지 검색하는 알고리즘은 많이 있다
    - 하지만 그래프가 디스크에 있을 때 그것들은 대부분 많은 계산량을 필요로 한다
  - 디렉터리와 링크의 특별한 경우에 좀 더 간단한 알고리즘은 디렉터리를 탐색하는 도중 링크는 검색하지 않는 것이다
    - 순환도 피할 수 있고, 추가적인 오버헤드도 발생하지 않는다

## 13.4 보호

- `정보`가 컴퓨터 시스템에 저장되어 있을 때, `물리적인 손상(신뢰성의 문제)`으로 부터 그리고 `부적절한 접근(보호의 문제)`으로 부터 안전하길 원한다
- 신뢰성은 파일의 복사본에 의해 제공된다
  - 많은 컴퓨터는 파일 시스템이 사고로 파괴될 경우를 대비하여 복사본을 유지하기 위해 규칙적인 간격(매일, 한 주 또는 한 달)으로 디스크 파일을 테이프에 자동 복사하는 시스템 프로그램이 있다
  - 신뢰성은 11장에서 자세히 다룬다
- 보호는 여러 가지 방법으로 제공될 수 있다
  - e.g. 랩톱 시스템
    - 사용자 이름 및 암호 인증을 요구하여 보호를 제공한다
  - 다중 사용자 시스템에서 시스템에 대한 유효한 액세스조차도 데이터에 대한 유효한 액세스만 허용하기 위해서는 고급 기법이 필요하다

### 13.4.1 접근의 유형(Types of Access)

- 보호 기법은 가능한 파일 접근 유형을 제한함으로써 통제된 접근을 제공한다
  - 여러 요인에 의해 접근이 허용되거나 거부된다
  - 요구되는 접근 유형 - 몇 가지 다른 유형의 연산들이 통제될 수 있다
    - 읽기 : 파일로부터 읽기
    - 쓰기 : 파일에 쓰기
    - 실행 : 파일을 메모리에 읽어오고 실행하기
    - 추가 : 파일의 끝에 새로운 정보를 첨부하기
    - 삭제 : 파일을 지우고 사용공간을 반납하기
    - 리스트 : 파일의 속성, 이름 등을 출력하기
    - 속성 변경 : 파일의 속성 변경하기
  - 이 외에도 이름 변경, 편집, 복사 같은 고급 명령들도 있을 수 있지만 그것들 대부분이 다 위의 기본 연산의 조하바으로 실행할 수 있다
  - 보호에 대한 완전한 논의는 17장으로 미룬다

### 13.4.2 접근 제어(Access Control)

- 사용자에 기반한 접근을 구현하는 가장 일반적인 방법은 각 파일과 디렉터리에 `접근 제어 리스트(access-control list, ACL)`를 연관해 두는 것이다
  - 이 리스트는 이 파일을 누가 어떤 연산을 위해 사용할 수 있는지를 기술한다
  - 만약 그 사용자의 요청이 리스트에 포함되어 있다면 접근은 허용되지만 보호 위반이 발생하면 사용자 작업은 파일에 대한 접근이 거부된다
- 접근 리스트의 주요 문제점은 그 리스트의 길이이다

  - 만약 모든 사람에게 읽기 접근을 허용하면 모든 사용자들이 읽기 접근을 가지도록 열거해야 할 것이다
  - 이러한 기법은 두 가지 원치않는 결과를 가진다
    - (1) 그러한 리스트를 구축하는 일은 지겹고 별 소득 없는 일이다
      - 특히 시스템 사용자의 리스트를 미리 알 수 없다
    - (2) 고정 크기였던 디렉터리 항목이 가변 크기가 되어 버려 결과적으로 더욱 복잡한 공간관리 문제가 발생한다
  - 이러한 문제점들은 접근 리스트를 간소화함으로써 해결될 수 있다
    - 많은 시스템은 모든 사용자를 세 가지 부류로 분류한다
      - 소유자 : 파일을 생성한 사용자
      - 그룹 : 파일을 공유하여 파일에 대한 유사한 접근을 해야 하는 사용자들의 집합
      - 기타 : 시스템에 있는 모든 다른 사용자들

- 최근 가장 일반적인 방법은 접근 제어 리스트를 일반적이고 구현하기 쉬운 소유자, 그룹, 모든 사람 접근 제어 기법과 결합하는 것이다

  - e.g. Solaris
    - 기본적으로 세 개의 분류가 사용되지만 보다 정교한 접근 제얼가 필요한 특정 파일과 디렉터리에 접근 제어 리스트를 추가하도록 허용한다
  - 이러한 기법이 적절하게 동작하려면, 허가 및 접근 리스트가 엄격하게 통제되어야 한다
    - 이러한 통제는 여러 방법으로 실행할 수 있다
    - 예를 들면 UNIX 시스템에서 그룹은 시스템의 관리자(혹은 슈퍼 유저)에 의해서만 생성되고 변경될 수 있다
    - 따라서 이러한 제어는 사람의 개입을 통해서 이루어진다
    - 접근 리스트는 17.6.2절에서 논의될 것이다

- 더욱 제한된 보호 분류에서는 보호를 정의하기 위해 단지 세 개의 필드만 필요하다
  - 각 필드는 비트들의 집합으로 구성되고, 각 비트는 접근을 허용하거나 금지한다
  - 예를 들면 UNIX 시스템은 각 3비트(rwx)인 3필드로 정의되는데
    - r : 읽기 접근
    - w : 쓰기 접근
    - x : 실행 제어
  - 각 필드는 파일 소유자, 소유자의 그룹 그리고 모든 사용자를 나타낸다
  - 이 방법에서 파일단 9비트가 보호 정보를 위해 필요하다
    - e.g, -rw-r--r--+ 1 jim staff 130 May 25 22:13 file1

#### UNIX 시스템에서 권한들

- rwx 비트들로 구성된다
- UNIX 환경에서 디렉터리 리스팅의 예

| 보호       | 파일에 대한 링크 수 | 소유자 | 그룹  | 크기(바이트 수) | 최종 변경 날짜 | 파일명   |
| ---------- | ------------------- | ------ | ----- | --------------- | -------------- | -------- |
| -rw-rw-r-- | 1                   | pbg    | staff | 31200           | Sep 3 08:30    | intro.ps |
| drwx------ | 5                   | pbg    | staff | 512             | Jul 8 09:33    | private/ |

### 13.4.3 다른 보호 방법(Other Protection Approaches)

#### 파일 접근 시 암호를 요구하는 것

- 파일 접근 암호를 알고 있는 사람으로 제한하는 데 효과적
- 그러나 몇 가지 단점이 있다
  - 파일마다 독자적인 암호를 가지면 기억해야 할 암호의 수가 너무 많아진다
  - 모든 파일에 대해 하나의 암호를 쓸 경우에는 하나만 알려지면 모든 파일 접근이 가능하여 보호가 무의미해진다

#### subdirectory를 보호하는 directory protection

- 여러 단계의 디렉터리를 가지는 구조에서는 각각의 파일의 보호 뿐만 아니라
  - subdirectory를 보호하는 directory protection기능이 있어야 한다
- 디렉토리용 연산은 일반 파일용 연산과 다르므로, directory 연산은 파일 연산과 다르게 보호되어야 한다
- 한 디렉터리 내에 파일을 생성하거나 제거하는 일을 제어하기를 원한다
- path 마다 접근 할 수 있는 사용자를 제어할 수도 있다

## 13.5 메모리 사상(매핑) 파일(Memory-Mapped Files)

- 파일을 액세스하는 또 다른 방법 : 메모리 참조 방식, `메모리 사상(memory-mapping)`
  - 디스크 입출력 대신 (10장에서 논의된 가상 메모리 기법을 사용하여) 메모리 참조방식으로 대신할 수도 있다
  - 이 방식은 현저하게 성능을 향상시킨다

### 13.5.1 기본 기법(Basic Mechanism)

- 파일의 메모리 매핑은 프로세스의 페이지 중 일부분을 디스크에 있는 파일의 블록에 매핑함으로써 이루어진다
- 메모리에 매핑된 파일에 대한 쓰기는 보조저장장치의 파일에 즉각적(동기식)으로 써지지는 않는다
  - 일반적으로 시스템은 파일을 닫을 때만 메모리 이미지의 변경사항에 따라 파일을 업데이트 한다
  - 메모리가 부족한 상황에서 시스템은 다른 용도로 메모리를 확보할 때 변경 사항을 잃어버리지 않도록 스왑공간에 즉각 반영한다
  - 파일이 닫히면 모든 메모리 사상된 데이터가 보조저장장치의 파일에 다시 쓰이고 프로세스의 가상 메모리에서 제거 된다
- 운영체제에 따라 파일 관련 시스템 콜이 표준이 되는 것도 있고 메모리 사상 파일을 표준으로 삼기도 한다

## 13.6 요약

- 파일은 운영체제에 의하여 정의되고 구현되는 추상적인 자료형이다

  - 파일은 논리 레코드의 연속으로서, 바이트, 행(길이가 고정 또는 가변) 또는 좀 더 복합적인 자료 항목들이다
  - 운영체제는 다양한 레코드형을 사용자에게 제공하거나 아니면 사용자가 프로그램상으로 정의하도록 해준다

- 운영체제의 가장 중요한 문제는 논리적인 파일을 하드 디스크나 NVM 장치 같은 실제 저장 장치에 어떻게 매핑 시키느냐이다

  - 보통 물리 레코드 크기는 논리 레코드 크기와 일치하지 않기 때문에 논리 레코드를 물리 레코드에 연관시켜야 한다
  - 이 작업은 운영체제에 의하여 제공되거나 사용자의 응용 프로그램에서 할 수 있다

- 파일 시스템 내에서 파일 구조화하는 디렉터리를 만드는 것이 유용하다

  - 다중 사용자 시스템에서 1단계 디렉터리는 모든 파일이 고유 이름을 가져야 하므로 파일 명칭 부여 문제를 유발한다
  - 2단계 디렉터리는 이름으로 파일을 기록하고, 디스크 상에서 파일의 위치, 길이, 형태, 소유자, 생성 시간, 마지막 사용 시간 등과 같은 정보를 포함한다

- 2단계 디렉터리를 일반화하여 확장하면 트리 구조 디렉터리가 되며, 트리 구조 디렉터리는 사용자가 자신의 파일을 구성하기 위하여 서브디렉터리를 구성할 수 있게 해준다

  - 비순환 그래프 디렉터리 구조는 서브디렉터리와 파일의 공유를 허용하지만, 탐색과 삭제가 복잡하다
  - 일반적인 그래프 디렉터리 구조는 디렉터리와 파일의 공유에 완전한 융통성을 주는 대신 사용되지 않는 디스크 공간을 회수하기 위해 쓰레기 수집(garbage collection)이 필요하다

- 원격 파일 시스템은 안정성, 성능 및 보안에 해결할 과제를 제시한다

  - 분산 정보 시스템은 클라이언트와 서버가 상태 정보를 공유하여 사용 및 액세스를 관리할 수 있도록 사용자, 호스트 및 액세스 정보를 유지 관리한다

- 파일은 대부분의 컴퓨터 시스템에서 주요 정보 저장 수단이기 때문에 다중 사용자 시스템에서 파일 보호가 필요하다
  - 파일에 대한 접근은 읽기, 쓰기 실행, 덧붙이기, 디렉터리 열거 등의 접근 유형에 따라 별도로 통제되어야 한다
  - 파일의 보호는 암호, 접근 리스트 또는 특별한 임의의 기법으로 구현될 수 있다
