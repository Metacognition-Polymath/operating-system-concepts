# 8. 교착 상태(Deadlocks)

- 교착 상태 : 대기 중인 스레드들이 결코 다시는 그 상태를 변경시킬 수 없으면 발생하는 상태

- 교착 상태의 좋은 예
  - 두 기차가 교차로에서 서로 접근할 때는 둘다 완전히 정지해야 하며,
  - 상대방이 없어지지 않는 한 누구도 다시 출발할 수 없다
- 이 번 장에서 운영체제 개발자 뿐 아니라 응용 프로그램 개발자들도 교착 상태를 예방항거나 다루기 위해 사용할 수 있는 방법들을 논의한다
- 몇몇 응용 프로그램은 교착 상태가 일어날 가능성이 있는 프로그램을 구별할 수 있겠지만
  - 보통 `운영체제`들은 `교착 상태 예방 기능을 제공하지 않는다`
    - 따라서 `교착 상태가 없는 프로그램을 설계`하는 것은 전적으로 `프로그래머의 책임`으로 남는다
- 다중 코어 시스템에서 병행 및 병렬 처리 증대에 대한 요구가 계속됨에 따라 교착 상태 문제 뿐만 아니라 기타 라이브니스 장애 문제가 점점 어려워지고 있다

#### 이 장의 목표

- Mutex 락을 사용할 때 어떻게 교착 상태가 발생할 수 있는지 보여준다(`Mutex락의 교착 상태 발생 예시`)
- `교착 상태를 특징 짓는 4가지` 필수 조건을 정의한다
- 자원 할당 그래프에서 교착 상태 상황을 식별한다
- 교착 상태 `예방`을 위한 `4가지 방법`을 평가한다
- 교착 상태 `회피`를 위해 `은행의 알고리즘`을 적용한다
- 교착 상태 `감지 알고리즘`을 적용한다
- 교착 상태에서 `복구하기 위한 접근법`을 평가한다

## 8.1 시스템 모델(System Model)

- `시스템`은 경쟁하는 스레드들 사이에 분배되어야 할 `유한한 자원들`로 구성된다
- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스(instance)들로 구성된다
- 자원 유형 예
  - CPU 주기
  - 파일
  - 입/출력 장치
- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다
  - 마찬 가지로 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다
  - 한 스레드가 어떤 자원 유형의 한 인스턴스를 요청하면, 동일 유형 자원의 임의의 인스턴스를 할당함으로써 요청이 충족된다
  - 각 인스턴스들은 락으로 보호된다
- 스레드는 자원을 사용 전에 반드시 요청(request)하고, 사용후에는 반드시 해제(release)해야 한다
- 프로세스의 자원 사용 순서

  - 자원 요청
  - 자원 사용
  - 자원 해제(방출, release)

- 장치별 자원 요청 및 방출 메서드

  - 장치 : request(), release()
  - 파일 : open(), close()
  - 메모리 시스템 콜 : allocate(), free()
  - 세마포 : wait(), signal()
  - mutex : acquire(), release()

- 한 스레드 집합 내의 `모든 스레드`가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 `이벤트를 기다린다`면, 그 스레드 집합은 `교착상태`에 있다
  - e.g. 식사하는 철학자 문제
- 6장의 락킹 도구들은 경쟁 조건을 회피하도록 설계되었다
  - 그러나 이러한 도구를 사용할 때, 주의를 기울여야 한다. 그렇지 않으면 교착상태가 발생할 수 있다 -> 8.2

## 8.2 다중 스레드 응용에서의 교착 상태(Deadlock in Multithreaded Applications)

```c
// thread_one은 이 함수를 실행한다
void *do_work_one (void *param) {
  pthread_mutex_lock(&first_mutex);
  pthread_mutex_lock(&second_mutex);
  // critical section, Do some work
  pthread_mutex_unlock(&second_mutex);
  pthread_mutex_unlock(&first_mutex);

  pthread_exit(0);
}

// thread_two는 이 함수를 실행한다
void *do_work_two (void *param) {
  pthread_mutex_lock(&second_mutex);
  pthread_mutex_lock(&first_mutex);
  // critical section, Do some work
  pthread_mutex_unlock(&first_mutex);
  pthread_mutex_unlock(&second_mutex);

  pthread_exit(0);
}
```

- 두 스레드가 동시에 실행되면, `thread_one`은 `first_mutex`를 잡고 `thread_two`는 `second_mutex`를 잡을 수 있다
  - 이때, `thread_one`은 `second_mutex`를 잡으려고 기다리고, `thread_two`는 `first_mutex`를 잡으려고 기다린다
  - 이러한 상황에서는 두 스레드 모두 무한정 기다리게 된다
- 이러한 상황을 `교착 상태`라고 한다

### 8.2.1 라이브락(Livelock)

- 라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다
- 교착상태와 유사하다
- 교착상태와 라이브락 둘 다 두 개이 이상의 스레드가 진행되는 것을 방해하지만 진행할 수 없는 이유가 서로 다르다
  - 교착 상태 발생 이유 : 어떤 스레드 집합의 모든 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄
  - 라이브락 발생 이유 : 스레드가 실패한 행동을 계속해서 시도할 때 발생
    - 라이브락 예시 : 복도에서 두 사람이 서로 마주쳐서 서로 피해주려는데 같은 방향으로 피해서 여전히 서로의 진행을 방해하는 상황
      - 네트워크에서 충돌이 발생할 때 발생할 수 있음
    - 라이브락 원인 : 실패한 작업을 동시에 재시도 할 때
    - 라이브락 해결 : 실패한 행동을 재시도 하는 시간을 무작위로 정한다
      - 네트워크에서 충돌이 발생할 때 Ethernet 네트워크가 취하는 접근법

## 8.3 교착 상태 특성(Deadlock Characterization)

- 교착 상태를 특정 짓는 조건을 자세히 살펴본다
- 교착 상태는 네 가지 조건이 모두 충족되어야 발생한다
  - 상호 배제(Mutual Exclusion)
  - 점유 대기(Hold and Wait)
  - 비선점(No Preemption)
  - 순환 대기(Circular Wait)

### 8.3.1 필요조건들(Necessary Conditions)

#### 1. 상호 배제(Mutual Exclusion)

- 한 번에 한 스레드만이 그 자원을 사용할 수 있다

#### 2. 점유하며 대기(hold-and-wait)

- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 `점유된 자원`을 추가로 얻기 위해 반드시 `대기`해야 한다

#### 3. 비선점(no preemption)

- 자원들을 선점할 수 없어야 한다
- 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다

#### 4. 순환 대기(circular wait)

- 각 스레드는 순환적으로 다음 스레드가 점유하고 있는 자원을 요구해야 한다
- e.g.
  - thread1 -> thread2 -> thread3 -> thread1

### 8.3.2 자원 할당 그래프(Resource Allocation Graph)

- 시스템 자원 할당 그래프(방향 그래프)로 교착 상태를 더욱 정확하게 기술할 수 있다
- 정점(V = vertex)는 프로세스를 나타내고, 간선(E = edge)는 자원을 나타낸다
  - T -> R : 자원 요청
  - R -> T : 자원 할당
- 자원할당 그래프에 사이클이 없다면, 시스템은 교착상태가 아니다
- 사이클이 있다면 시스템은 교착상태 일 수도 있고 아닐 수도 있다

## 8.4 교착 상태 처리 방법(Methods for Handling Deadlocks)

- 교착 상태 문제를 처리하는 데 세 가지 방법이 있다

  - (1) 문제를 `무시`하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다
  - (2) 시스템이 `결코 교착 상태가 되지 않도록 보장`하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다
  - (3) 시스템이 교착 상태가 되도록 `허용`한 다음에 (감지 후) `복구` 시키는 방법이 있다

- 첫 번째 해결안(교착상태 무시)이 Linux와 Windows를 포함해 대부분의 운영체제가 사용하는 방법이다
  - 이 경우 교착 상태를 처리하는 프로그램을 작성하는 것은 응용 개발자의 몫
    - 보통 두 번째 해결안을 사용한다(결코 교착 상태가 되지 않도록 보장)
- 데이터베이스와 같은 일부 시스템은 세 번째 해결안을 채택하여 교착 상태의 발생을 허용하고 복구 작업을 수행한다
- 몇몇 연구자들은 이 기본적인 방법 중 어느 것도 단독으로는 운영체제에서의 자원 할당 문제 전 범위를 처리하는 데에는 적절하지 못하다고 주장
- 교착 상태가 발생하지 않도록 예방, 혹은 회피 기법의 하나를 사용할 수 있다
- 교착 상태 `예방`은 8.3.1절에서 언급한 `필요조건 중 적어도 하나가 성립하지 않도록 보장`하는 일련의 방법이다 => 8.5절에서 논의
- 교착 상태 `회피`는 스레드가 `사용할 자원에 대한 부가적인 정보`를 미리 제공할 것을 요구 한다 => 8.6절
  - 이 사용할 자원에 대한 정보를 가지고 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다
- 교착 상태가 언제 발생했는지 상태를 조사하는 알고리즘, 교착 상태로 부터 복구하기 위한 알고리즘 => 8.7, 8.8절
- 교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 든다
  - 많은 시스템에서 교착 상태는 드물게(예를 들면 한달에 한번) 발생하기 때문에 다른 처리 방법을 사용하는 부가적인 비용은 그만한 가치가 없을 수 있다
- 라이브락과 같은 다른 라이브니스 조건으로부터 복구하는 데 사용되는 방법을 교착 상태로 부터 복구하는 데 사용할 수 있다
- 어떤 상황에서는 시스템이 라이브니스 장애로 고생하고 있지만 교착 상태에 있지 않을 수 있다
  - 이러한 상황의 예로 최고 우선순위로 수행되고 제어가 결코 운영체제로 돌아가지 않는 실시간 스레드(혹은 비선점 스케줄러에서 수행되는 임의의 스레드)의 경우를 고려할 수 있다
  - 따라서 시스템은 교착 상태가 아닌 상황을 위해 수작업 복구 방법을 반드시 가지고 있어야 하며, 단순히 동일한 방법을 교착 상태 회복을 위해서 사용할 수도 있다

## 8.5 교착 상태 예방(Deadlock Prevention)

- 4가지 필요 조건 중 하나가 성립하지 않도록 보장함으로써 교착 상태를 예방할 수 있다

### 8.5.1 교착 상태 필요 조건 1: 상호 배제(Mutual Exclusion) -> 예방 : 불가능

- 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능하다
- 어떤 자원들은 근본적으로 공유가 불가능하기 때문이다

### 8.5.2 교착 상태 필요 조건 2: 점유 대기(Hold and Wait) -> 예방 : 불가능

- 시스템에서 점유하며 대기 조건이 발생하지 않도록 하려면 스레드가 자원을 요청할 때 마다 다른 자원을 보유하지 않도록 보장해야 한다

- 적용안(프로토콜)1
  - 이 조건을 위해선 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다
  - 이것은 자원 요청의 동적 특성을 가진 대부분의 응용 프로그램에는 실용적이지 않다
- 적용안(프로토콜)2

  - 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다

- 위 두 적용안은 주요 단점이 있다
  - 자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 자원 이용률이 낮을 수 있다
    - 짧은 기간에만 필요한 자원도 계속 가지고 있어야 함
  - 기아(starvation)가 발생할 수 있다
    - 인기 있는 여러 개의 자원이 필요한 스레드는 필요한 자원 중 적어도 하나는 항상 다른 스레드에 할당되므로 무한정 대기해야 할 수 있다

### 8.5.3 교착 상태 필요 조건 3: 비선점(No Preemption) -> 적용이 한정적이며, 일반적으로 적용 불가능

- 비선점은 이미 할당된 자원이 선점되지 않는 다는 것이다

#### 비선점을 막기 위한 프로토콜(적용안)

- 적용안 1
  - 스레드가 대기해야 하면, 점유하고 있는 모든 자원이 선점된다
- 적용안 2
  - 사용가능 여부 검사
    - 사용 가능 -> 할당
    - 사용 불가능
      - 추가의 자원을 위해 대기하고 있는 어떤 다른 스레드에 할당되어 있는지를 검사
        - 그렇다면 선점 후 요청하는 스레드에게 할당
        - 아니라면 요청 스레드는 대기
  - 이 프로토콜(적용안2)은 CPU 레지스터나 데이터베이스 트랜잭션처럼 그 상태가 쉽게 저장되고 복원될 수 있는 자원에 종종 적용된다
  - 이 프로토콜(적용안2)은 mutex락과 세마포 같은 자원에는 적용 될 수 없다
  - 교착 상태가 가장 흔하게 발생하는 자원 유형인 mutex락과 세마포 같은 자원에는 일반적으로 적용할 수 없다

### 8.5.4 순환 대기(Circular Wait) -> 예방 : 가능

- 상호배제, 점유하며 대기, 비선점 조건들을 예방하는 것은 일반적으로 실용적이지 않다
- 하지만 순환 대기 조건은 실용적인 해결책을 제공할 수 있다
- 순환 대기 조건이 성립되지 않도록 하는 방법 1
  - 모든 자원 유형에 순서를 부여,
  - 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것

## 8.6 교착 상태 회피(Deadlock Avoidance)

- 교착상태 예방할 때 문제
  - 자원 이용률이 낮아짐
  - 시스템 총처리율(throughtput)이 감소
- 교착상태를 회피하는 대안으로 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이 있다
- 가장 단순하고 제일 유용한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다

  - 각 스레드가 요청할 각 유형의 자원의 최대수 정보를 파악할 수 있다면, 교착상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다
    - 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수 그리고 스레드들의 최대 요구 수에 의해 정의된다

- 두 개의 교착 상태 회피 알고리즘
  - 8.6.2 자원 할당 그래프 알고리즘(Resource Allocation Graph Algorithm)
  - 8.6.3 은행원 알고리즘(Banker's Algorithm)

### 8.6.1 안전 상태(Safe State)

- 시스템 상태가 `안전(safe)`하다는 말은 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을(최대 요구 수를 요구하더라도) `교착 상태를 야기시키지 않고` `차례로` `모두 할당해 줄 수 있다`는 것을 뜻한다
- 즉, 시스템이 `안전 순서(safe sequence)`를 찾을 수 있다면 시스템은 안전하다고 말한다
- 시스템이 불안전하다는 말은 반드시 교착 상태로 간다는 것이 아니라 교착 상태로 가게 될 수도 있다는 뜻이다
- 안전상태에 머무는 운영체제는 불안전 상태, 교착 상태 모두를 예방할 수 있다
- 그러나 일단 불안전 상태에 들어가게 되면 운영체제는 교착 상태가 일어날 수도 있는 자원요청을 막을 수는 없다
- 스레드들의 행동 양태가 불안전 상태를 제어한다
- 예를 들어, 시스템에 12개의 자원이 있고 T0, T1, T2 세 개의 프로세스가 있다고 하자
  - T0가 10개의 테이프가 필요하고
  - T1이 4개
  - T2가 9개의 자원을 필요로 할 수 있다
  - 임의의 시점 t0에서 T0가 5개, T1이 2개, T2가 2개의 자원을 보유중이다
    - 이 시점에서 3개의 자원이 시스템 보유분으로 남았다
  - t0시점에서 시스템의 상태는 안전하다
    - T1, T0, T2 순서로 모든 프로세스를 처리할 수 있다
- 안전 상태에서 불안 전 상태로 전이할 수 있다
  - 위 예시를 이어서 t1에서 T2가 자원 한 개를 추가로 요청하여 그것을 주었다고 가정해보자
  - 이제 시스템에는 2개의 자원만 남았고 T0, T1, T2 어느 프로세스도 처리할 수 없는 상태가 되었다
  - 이 상태는 불안전 상태이다
  - 그러므로 T2가 자원한 한 개를 요청하는 것을 들어준다면 교착 상태가 발생한다
- 회피 알고리즘
  - 기본 원칙 : 시스템의 상태가 항상 안전 상태를 떠나지 않도록 고수하는 것
  - 요청한 자원을 즉시 승낙해주는 경우는 시스템의 상태가 안전 상태에서 안전 상태로 옮길 때 뿐이다
  - 이러한 방식에서는 스레드가 요청한 자원보다 많은 양을 시스템이 보유하고 있다고 하더라도 그 프로세스를 기다리게 하는 상황이 벌어질 수 있다
  - 자원 이용률은 회피를 안 쓸 때 비해서 낮아질 수 밖에 없다

### 8.6.2 자원 할당 그래프 알고리즘(Resource allocation graph algorithm)

- 자원할당 그래프에 예약 간선이라는 새로운 타입의 간선을 도입한다
- 자원 할당 그래프 간선 종류
  - 요청 간선(Request Edge)
    - 프로세스가 자원을 요청할 때 사용
  - 할당 간선(Allocation Edge)
    - 프로세스가 자원을 할당받을 때 사용
  - 예약 간선(Reservation Edge)
    - 프로세스가 자원을 요청할 것이라는 의미
- 예약 간선은 요청 간선과 유사하지만 점선(dashed line)으로 표시된다
  - 프로세스가 자원을 예약간선을 통해 요청하게 되면 요청간선으로 변환된다
  - 그리고 해당 프로세스가 자원을 방출하면 다시 예약간선으로 변환된다
- 자원 할당 그래프 알고리즘은 `사이클이 생기지 않게 하는 것`이다
  - 사이클은 불안전한 상태에 있음을 의미한다

### 8.6.3 은행원 알고리즘(Banker's algorithm)

- `자원할당 그래프 알고리즘`은 `종류마다 자원이 여러 개`씩 있게 되면 `사용할 수 없다`
- 자원할당 그래프 알고리즘 보다 효율성이 다소 떨어지지만 `은행원 알고리즘`은 `종류마다 자원이 여러 개`씩 있어도 `사용할 수 있다`
- 은행원 알고리즘이란 이름이 붙여진 이유 : 이 알고리즘을 은행에 적용하면 고객들이 현금을 찾으러 와도 일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있게 되기 때문이다
- 이 시스템에서 `스레드가 시작할 때` 스레드가 `가지고 있어야 할 자원의 최대 개수`를 `자원 종류마다 미리 신고`하여야 한다
  - 이 숫자가 자원의 총 보유수를 넘어서면 안된다
- 스레드가 자원 요청 -> 시스템은 안전 상태에 머무르게 되는지 판단

  - 계속 안전하다고 판단 : 요청을 들어줌
  - 안전하지 않다고 판단 : 허락이 안된채 다른 스레드가 끝날 때 까지 기다리게 된다

- 은행원 알고리즘을 구현하려면 몇 가지의 자료 구조가 필요하다
  - 이 자료구조들은 시스템이 자원을 할당하고 있는 상태를 나타내게 된다
  - n : 스레드 수
  - m : 자원의 종류
  - Available : 각 종류별로 가용한 자원의 개수를 나타내는 벡터
    - 크기가 m
    - `Available[j]` = k
      - 현재 Rj(자원 종류가 j인 자원)를 k개 사용할 수 있다는 뜻
  - Max : `각 스레드가 최대로 필요로 하는 자원의 개수`를 나타내는 `행렬`(크기가 n x m)
    - `Max[i][j]` = k
      - 스레드 Ti가 Rj를 최대 k개 까지 요청할 수 있다는 뜻
  - Allocation : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬(크기가 n x m)
    - `Allocation[i][j]` = k
      - 스레드 Ti가 현재 Rj를 k개 사용하고 있다는 뜻
  - Need : 각 스레드가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬(크기가 n x m)
    - `Need[i][j]` = k
      - 스레드 Ti가 향후 Rj를 k개까지 더 요청할 수 있다는 뜻
    - `Need[i][j] = Max[i][j] - Allocation[i][j]` 관계가 있다
- 은행원 알고리즘 설명을 위한 몇 가지 표기법 정리
  - 크기가 n인 벡터 X, Y가 있을 때, `X <= Y`라고 표기하면 모든 i값에(i=1,2,...,n) 대해 `X[i] <= Y[i]` 관계가 있음을 뜻한다
  - Allocation과 Need 행렬의 각 행을 벡터로 취급하고 이들 행 벡터는 각각 Allocation[i], Need[i]와 같이 표기한다
    - Allocation[i] : 스레드 Ti에 할당된 자원들
    - Need[i] : 스레드 Ti가 향후 요청할 수 있는 자원들

#### 8.6.3.1 안전성 알고리즘 (Safety Algorithm)

- 시스템이 안전한지 아닌지를 알아낼 수 있는 알고리즘
- (1) Work와 Finish는 크기가 m, n인 벡터이다.
  - Work = Available로 초기값을 준다
  - i = 0, 1, 2, ... , n-1에 대해 Finish[i] = false로 초기값을 준다
- (2) 아래 두 조건을 만족시키는 i 값을 찾는다
  - Finish[i] = false
  - Need[i] <= Work
  - 이러한 i 값을 찾을 수 없다면 step (4)로 이동
- (3) Work = Work + Allocation[i]로 갱신하고 Finish[i] = true로 갱신한다
  - 이제 스레드 Ti는 자원을 모두 사용하고 종료되었다는 뜻
  - 이제 다시 step (2)로 돌아간다
- (4) 만약 모든 i에 대해 Finish[i] = true라면 시스템은 안전한 상태이다

- 이 알고리즘으로 안전 여부를 알아내는 데에는 m \* n^2 개의 연산이 필요하다

#### 8.6.3.2 자원 요청 알고리즘(Resource Request Algorithm)

- 자원 요청이 안전하게 들얼 줄 수 있는지를 검사하는 알고리즘을 설명한다

  - Request_i는 스레드 Ti의 요청 벡터라고 하자
  - Request_i[j] == k 라면 Ti(i번째 스레드)가 Rj(j번째 자원)를 k개 까지 요청하고 있음을 뜻한다

- Ti가 자원을 요청하게 되면 아래와 같은 조치가 취해진다
  - (1) 만일 Request_i <= Need_i 이면 (2)번으로 간다
    - 아니면 시스템에 있는 개수보다 더 많이 요청했으므로 오류로 처리한다
  - (2) 만일 Request_i <= Available 이면 (3)번으로 간다
    - 아니면 자원이 부족하므로 Ti는 자원을 기다려야 한다
  - (3) 마치 시스템이 Ti에게 자원을 할당해준 것 처럼 시스템 상태 정보를 아래 처럼 바꾸어본다
    - Available(여유 자원 수) = Available - Request_i
    - Allocation_i(Ti에 할당한 자원 수) = Allocation_i + Request_i
    - Need_i(Ti가 향후 요청할 수 있는 자원 수) = Need_i - Request_i
    - 만일 이렇게 바뀐 상태가 안전하다면 Ti에 여기에 반영된 정보대로 자원을 할당해준다
    - 그러나 새로운 상태가 불안전하다면, 위의 자원 할당 상태는 원상태로 복원되고 Ti는 Request_i가 만족하기까지 기다려야 한다

#### 8.6.3.3 예시(An Illustrative Example)

- 이 알고리즘을 예를 들어 설명하기 위해 시스템에는 다섯 개의 프로세스 T0부터 T4까지 있고,
  - A, B, C 세 종류의 자원이 있다고 가정한다
  - 시스템에는 A자원이 10개, B자원이 5개, C자원이 7개가 있다
  - 다음 스냅샷은 시스템의 현재 상태를 나타낸다고 가정하자

|  -  | Allocation |  Max  | Available |
| :-: | :--------: | :---: | :-------: |
|  -  |   A B C    | A B C |   A B C   |
| T0  |   0 1 0    | 7 5 3 |   3 3 2   |
| T1  |   2 0 0    | 3 2 2 |           |
| T2  |   3 0 2    | 9 0 2 |           |
| T3  |   2 1 1    | 2 2 2 |           |
| T4  |   0 0 2    | 4 3 3 |           |

- Need 행렬의 값은 (Max - Allocation)으로 계산된다

|  -  | Need  |
| :-: | :---: |
|  -  | A B C |
| T0  | 7 4 3 |
| T1  | 1 2 2 |
| T2  | 6 0 0 |
| T3  | 0 1 1 |
| T4  | 4 3 1 |

- 이 시스템은 안전하다. T1, T3, T4, T2, T0 순서로 실행되면 안전성 기준을 만족시키기 때문이다
  - 시스템 전체의 안전성을 확인하기 위해선 m \* n^2 개의 연산이 필요하다
- T1이 Request_1 = (1, 0, 2)를 요청하면, 변화 후에도 안전 상태인지 검사 후 안전하다면 요청을 들어줄 것이다
- 그 상태에서 T4가 (3, 3, 0)을 요청하면 시스템은 불안전 상태가 되므로 요청을 즉시 들어줄 수 없다

## 8.7 교착 상태 탐지(Deadlock Detection)

- 만일 시스템이 교착 상태 예방이나 교착 상태 방지 알고리즘을 사용하지 않는다면, 교착 상태가 발생할 수 있다
- 이러한 환경에서는 시스템의 다음 알고리즘들을 반드시 지원해야 한다
  - 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘
  - 교착 상태로부터 회복하는 알고리즘
- 자원의 종류(유형)이 (인스턴스가)하나인 경우와 (인스턴스)다수인 경우에 대해 논의해보자
- 탐지와 회복 방법에서 필요한 것
  - 필요한 정보를 유지하고 탐지 알고리즘을 실행 시키기 위한 `실행 시간 비용`
  - 교착 상태로부터 회복할 때 내재하는 가능한 `손실`을 포함하는 `오버헤드`

### 8.7.1 각 자원 유형이 한 개씩 있는 경우(Single Instance of Each Resource Type)

- 모든 자원이 한 개의 인스턴스만 있다면, 대기 그래프(wait for graph)라고 하는, 자원 할당 그래프의 변형을 사용해 교착 상태 탐지 알고리즘을 정의할 수 있다
- 우리는 자원 할당 그래프로부터 자원 유형의 노드를 제거하고 적절한 간선들을 결합함으로써 대기 그래프를 얻을 수 있다
- 교착 상태를 탐지하기 위해 시스템은 대기 그래프를 유지할 필요가 있고,
  - 주기적으로 그래프에서 사이클을 탐지하는 알고리즘을 호출한다
  - 그래프에서 사이클을 탐지하는 알고리즘은 O(n^2)의 연산을 요구한다

### 8.7.2 각 유형의 자원을 여러 개 가진 경우(Several Instances of a Resource Type)

- 8.7.1의 대기 그래프는 자원이 종류마다 여러 개씩 존재하는 상황에서는 사용할 수 없다
- 아래 기법으로 교착 상태를 탐지 할 수 있는데, 이 알고리즘은 은행원 알고리즘과 마찬가지로 시시각각 그 내용이 달라지는 자료구조를 사용한다
- Available : 각 종류의 자원이 현재 몇 개가 가용한지를 나타내는 벡터로, 크기가 m이다
- Allocation : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬로 크기가 n \* m 이다
- Request : 각 스레드가 현재 요청 중인 자원의 개수를 나타내는 행렬로 크기가 n \* m 이다

  - `Request[i][j]==k` 라면 현재 Ti가 Rj를 k개 요청 중임을 뜻한다

- (1) Work와 Finish는 크기가 m과 n인 벡터이다
  - Work = Available로 초기값을 준다
  - i = 0, 1, ..., n-1에 대해서 Allocation != 0이면 Finish[i] = false이다
  - 그렇지 않으면 Finish[i] = true이다
- (2) 아래 두 조건을 만족시키는 i값을 찾는다
  - Finish[i] == false
  - Request_i <= Work
  - 그러한 i값을 찾을 수 없다면 (4)번으로 간다
- (3) Work = Work + Allocation_i
  - Finish[i] = true
  - (2)번으로 돌아간다
- (4) 어떠한 i 값에 대해 (0 <= i < n) Finish[i] == false 이면 이 시스템은 교착 상태에 빠져 있는 것이다
  - Ti가 교착 상태에 빠져 있다는 것을 의미한다
- 이 탐지 알고리즘을 실행하는 데에는 m \* n^2개의 연산이 필요하다
- (3)에서 시스템이 Ti의 자원을 회수한 이유
  - Ti가 교착 상태에 빠져있지 않음을 Request_i <= Work 관계로 부터 알 수 있다
  - 낙관적인 관점에서 볼 때 이 프로세스가 작업을 마치기까지 더 이상의 추가적인 자원을 필요로 하지 않는다고 생각해 볼 수 있다
  - 그러면 Ti는 지금까지 가지고 있던 모든 자원을 반납하고 시스템을 떠난다고 가정한다
  - 만일 이 가정이 틀린 것이었다면 교착 상태는 다음에 발생할 것이다
  - 그러한 교착 상태는 이 탐지 알고리즘을 다음 차례에 돌릴 때 나타나게 될 것이다

#### Java Thread Dumps를 사용한 교착 상태 감지

- Java는 교착 상태 감지를 명시적으로 지원하지 않지만 스레드 덤프를 사용하여 교착 상태가 있는지 판별하기 위해 실행 중인 프로그램을 분석할 수 있다
- 스레드 덤프는 Java 응용 프로그램의 모든 스레드 상태의 스냅샷을 보여주는 유용한 디버깅 도구이다
- Java 스레드 덤프는 또한 봉쇄된 스레드가 획득하려고 기다리고 있는 락을 포함하여 락 정보를 보여준다
- 스레드 덤프가 생성되면 JVM은 대기 그래프를 검색하여 주기를 감지하고 감지된 교착 상태를 보고한다
- 실행 중인 응용 프로그램의 스레드 덤프를 생성하려면 명령 라인에서 다음을 입력하라

```
Ctrl-\(UNIX, Linux, macOS)
Ctrl-Break(Windows)
```

### 8.7.3 탐지 알고리즘 사용(Detection Algorithm Usage)

- "위에서 설명한 탐지 알고리즘은 언제 돌리는가?"에 대한 대답은 두 가지 관점에 달려있다

  - (1) 교착 상태가 얼마나 자주 일어나는가?
  - (2) 교착 상태가 일어나면 통상 몇 개의 스레드가 거기에 연루되는가?

- 교착 상태가 자주 일어난다면 탐지 알고리즘도 자주 돌려야 한다
- 교착 상태가 된 스레드로부터 자원을 회수하기까지는 그 자원들은 아무도 못 쓰는 자원으로 교착 상태 기간 내내 묶이게 되기 때문이다
- 또 시간이 더 지나면 지날수록 교착 상태에 연루되는 스레드의 수도 늘어날 수 있다
- 교착 상태가 일어나는 시점은 어떤 스레드가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다
  - 때론 이 요청이 마지막 요청일 수도 있다
- 한 극단적인 방법은 스레드의 요청이 즉시 만족하지 않을 때 마다 탐지 알고리즘을 돌리는 방법이 있다
  - 이 처럼 하면 교착 상탱체 연루된 스레드 뿐 아니라 교착 상태를 야기한 장본인 스레드도 알아낼 수 있게 된다
    - 교착 상태에 빠진 스레드들은 사이클을 구성하게 되므로 그 스레드들 모두가 교착 상태를 야기한 공범이라고 할 수 있다
- 요청으로 인한 오버헤드를 줄이는 간단한 대안은 지정된 시간 간격으로, 예를 들어 한 시간에 한번 또는 CPU 이용률이 40% 이하로 떨어질 때 탐지 알고리즘을 호출하는 것이다
  - 교착 상태는 궁극적으로 시스템의 처리율을 감소시키고 CPU의 이용률을 떨어뜨리게 된다
  - 이 경우 자원 그래프가 여러 사이클을 포함할 수 있기 때문에 교착 상태를 야기한 장본인이 어떤 스레드인지 알아내기가 어렵다

## 8.8 교착 상태로부터 회복(Recovery from Deadlock)

- 탐지 알고리즘이 교착 상태가 존재한다고 결정하면, 여러 대안의 처리 방법이 있다
- 한 가지 방법은 교착 상태가 발생한 것을 운영자(operator)에게 통지해, 운영자가 수작업으로 처리하게 하는 것이다
- 다른 방법은 시스템이 자동으로 교착 상태로부터 회복하게 하는 것이다
- 교착 상태를 깨뜨리는 데는 두 가지 방법이 있다
  - 방법1. 순환 대기를 깨뜨리기 위해 단순히 한 개 이상의 스레드를 중지(abort) 시키는 것이다
  - 방법2. 교착 상태에 있는 하나 이상의 스레드들로부터 자원을 섬점(preempt)하는 것이다

### 8.8.1 프로세스와 스레드의 종료(Process and Thread Termination)

- 프로세스 또는 스레드를 중지(abort) 시킴으로써 교착 상태를 제거하기 위해 우리는 아래의 두 방법의 하나를 사용한다

  - 두 방법 모두, 종료된 프로세스에게 할당되었던 모든 자원을 시스템이 회수한다

- 방법1) 교착 상태 프로세스를 모두 중지
  - 이 방식은 확실하게 교착 상태의 사이클을 깨뜨리지만, 그 비용이 크다
  - 왜냐하면, 이들 프로세스가 오랫동안 연산했을 가능성이 있으며, 이들 부분 계산의 결과들을 반드시 폐기해야 하며, 아마도 후에 다시 계산해야 하기 때문이다
- 방법2) 교착 상태가 제거될 때 까지 한 프로세스씩 중지

  - 이 방법은 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해 프로세스들이 아직도 교착 상태에 있는지 확인해야 하므로 상당한 오버헤드를 유발한다

- 프로세스를 중지시키기는 쉽지 않다. 만약 프로세스가 파일을 갱신하는 도중이었다면, 그 중간에 종료시킬 경우 그 파일은 부저어확한 상태가 된다
- 부분 종료 방식을 적용할 때에도 프로세스를 선택할지 결정하는 데는 다음과 같은 많은 요인이 있다
  - 1. 프로세스의 우선순위가 무엇인지
  - 2. 지금까지 프로세스가 수행된 시간과 지정된 일을 종료하는 데 더 필요한 시간
  - 3. 프로세스가 사용한 자원 유형과 수(예를 들어, 자원들을 선점하기가 단순한지 여부)
  - 4. 프로세스가 종료하기 위해 더 필요한 자원의 수
  - 5. 얼마나 많은 수의 프로세스가 종료되어야 하는지

### 8.8.2 자원 섬점(Preemption)

- 자원 선점으로 교착상태를 제거하려면 교착 상태가 깨어질 때 까지 프로세스로부터 자원을 계속 선점해 이들을 다른 프로세스에게 할당해야 한다
- 만일 교착 사애를 해결하기 위해 선점이 필요하다면, 다음의 세 가지 사항들을 고려해야 한다
  - 1. 희생자 선택(selection of a victim)
  - 2. 후퇴(rollback)
    - 프로세스로부터 자원을 선점하려면, 그 프로세스를 롤백하고 그 상태로부터 다시 시작해야 한다
  - 3. 기아 상태(starvation)
    - 자원들이 동일한 프로세스로부터 항상 선점되지 않는 다는 것을 어떻게 보장하는가?

## 8.9 요약

- 집합의 모든 프로세스가 같은 집합의 다른 프로세스에서만 발생할 수 있는 이벤트를 기다리는 경우 프로세스 집합에서 교착 상태가 발생한다
- 교착 상태에 필요한 네 가지 조건이 있다
  - 상호 배제(Mutual Exclusion)
  - 점유 대기(Hold and Wait)
  - 비선점(No Preemption)
  - 순환 대기(Circular Wait)
  - 교착 상태는 네 가지 조건이 모두 존재할 때만 가능하다
- 교착 상태는 자원 할당 그래프를 사용하여 모델링 할 수 있다
  - 여기서 사이클이 존재한다면 교착 상태가 있다는 것을 의미한다
- 교착 상태에 필요한 4가지 조건 중 하나가 발생하지 않도록 하여 교착 상태를 예방할 수 있다
  - 필요한 네 가지 조건 중 순환 대기를 제거하는 것이 유일한 현실적인 접근 방식이다
- 은행원 알고리즘을 사용하여 교착 상태를 회피할 수 있다
  - 이 알고리즘은 시스템을 교착 상태가 발생할 가능성이 있는 불안전 상태로 이끌 수 있는 자원 요청은 허가하지 않는다
- 교착 상태 감지 알고리즘은 실행 중인 시스템의 프로세스 및 자원을 평가하여 일련의 프로세스가 교착 상태에 있는지 아닌지 결정한다
- 교착 상태가 발생하면 시스템은 순환 대기 중인 프로세스 중 하나를 중단하거나 교착 상태의 프로세스에 지정된 자원을 선점하여 교착 상태에서 복구를 시도할 수 있다
