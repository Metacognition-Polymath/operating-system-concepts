# 8. 교착 상태(Deadlocks)

- 교착 상태 : 대기 중인 스레드들이 결코 다시는 그 상태를 변경시킬 수 없으면 발생하는 상태

- 교착 상태의 좋은 예
  - 두 기차가 교차로에서 서로 접근할 때는 둘다 완전히 정지해야 하며,
  - 상대방이 없어지지 않는 한 누구도 다시 출발할 수 없다
- 이 번 장에서 운영체제 개발자 뿐 아니라 응용 프로그램 개발자들도 교착 상태를 예방항거나 다루기 위해 사용할 수 있는 방법들을 논의한다
- 몇몇 응용 프로그램은 교착 상태가 일어날 가능성이 있는 프로그램을 구별할 수 있겠지만
  - 보통 `운영체제`들은 `교착 상태 예방 기능을 제공하지 않는다`
    - 따라서 `교착 상태가 없는 프로그램을 설계`하는 것은 전적으로 `프로그래머의 책임`으로 남는다
- 다중 코어 시스템에서 병행 및 병렬 처리 증대에 대한 요구가 계속됨에 따라 교착 상태 문제 뿐만 아니라 기타 라이브니스 장애 문제가 점점 어려워지고 있다

#### 이 장의 목표

- Mutex 락을 사용할 때 어떻게 교착 상태가 발생할 수 있는지 보여준다(`Mutex락의 교착 상태 발생 예시`)
- `교착 상태를 특징 짓는 4가지` 필수 조건을 정의한다
- 자원 할당 그래프에서 교착 상태 상황을 식별한다
- 교착 상태 `예방`을 위한 `4가지 방법`을 평가한다
- 교착 상태 `회피`를 위해 `은행의 알고리즘`을 적용한다
- 교착 상태 `감지 알고리즘`을 적용한다
- 교착 상태에서 `복구하기 위한 접근법`을 평가한다

## 8.1 시스템 모델(System Model)

- `시스템`은 경쟁하는 스레드들 사이에 분배되어야 할 `유한한 자원들`로 구성된다
- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스(instance)들로 구성된다
- 자원 유형 예
  - CPU 주기
  - 파일
  - 입/출력 장치
- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다
  - 마찬 가지로 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다
  - 한 스레드가 어떤 자원 유형의 한 인스턴스를 요청하면, 동일 유형 자원의 임의의 인스턴스를 할당함으로써 요청이 충족된다
  - 각 인스턴스들은 락으로 보호된다
- 스레드는 자원을 사용 전에 반드시 요청(request)하고, 사용후에는 반드시 해제(release)해야 한다
- 프로세스의 자원 사용 순서

  - 자원 요청
  - 자원 사용
  - 자원 해제(방출, release)

- 장치별 자원 요청 및 방출 메서드

  - 장치 : request(), release()
  - 파일 : open(), close()
  - 메모리 시스템 콜 : allocate(), free()
  - 세마포 : wait(), signal()
  - mutex : acquire(), release()

- 한 스레드 집합 내의 `모든 스레드`가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 `이벤트를 기다린다`면, 그 스레드 집합은 `교착상태`에 있다
  - e.g. 식사하는 철학자 문제
- 6장의 락킹 도구들은 경쟁 조건을 회피하도록 설계되었다
  - 그러나 이러한 도구를 사용할 때, 주의를 기울여야 한다. 그렇지 않으면 교착상태가 발생할 수 있다 -> 8.2

## 8.2 다중 스레드 응용에서의 교착 상태(Deadlock in Multithreaded Applications)

```c
// thread_one은 이 함수를 실행한다
void *do_work_one (void *param) {
  pthread_mutex_lock(&first_mutex);
  pthread_mutex_lock(&second_mutex);
  // critical section, Do some work
  pthread_mutex_unlock(&second_mutex);
  pthread_mutex_unlock(&first_mutex);

  pthread_exit(0);
}

// thread_two는 이 함수를 실행한다
void *do_work_two (void *param) {
  pthread_mutex_lock(&second_mutex);
  pthread_mutex_lock(&first_mutex);
  // critical section, Do some work
  pthread_mutex_unlock(&first_mutex);
  pthread_mutex_unlock(&second_mutex);

  pthread_exit(0);
}
```

- 두 스레드가 동시에 실행되면, `thread_one`은 `first_mutex`를 잡고 `thread_two`는 `second_mutex`를 잡을 수 있다
  - 이때, `thread_one`은 `second_mutex`를 잡으려고 기다리고, `thread_two`는 `first_mutex`를 잡으려고 기다린다
  - 이러한 상황에서는 두 스레드 모두 무한정 기다리게 된다
- 이러한 상황을 `교착 상태`라고 한다

### 8.2.1 라이브락(Livelock)

- 라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다
- 교착상태와 유사하다
- 교착상태와 라이브락 둘 다 두 개이 이상의 스레드가 진행되는 것을 방해하지만 진행할 수 없는 이유가 서로 다르다
  - 교착 상태 발생 이유 : 어떤 스레드 집합의 모든 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄
  - 라이브락 발생 이유 : 스레드가 실패한 행동을 계속해서 시도할 때 발생
    - 라이브락 예시 : 복도에서 두 사람이 서로 마주쳐서 서로 피해주려는데 같은 방향으로 피해서 여전히 서로의 진행을 방해하는 상황
      - 네트워크에서 충돌이 발생할 때 발생할 수 있음
    - 라이브락 원인 : 실패한 작업을 동시에 재시도 할 때
    - 라이브락 해결 : 실패한 행동을 재시도 하는 시간을 무작위로 정한다
      - 네트워크에서 충돌이 발생할 때 Ethernet 네트워크가 취하는 접근법

## 8.3 교착 상태 특성(Deadlock Characterization)

- 교착 상태를 특정 짓는 조건을 자세히 살펴본다
- 교착 상태는 네 가지 조건이 모두 충족되어야 발생한다
  - 상호 배제(Mutual Exclusion)
  - 점유 대기(Hold and Wait)
  - 비선점(No Preemption)
  - 순환 대기(Circular Wait)

### 8.3.1 필요조건들(Necessary Conditions)

#### 1. 상호 배제(Mutual Exclusion)

- 한 번에 한 스레드만이 그 자원을 사용할 수 있다

#### 2. 점유하며 대기(hold-and-wait)

- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 `점유된 자원`을 추가로 얻기 위해 반드시 `대기`해야 한다

#### 3. 비선점(no preemption)

- 자원들을 선점할 수 없어야 한다
- 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다

#### 4. 순환 대기(circular wait)

- 각 스레드는 순환적으로 다음 스레드가 점유하고 있는 자원을 요구해야 한다
- e.g.
  - thread1 -> thread2 -> thread3 -> thread1

### 8.3.2 자원 할당 그래프(Resource Allocation Graph)

- 시스템 자원 할당 그래프(방향 그래프)로 교착 상태를 더욱 정확하게 기술할 수 있다
- 정점(V = vertex)는 프로세스를 나타내고, 간선(E = edge)는 자원을 나타낸다
  - T -> R : 자원 요청
  - R -> T : 자원 할당
- 자원할당 그래프에 사이클이 없다면, 시스템은 교착상태가 아니다
- 사이클이 있다면 시스템은 교착상태 일 수도 있고 아닐 수도 있다

## 8.4 교착 상태 처리 방법(Methods for Handling Deadlocks)

- 교착 상태 문제를 처리하는 데 세 가지 방법이 있다

  - (1) 문제를 `무시`하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다
  - (2) 시스템이 `결코 교착 상태가 되지 않도록 보장`하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다
  - (3) 시스템이 교착 상태가 되도록 `허용`한 다음에 (감지 후) `복구` 시키는 방법이 있다

- 첫 번째 해결안(교착상태 무시)이 Linux와 Windows를 포함해 대부분의 운영체제가 사용하는 방법이다
  - 이 경우 교착 상태를 처리하는 프로그램을 작성하는 것은 응용 개발자의 몫
    - 보통 두 번째 해결안을 사용한다(결코 교착 상태가 되지 않도록 보장)
- 데이터베이스와 같은 일부 시스템은 세 번째 해결안을 채택하여 교착 상태의 발생을 허용하고 복구 작업을 수행한다
- 몇몇 연구자들은 이 기본적인 방법 중 어느 것도 단독으로는 운영체제에서의 자원 할당 문제 전 범위를 처리하는 데에는 적절하지 못하다고 주장
- 교착 상태가 발생하지 않도록 예방, 혹은 회피 기법의 하나를 사용할 수 있다
- 교착 상태 `예방`은 8.3.1절에서 언급한 `필요조건 중 적어도 하나가 성립하지 않도록 보장`하는 일련의 방법이다 => 8.5절에서 논의
- 교착 상태 `회피`는 스레드가 `사용할 자원에 대한 부가적인 정보`를 미리 제공할 것을 요구 한다 => 8.6절
  - 이 사용할 자원에 대한 정보를 가지고 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다
- 교착 상태가 언제 발생했는지 상태를 조사하는 알고리즘, 교착 상태로 부터 복구하기 위한 알고리즘 => 8.7, 8.8절
- 교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 든다
  - 많은 시스템에서 교착 상태는 드물게(예를 들면 한달에 한번) 발생하기 때문에 다른 처리 방법을 사용하는 부가적인 비용은 그만한 가치가 없을 수 있다
- 라이브락과 같은 다른 라이브니스 조건으로부터 복구하는 데 사용되는 방법을 교착 상태로 부터 복구하는 데 사용할 수 있다
- 어떤 상황에서는 시스템이 라이브니스 장애로 고생하고 있지만 교착 상태에 있지 않을 수 있다
  - 이러한 상황의 예로 최고 우선순위로 수행되고 제어가 결코 운영체제로 돌아가지 않는 실시간 스레드(혹은 비선점 스케줄러에서 수행되는 임의의 스레드)의 경우를 고려할 수 있다
  - 따라서 시스템은 교착 상태가 아닌 상황을 위해 수작업 복구 방법을 반드시 가지고 있어야 하며, 단순히 동일한 방법을 교착 상태 회복을 위해서 사용할 수도 있다

## 8.5 교착 상태 예방(Deadlock Prevention)

## 8.6 교착 상태 회피(Deadlock Avoidance)

## 8.7 교착 상태 탐지(Deadlock Detection)

## 8.8 교착 상태로부터 회복(Recovery from Deadlock)

## 8.9 요약

- 집합의 모든 프로세스가 같은 집합의 다른 프로세스에서만 발생할 수 있는 이벤트를 기다리는 경우 프로세스 집합에서 교착 상태가 발생한다
- 교착 상태에 필요한 네 가지 조건이 있다
  - 상호 배제(Mutual Exclusion)
  - 점유 대기(Hold and Wait)
  - 비선점(No Preemption)
  - 순환 대기(Circular Wait)
  - 교착 상태는 네 가지 조건이 모두 존재할 때만 가능하다
- 교착 상태는 자원 할당 그래프를 사용하여 모델링 할 수 있다
  - 여기서 사이클은 교착 상태를 가리킨다
- 교착 상태에 필요한 4가지 조건 중 하나가 발생하지 않도록 하여 교착 상태를 예방할 수 있다
  - 필요한 네 가지 조건 중 순환 대기를 제거하는 것이 유일한 현실적인 접근 방식이다
- 은행원 알고리즘을 사용하여 교착 상태를 회피할 수 있다
  - 이 알고리즘은 시스템을 교착 상태가 발생할 가능성이 있는 불안전 상태로 이끌 수 있는 자원 요청은 허가하지 않는다
- 교착 상태 감지 알고리즘은 실행 중인 시스템의 프로세스 및 자원을 평가하여 일련의 프로세스가 교착 상태에 있는지 아닌지 결정한다
- 교착 상태가 발생하면 시스템은 순환 대기 중인 프로세스 중 하나를 중단하거나 교착 상태의 프로세스에 지정된 자원을 선점하여 교착 상태에서 복구를 시도할 수 있다
