# 4. 스레드와 병행성

- 3장에서 소개한 프로세스 모델 : 한 프로세스 -> 하나의 제어 스레드
- 현대 운영체제는 한 프로세스가 다중 스레드를 포함한다
- 다중 CPU를 제공하는 최신 다중 코어 시스템에서 스레드 사용을 통한 병렬 처리의 기회를 식별하는 것이 점차 중요해졌다

#### 이 장의 목표

- 스레드의 기본 구성요소를 식별하고, 스레드와 프로세스를 대조한다
- 다중 스레드 프로세스를 설계할 때의 주요 이점과 중대한 과제를 설명ㅎ나다
- 스레드 풀, 포크, 조인 및 그랜드 센트럴 디스패치를 포함하여 암시적 스레딩에 대한 다양한 접근 방식을 설명한다
- Pthread, Java 및 Windows 스레딩 API를 사용하여 다중 스레드 응용 프로그램을 설계한다

## 4.1 개요(Overview)

- 스레드는 CPU 이용의 기본 단위이다.
- 스레드는 스레드 ID, 프로그램 카운터(PC), 레지스터 집합 및 스택으로 구성된다.
- 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다
- 전통적인 프로세스는 하나의 제어 스레드를 가지고 있다
- 만일 프로세스가 다수의 제어 스레드를 가진다면, 프로세스는 동시에 여러 작업을 수행할 수 있다

### 4.1.1 동기 (Motivation)

- 현대 거의 모든 소프트웨어 응용프로그램들은 다중 스레드를 이용한다
- 다중 스레드 응용 프로그램 예시

  - 사진 축소판을 만드는 응용 프로그램
    - 별도의 스레드를 사용하여 개별 이미지에서 축소판을 생성
  - 웹 브라우저
    - 이미지 또는 텍스트 표시
    - 네트워크에서 데이터 검색
  - 워드 프로세서
    - 그래픽 표시
    - 키 입력 응답
    - 맞춤법 검사 등

- 애플리케이션은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다(병렬 처리)
- 대부분 운영체제 커널도 일반적으로 다중 스레드이다
  - ps -ef 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시할 수 있다
    - 커널 스레드는 커널 내부에서 실행되는 스레드이다

### 4.1.2 장점(Benefits)

- 다중 스레드 프로그래밍의 장점 4가지

#### 1. 응답성(responsiveness)

#### 2. 자원 공유

- 프로세스와 프로세스는 공유 메모리와 메시지 전달 기법을 통해서 자원을 공유할 수 있다
  - 프로그래머에 의해 명시적으로 처리 되어야 한다
- 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다
  - 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점이다

#### 3. 경제성(economy)

- 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다
- 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 context switching하는 것이 더 적은 비용이 든다
- 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다
- context switching은 일반적으로 프로세스 사이보다 스레드 사이에서 더 빠르다

#### 4. 규모 적응성(scalability)

- 다중 스레드의 이점은 다중 처리기(multi processing) 구조에서 더욱 증가할 수 있다
  - 각각의 스레드가 병렬로 수행되기 때문이다

## 4.2 다중 코어 프로그래밍(Multicore Programming)

- 컴퓨터는 단일CPU에서 다중 CPU 시스템으로 발전하였다
- 각 코어는 운영체제에 별도의 CPU로 보인다
- 병행성 vs 병렬성
  - 병행성 : 하나의 CPU에서 여러 작업을 동시에 수행하는 것
  - 병렬성 : 여러 CPU에서 여러 작업을 동시에 수행하는 것

### 4.2.1 프로그래밍 도전과제(Programming Challenges)

- 운영체제 설계자는 병렬 수행이 될 수 있도록 여러 코어를 활용하는 스케줄링 알고리즘을 개발해야 한다
- 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 하고 새로운 프로그램을 다중 스레드로 작성해야 한다

- 다중 코어 시스템을 위한 5개의 도전과제
  - (1) 태스크 인식 (identifying tasks)
    - 어플리케이션을 분석해서 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다
  - (2) 균형(balance)
    - 병렬 가능 태스크 -> 균등하게 분배
    - 다른 태스크에 비해 기여도가 적은 작업이 있을 수 있는데 이런 작업을 위해 별도의 코어를 사용하는 것은 그만한 가치가 없다
  - (3) 데이터 분리(data splitting)
    - 태스크가 접근하고 조작하는 데이터도 개별 코어에서 사용할 수 있도록 나누어져야 한다
  - (4) 데이터 종속성(data dependency)
    - 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다
    - 태스크 사이가 데이터 종속적인 경우에 종속성을 수용할 수 있도록 태스크 수행을 잘 동기화해야 한다
  - (5) 시험 및 디버깅(testing and debugging)
    - 프로그램이 다중 코엉에서 병렬로 시행될 때, 다양한실행 경로가 존재할 수 있다
    - 그런 병행 프로그램을 시험하고 디버깅하는 것은 단일 스레드 어플리케이션을 테스트하고 디버깅하는 것보다 근복적으로 훨씬 더 어렵다

### 4.2.2 병렬 실행의 유형

- 데이터의 병렬 실행 | 태스크의 병렬 실행

#### 데이터의 병렬 실행

- 테스크의 병렬 실행은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다
- 크기가 N인 배열의 내용을 더하는 경우
  - 단일 코어 시스템 : 0부터 N-1까지의 합을 계산
  - 다중 코어 시스템 : 0부터 N/2-1까지의 합을 계산하는 태스크와 N/2부터 N-1까지의 합을 계산하는 태스크를 각각 다른 코어에서 실행

#### 태스크의 병렬 실행

- 각 태스크(스레드)를 다수의 코어에 분배한다
- 스레드는 고유의 연산을 실행한다

## 4.3 다중 스레드 모델(Multithreading Models)

- 스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서

  - 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다

- 사용자 스레드는 커널 위에서 지원되며 커널의 지원없이 관리된다

  - 반면 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다

- 현대 운영체제들은 커널 스레드를 지원한다

- 이 절에선 사용자 스레드와 커널 스레드는 어떤 관계가 존재하는지 알아보자
  - 다대일
  - 일대일
  - 다대다

### 4.3.1 다대일 모델(Many to one model)

- `많은 사용자 수준 스레드`를 `하나의 커널 스레드`로 매핑한다
- 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다(4.4절 참고)
- 한번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다
- 다중 코어 시스템이 표준이 되면서 이 모델은 거의 사용되지 않는다

### 4.3.2 일대일 모델(One to one model)

- 각 사용자 스레드를 각각 하나의 커널 스레드로 매핑한다
- 이 모델은 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다
- 또한 이 모델은 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다
- 이 모델의 유일한 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며, 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다는 것이다
- Linux는 Windows 운영체제 제품군과 함게 일대일 모델을 구현한다

### 4.3.3 다대다 모델(Many to many model)

- 다대일 모델과 일대일 모델의 장점을 결합한 모델이다
- 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플렉싱(multiplexing)한다

  - 멀티플렉싱(다중화) : 하나의 회선 또는 전송로(유선의 경우 1조의 케이블, 무선의 경우 1조의 송수신기)를 분할하여 개별적으로 독립된 다수의 신호를 결합하여 한 신호로 만든 후 공동의 통신로로 동시에 전송하는 기술
    - https://terms.naver.com/entry.naver?docId=2754894&cid=50307&categoryId=50307

- 변형 => 두 수준 모델(two-level model)

  - 멀티플렉싱시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용한다

- 다대다 모델이 논의된 모델 중 가장 융통성있지만 실제로 구현하긴 어렵다

  - 또한 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었다

- 결과적으로 대부분의 운영체제는 이제 일대일 모델을 사용한다
- 그러나 4.5절에서 일부 현대 병행 라이브러리는 개발자가 태스크를 식별하면 다대다 모델을 사용하여 스레드에 매핑될 수 있게 한다

## 4.4 스레드 라이브러리(Thread Library)

- 스레드 라이브러리는 프로그래머에게 스레드르 생성하고 관리하기 위한 API를 제공한다
- 스레드 라이브러리를 구현하는 데에는 주된 두 가지 방법이 있다
  - (1) 커널 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것
    - 라이브러리의 모든 코드와 자료구조는 사용자 공간에 존재한다
    - 라이브러리의 함수를 호출하는 것은 시스템 콜이 아니라 사용자 공간의 지역함수를 호출하게 된다는 것을 의미한다
  - (2) 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것
    - 라이브러리 코드와 자료구조는 커널 공간에 존재한다
    - 라이브러리 API를 호출하면 커널 시스템 콜을 호출하게 된다
- 현재 POSIX Pthreads, Windows, Java 이렇게 세 종류의 라이브러리가 주로 사용된다
- POSIX 표준안의 스레드 확장판인 Pthreads는 사용자 또는 커널 수준 라이브러리로서 제공될 수 있다
- Windows 스레드 라이브러리는 Windows 시스템에서 사용 가능한 커널 수준 라이브러리이다
- Java 스레드 API는 Java 프로그램에서 직접 스레드 생성과 관리를 가능하게 한다
  - 그러나 대부분 JVM 구현은 호스트 운영체제에서 실행되기 때문에 Java 스레드 API는 통상 호스트 시스템에서 사용가능한 스레드 라이브러리를 이용하여 구현된다
  - e.g.
    - Windows 운영체제에서 Java 스레드는 Windows API를 사용하여 구현된다는 것을 의미한다
    - UNIX, Linux 및 macOS 시스템에서는 통상 Pthreads를 사용한다
- POSIX와 Windows 스레드의 경우 전역 변수로 선언된 데이터는 같은 프로세스에 속한 모든 스레드가 공유한다
- Java는 상응하는 전역 데이터 액세스라는 개념이없기 때문에 공유 데이터에 대한 접근이 스레드 사이에 명시적으로 조율되어야 한다
- 앞으로 다룰 주제
  - 음이 아닌 정수의 합을 구하는 다중 스레드 프로그램 설계
  - 비동기 스레딩과 동기 스레딩

### 비동기 스레딩과 동기 스레딩

#### 비동기 스레딩

- 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행
- 데이터 공유는 거의 없다(독립적이기 때문)

#### 동기 스레딩

- 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식
- 자식 스레드는 병행하게 실행되지만 부모 스레드는 자식 스레드가 종료될 때까지 기다려야 한다
- 동기 스레딩은 보통 스레드 사이(부모-자식)의 상당한 양의 데이터 공유를 수반한다
- 이 절에서 소개하는 예에서는 동기 스레딩을 사용한다

### 4.4.1 Pthread

- Pthreads는 POSIX가 스레드 생성과 동기화를 위해 제정한 표준 API 이다
- 이것은 스레드 동작에 관한 명세일뿐 그것 자체를 구현한 것은 아니다
- 운영체제 설계자들은 나름대로 Pthreads를 구현하여 제공한다

- 그림 4.11 Pthread API를 사용하는 다중 스레드 C 프로그램

### 4.4.2 Windows 스레드(Windows Threads)

- Windows 스레드 라이브러리를 이용하여 스레드를 생성하는 기술은 많은 점에서 Pthreads 기법과 유사하다

### 4.4.3 Java 스레드(Java Threads)

- 스레드는 Java 프로그램의 프로그램 실행의 근본적인 모델이고, Java 언어와 API는 스레드의 생성과 관리를 지원하는 풍부한 특성을 제공한다
- 모든 Java 프로그램은 적어도 하나의 단일 제어 스레드를 포함하고 있다
  - 단지 main() 함수로만 이루어진 단순한 Java 프로그램도차 JVM 내의 하나의 단일 스레드로 실행된다
- Java 스레드는 JVM을 제공하는 어떠한 시스템에서도 사용할 수 있다
  - JVM을 제공하는 시스템들 : Windows, UNIX, Linux, macOS 등
  - Java 스레드 API는 Android 응용 프로그램에서도 사용할 수 있다
- Java 프로그램에서 스레드를 명시적으로 생성하는 두 가지 방법
  - (1) Thread 클래스를 확장하는 방법
    - Thread 클래스를 확장하여 새로운 스레드를 정의하고, run() 메소드를 재정의하여 스레드가 실행할 코드를 정의한다
  - (2) Runnable 인터페이스를 구현하는 방법
    - Runnable 인터페이스를 구현하는 클래스를 정의하고, run() 메소드를 재정의하여 스레드가 실행할 코드를 정의한다

```java
public class MyThread extends Thread {
  public void run() {
    // 스레드가 실행할 코드
  }
}
```

```java
public class MyRunnable implements Runnable {
  public void run() {
    // 스레드가 실행할 코드
  }
}

Thread worker = new Thread(new MyRunnable());
worker.start();
```

- Thread 인스턴스에 대해 start() 메소드를 호출하면 두 가지 작업이 수행된다

  - (1) 메모리가 할당되고, JVM 내에 새로운 스레드가 초기화된다
  - (2) run() 메소드를 호출하면 스레드가 JVM에 의해 수행될 자격을 갖게 한다
    - run() 메소드를 직접 호출하지마라. 그 대신 start() 메소드를 호출하고 이 메소드가 우리 대신 run() 메소드를 호출한다

- Pthreads의 pthread_join()과 Windows의 Wait-ForSingleObject()를 사용하여 각 스레드가 완료되기를 기다렸다가 진행하는 것 처럼
  - Java의 join() 메소드는 유사한 기능을 제공한다

```java
try {
  worker.join();
} catch (InterruptedException e) {
  // 스레드가 인터럽트되었을 때 처리
}
```

- join()은 InterruptedException을 던질 수 있으므로 try-catch 블록으로 감싸야 한다

#### 4.4.3.1 Java Executor 프레임워크

- Java 5부터는 Executor 프레임워크를 사용하여 스레드를 생성하고 관리할 수 있다
- 스레드 생성 및 통신에 대한 제어 기능을 크게 향상 키기는 병행 처리 기능을 제공하는 프레임워크

- Executor
  - 생산자-소비자 모델을 기반으로 한다(한쪽은 계속 생산만, 한쪽은 소비만)
- 생산
  - Runnable 인터페이스르 구현하는 작업이 생성
- 소비
  - 작업 실행하는 스레드가 이를 소비
- 장점
  - 스레드 생성을 실행에서 분리
  - 병행하게 실행되는 작업 간 통신 기법을 제공
- 자바는 순수한 객체지향언어로 전역 데이터에 대한 개념이 없다
  - 스레드의 결과를 반환할 수 없다
    - java.util.concurrent 패키지에서 Callable 인터페이스를정의, 결과를 반환할 수 있게 함

## 4.5 암묵적 스레딩(implicit threading)

- 다중 코어 처리의 지속적 성장에 따라 수백 또는 심지어 수천 개의 스레드를 가진 응용프로그램이 등장하게 되었다
- 그런 응용 프로그램을 설계하는 것은 사소한 일이 아니며, 프로그래머는 4.2절에서 설명한 도전과제뿐 아니라 추가 어려움을 극복해야 한다
  - 추가 어려움?
    - 이러한 어려움 중 프로그램의 정확도와 관계된 것들은 6장, 8장에서 논의된다
- 이러한 어려움을 극복하고 병행 및 병렬 응용 프로그램의 설계를 도와주는 한 가지 방법으 `스레딩의 생성과 관리` 책임을 응용 프로그램 개발자로부터 컴파일과 실행 시간 `라이브러리에게 넘겨주는 것이다` : 암묵적 스레딩
  - 런타임 라이브러리는 일반적으로 다대다 모델을 사용하여 별도의 스레드에 매핑된다
- 이 방법의 장점은 개발자는 병렬 작업만 식별하면 되고, 라이브러리는 스레드 생성 및 관리에 대한 특정 세부 사항을 결정한다는 것이다

### 4.5.1 스레드 풀

- 4.1절에선 다중 스레드로 구성된 웹 브라우저를 살펴보았다
  - 웹 서버는 요청을 받을 때 마다 그 요청을 새로운 스레드로 만들어 준다
  - 스레드를 만들고 관리하는 비용이 크기 때문에, 이러한 방식은 비효율적이다
  - 이러한 문제를 해결해 줄 수 있는 방법 중 하나가 스레드 풀(pool)이다
- 스레드 풀
  - 스레드를 미리 생성해 놓고, 스레드 풀에 있는 스레드를 사용하는 방식
  - 스레드 풀은 스레드를 생성하고 관리하는 비용을 줄이고, 스레드를 재사용할 수 있게 해준다
  - 요청을 받으면 스레드 풀에 제출
  - 풀에 사용 가능한 스레드가 없으면 사용가능한 스레드가 생길 때 까지 작업이 대기 된다
- 스레드 풀에 제출 된 작업을 비동기적으로 실행할 수 있는 경우 스레드 풀이 제대로 작동한다

- 스레드 풀의 장점

  - (1) 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다
  - (2) 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다
    - 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다
  - (3) 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크 실행을 다르게 할 수 있다
    - 예를 들어, 태스크를 일정 시간 후에 실행되도록 스케줄 하거나 혹은 주기적으로 실행시킬 수 있다

- 스레드 풀에 있는 스레드 개수는 CPU 수, 물리 메모리 용량, 동시 요청 클라이언트 최대 개수 등을 고려하여 정해질 수 있다
- 더 정교하게 하려면 풀의 활용도를 보며 동적으로 풀의 크기를 바꾸어줄 수도 있다
  - 이런 구조는 시스템 부하가 적을 때는 더 작은 풀을 유지하도록 함으로써 메모리 등의 소모를 더 줄일 수 있다
    - 이런 구조 중 하나인 Apple의 Grand Central Dispatch(GCD)에 대해 4.5.4절에서 논의한다

#### 4.5.1.1 Java 스레드 풀(Java Thread Pool)

- java.util.concurrent 패키지에는 여러 종류의 스레드 풀 구조에 대한 API가 포함되어 있다

### 4.5.2 Fork Join

- 4.4절(스레드 라이브러리, 동기 스레딩)에서 다루는 스레드 생성 전략은 종종 fork-join 모델로 알려져있다
- 이 메소드를 사용하면 메인 부모 스레드가 하나 이상의 자식 스레드를 생성(fork)한 다음 자식의 종료를 기다린 후(join)하고 그 시점부터 자식의 결과를 확인하고 결합할 수 있다
- 암시적 스레딩에서도 fork-join 모델을 사용할 수 있다
  - fork 단계에서 스레드가 직접 구축되지 않고 병렬 작업이 식별된다
  - 라이브러리는 생성되는 스레드 수를 관리하며, 스레드에 작업 배정을 책임진다
  - 이 fork-join 모델은 라이브러리가 생성할 실제 스레드 수를 결정하는 동기 버전의 스레드 풀이다

#### 4.5.2.1 Java에서의 Fork Join

- Java는 Quicksort 및 Mergesort와 같은 재귀 분할-정복 알고리즘과 함께 사용되도록 설계된 버전 1.7 API에 fork join 라이브러리를 도입하였다
  - mergesort : https://www.geeksforgeeks.org/merge-sort/
  - 이 라이브러리를 사용하여 분할-정복 알고리즘을 구현할 때
    - 분할 단계 동안 별도의 작업이 fork 되고
    - 원래 문제의 작은 부분집합이 할당된다
  - 이러한 별도의 작업이 병행하게 실행할 수 있도록 알고리즘이 설계되어야 한다

```java
// Java fork-join 모델의 일반적인 재귀 알고리즘
Task(problem) {
  if (problem is small enough) {
    solve problem directly
  } else {
    subtask1 = fork(new Task(subset of problem))
    subtask2 = fork(new Task(subset of problem))

    result1 = join(subtask1)
    result2 = join(subtask2)

    return combined results
  }
}
```

- Java의 fork-join 모델에서 흥미로운 점은
  - 라이브러리가 작업자 스레드(worker thread) 풀을 생성하고 사용가능한 작업자(worker) 사이 부하의 균형을 조정하려는 작업 관리에 있다
  - 어떤 상황에서는 수천 개의 작업이 있지만 작업을 수행하는 소수의 스레드(예, CPU마다 하나의 개별 스레드)만 있다
  - 또한 ForkJoinPool의 각 스레드는 fork된 작업의 큐를 유지관리하며, 스레드의 큐가 비어있으면 work stealing 알고리즘을 사용하여 다른 스레드 큐에서 작업을 가져올 수 있으므로 모든 스레드 간에 부하를 분산시킬 수 있다

### 4.5.3 OpenMP

- OpenMP는 C, C++, Fortran으로 작성된 API와 컴파일러 디렉티브(directive 지침, 지시)의 집합이다

  - OpenMP는 공유 메모리 환경에서 병렬 프로그래밍을 할 수 있도록 도움을 준다

- OpenMP는 병렬로 실행될 수 있는 블록을 찾아 병렬역역이라 부른다
- 응용 프로그램 개발자는 자신들의 코드 중 병렬 영역에 컴파일러 `디렉티브(데코레이터? - 차이 : 블록이 지정됨 약간 함수와 비슷)`를 삽입한다
  - `#pragma omp parallel` : 병렬 영역 시작

```c
#include <omp.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
  // sequential code
  #pragma omp parallel
  {
    // parallel code
    printf("I am a parallel region.\n");
  }
  // sequential code
  return 0;
}
```

### 4.5.4 Apple의 Grand Central Dispatch(GCD)

- 개발자가 병렬로 실행될 코드 섹션(태스크)을 식별할 수 있도록 하는 런타임 라이브러리, API 및 언어 확장의 조합이다
- OpenMP와 마찬가지로 GCD는 스레딩에 대한 대부분의 세부 사항을 관리한다

- GCD는 실행 시간 수행을 위해 태스크를 디스패치 큐에 넣어서 스케줄 한다
- 큐에서 태스크를 제거할 때 관리하는 스레드 풀에서 가용 스레드를 선택하여 태스크를 할당한다
- GCD는 `직렬(serial)`과 `병행(concurrent)`의 두 가지 유형의 디스패치 큐를 유지한다
- 각 프로세스에는 고유한 직렬 큐(=메인 큐)가 있으며
  - 개발자는 특정 프로세스에 로컬로 추가 직렬 큐를 만들 수 있다(개인 디스패치큐라고도 하는 이유)
- 병행 큐

  - 한 번에 여러 태스크가 제거되어 병렬로 실행될 수 있게 한다
  - 다수의 시스템 전체의 병행 큐(전역 디스패치 큐)가 존재하며 4가지 주요 서비스 품질 클래스로 나뉜다
    - (1) QOS_CLASS_USER_INTERACTIVE(사용자 대화형 클래스)
      - 반응형 사용자 인터페이스를 보장하기 위해 사용자와 상호작용하는 태스크를 나타낸다
      - 사용자 인터페이스와 이벤트 처리 등이 포함됨
      - 이 클래스에는 아주 적은 양의 작업만 해야 한다
    - (2) QOS_CLASS_USER_INITIATED(사용자 시작 클래스)
      - 태스크가 반응형 사용자 인터페이스와 관련되어 있다 - 사용자 대화형 클래스와 유사
      - 그러나 사용자 시작 인터페이스는 처리 시간이 더 오래 걸릴 수 있다
      - 예를들어, 파일 또는 URL을 여는 것은 사용자 시작 태스크이다
      - 사용자 대화형 큐의 태스크만큼 빨리 서비스될 필요는 없다
    - (3) QOS_CLASS_UTILITY(유틸리티 클래스)
      - 완료하는 데 시간이 오래걸리지만 즉각적인 결과를 요구하지 않는 태스크
      - 데이터 가져오기같은 작업이 포함된다
    - (4) QOS_CLASS_BACKGROUND(백그라운드 클래스)
      - 사용자에게 보이지 않으며 시간에 민감하지 않다
      - 예를 들어, 메일박스 시스템에 색인을 만들거나 백업 수행이 있다

- 디스패치 큐에 제출된 태스크는 다음 두 가지 방법 중 하나로 표현될 수 있다
  - 블록
  - closure

```c
// block
^{printf("I am a block.\n");}
```

```swift
let queue = dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0)
dispatch_async(queue) {
  print("I am a closure.")
}
```

- Swift 코드 세그먼트는 사용자 시작 클래스에 대한 병행 큐를 획득하고 dispatch_async() 함수를 사용하여 태스크를 큐에 제출하는 것을 보여준다
- 내부적으로 GCD의 스레드 풀은 POSIX 스레드로 구성된다
- GCD는 풀을 적극적으로 관리하여 응용 프로그램 요구 및 시스템 용량에 따라 스레드 수가 늘어나거나 줄어들게 한다

### 4.5.5 Intel 스레드 빌딩 블록

- Intel TBB(threading building block)는 C++에서 병렬 응용 프로그램 설계를 지원하는 템플릿 라이브러리이다
- 이것은 라이브러리이므로 특별한 컴파일러나 언어지원이 필요하지 않다
- 개발자는 병렬로 실행할 수 있는 태스크를 지정하고 TBB 태스크 스케줄러는 이러한 태스크를 하부 스레드에 매핑한다
- 또한 태스크 스케줄러는 부하 균형 기능을 제공하고 캐시를 인지한다
  - 캐시 인지 : 빠르게 실행, 태스크에 우선순위를 부여한다는 것을 의미

## 4.6 스레드와 관련된 문제들(Treading issues)

- 다중 스레드 프로그램을 설계할 때 고려해야 할 몇 가지 문제들을 논의한다

### 4.6.1 Fork() 및 Exec() 시스템 콜

- fork()를 호출하면 새로운 프로세스는 모든 스레드를 복제해야 하는가?
  - 아니면 한 개의 스레드만 가지는 프로세스여야 하는가?
  - 몇몇 UNIX 기종은 이 두 가지 버전 fork()를 다 제공한다
- exec() 시스템 콜은 보통 3장에서 기술한 것과 같은 방법으로 수행된다
  - exec()의 매개 변수로 지정된 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체시킨다

### 4.6.2 신호 처리(Signal Handling)

- 신호는 UNIX에서 프로세스에 어떤 `이벤트`가 일어났음을 알려주기 위해 사용된다
- 신호는 동기식 또는 비동기식으로 전달될 수 있다
- 동기식이건 비동기식이건 모든 신호는 다음과 같은 형태로 전달된다
  - (1) 신호는 특정 `이벤트가 일어나야` 생성된다
  - (2) 생성된 신호가 `프로세스에 전달`된다
  - (3) 신호가 `전달`되면 반드시 `처리`되어야 한다
- 동기식 신호 : 신호를 발생 시킨 프로세스에 전달됨
- 비동기식 신호 : 다른 프로세스에 전달 됨

  - e.g.
    - (UNIX) kill(pid_t pid, int signal) : 프로세스 강제 종료

- 신호 처리기

  - (1) 디폴트 신호 처리기
    - 모든 신호마다 커널이 제공하는 디폴트 신호 처리기가 있다
    - 사용자 정의 처리기에 의해 대체될 수 있다
  - (2) 사용자 정의 신호 처리기

- 다중 스레드 프로그램에서 신호 처리 - 어느 스레드에 신호를 전달해야 하는가?

  - (1) 신호가 적용될 스레드에게 전달한다
  - (2) 모든 스레드에 전달한다
  - (3) 몇몇 스레드들에만 선택적으로 전달한다
  - (4) 특정 스레드가 모든 신호를 전달받도록 지정한다

- POSIX Pthread는 tid로 지정된 스레드에만 전달이 되도록 허용하는 다음과 같은 함수를 제공

  - pthread_kill(pthread_t tid, int signal)

- Windows는 신호를 명시적으로 지원하진 않지만 비동기식 프로시저 호출(asyncronous procedure call)을 사용하여 대리 실행(emulate)할 수 있다
  - APC는 프로세스에 전달되는 것이 아니라 특정 스레드에게 전달되기 때문에 좀 더 간단하다

### 4.6.3 스레드 취소(Thread Cancellation)

- 스레드가 끝나기 전에 그것을 강제 종료 시키는 작업
  - 예) 웹 브라우저의 stop 버튼
- 이 처럼 취소되어야 할 스레드를 목적 스레드(target thread)라고 부른다
- 목적 스레드의 취소는 다음과 같은 두 가지 방식으로 발생할 수 있다

  - (1) `비동기식 취소(asynchronous cancellation)`
    - 한 스레드가 즉시 목적 스레드를 강제 종료 시킨다
  - (2) `지연 취소(deferred cancellation)` - defer : 미루다, 연기하다
    - 목적 스레드가 주기적으로 자신이 강제 종료 되어야 할지를 점검한다
    - 이 경우 목적 스레드가 질서 정연하게 강제 종료될 수 있는 기회가 만들어진다

- 스레드 취소를 어렵게 만드는 것은
  - 취소 스레드들에 할당된 자원 문제이다
  - 또한 스레드가 다른 스레드와 공유하는 자료구조를 갱신하는 도중에 취소 요청이 와도 문제가 된다
    - 비동기식 취소의 경우 더 심각하다
  - 종종 운영체제는 취소된 스레드로부터 시스템 자원을 회수할 수도 있지만, 모든 시스템 자원을 다 회수하지 못하는 경우도 있다
  - 따라서 비동기식으로 스레드를 취소하면 필요한 시스템 자원을 다 사용 가능한 상태로 만들지 못할 수도 있다
- 지연 취소의 경우

  - 한 스레드가 목적 스레드를 취소한다고 표시하지만 실제 취소는 목적 스레드가 취소 여부를 결정하기 위한 플래그 검사한 이후에야 일어난다
    - 스레드는 자신이 취소되어도 안전하다고 판단되는 시점에서 취소 여부를 검사할 수 있다

- Pthreads는 3가지 취소 모드를 지원한다

| 모드                 | 상태        | 유형          |
| -------------------- | ----------- | ------------- |
| Off                  | 사용 불가능 | -             |
| 지연(deferred)       | 사용 가능   | 지연 취소     |
| 비동기(asynchronous) | 사용 가능   | 비동기식 취소 |

- 기본 취소 유형은 지연 취소이다
  - 스레드가 취소 점에 도달한 경우에만 취소가 발생한다
- Pthreads는 스레드가 취소될 때 정리 핸들러(cleanup handler)라고 하는 함수가 호출되게 할 수 있다
  - 스레드가 종료되기 전에 스레드가 획득한 모든 자원을 해제한다

### 4.6.4 스레드-로컬 저장장치(Thread-Local Storage)

- 한 프로세스에 속한 스레드들은 그 프로세스의 데이터를 모두 공유한다
- 그러나 상황에 따라 스레드 자기만 액세스할 수 있는 데이터를 가져야 할 필요도 있다
  - 그러한 데이터를 스레드-로컬 저장장치(thread-local storage, TLS)라고 부른다
- 어떤 면에서 TLS는 정적 데이터와 유사하다(사실 TLS는 보통 static으로 선언된다)
- 대부분의 스레드 라이브러리 및 컴파일러는 TLS를 지원한다
  - 예를 들어, Java는 `ThreadLocal<T>` 객체에 대한 set() 및 get() 메소드와 함께 `ThreadLocal<T>` 클래스를 제공한다

### 4.6.5 스케줄러 액티베이션(Scheduler Activations)

- 스레드 라이브러리와 커널의 통신 문제이다
  - 이 통신은 4.3.3절에서 논의한 다대다 및 두 수준 모델에서 반드시 해결해야 할 문제이다
  - 이러한 통신의 조정은 응용 프로그램이 최고의 성능을 보이도록 보장하기 위하여 커널 스레드의 수를 동적으로 조정하는 것을 가능하게 한다
- 다대다 또는 두 수준 모델을 구현하는 많은 시스템은 `사용자와 커널 스레드 사이`에 `중간 자료`를 둔다
  - 이 자료구조는 통상 경량 프로세스 또는 LWP(Light Weight Process)라고 불린다
    - `사용자 스레드` <-> `LWP(경량 프로세스)` <-> `커널 스레드`
- 예) 서로 다른 5개의 파일 읽기 요청이 발생

  - 모든 LWP가 입출력 완료를 기다리면서 커널 안에서 대기할 수 있기 때문에 5개의 LWP가 필요하다

- `사용자 스레드 라이브러리와 커널 스레드 간의 통신` 방법 중 하나는 `스케줄러 액티베이션`이라고 알려진 방법이다
  - 커널은 응용 프로그램에 가상 처리기(LWP)의 집합을 제공하고
  - 응용 프로그램은 사용자 스레드를 가용한 가상 처리기로 스케줄 한다
  - 게다가 커널은 응용 프로그램에게 특정 이벤트에 대해 알려줘야 한다
    - 이 프로시저를 upcall 이라고 부른다
- upcall은 스레드 라이브러리의 upcall 처리기에 의해 처리되고,
  - upcall 처리기는 가상 처리기(LWP)상에서 실행되어야 한다

## 4.7 운영체제 사례(Operating-system example)

- Windows와 Linux 시스템에서 스레드를 어떻게 구현하는지를 살펴보자

### 4.7.1 Windows 스레드

- Windows 응용 프로그램들은 프로세스 형태로 실행되며 이들 각 프로세스는 한 개 또는 그 이상의 스레드를 가질 수 있다

- 스레드의 일반적인 구성요소는 다음과 같다

  - 각 스레드를 유일하게 지목하는 스레드 ID
  - 처리기의 상태를 나타내는 레지스터 집합
    - 레지스터 : 메모리보다 빠른 기억 장치
  - 프로그램 카운터(명령어 포인터)
    - 다음에 실행될 명령의 주소를 포함한다
  - 사용자 모드에서 실행될 때 필요한 사용자 스택, 커널 모드에서 실행될 때 필요한 커널 스택
  - 실행 시간 라이브러리와 동적 링크 라이브러리(DLL) 등이 사용하는 개별 데이터 저장 영역

- 레지스터 집합, 스택, 개별 데이터 저장 영역들은 그 스레드의 문맥으로 불린다
  - 스레드의 주요 자료구조는 다음과 같다
  - ETHREAD : 실행 스레드 블록(Execution Thread Block)
    - 커널안에 존재 - 커널만이 접근할 수 있다
    - 주요 내용
      - 그 스레드가 속한 프로세스를 가리키는 포인터
      - 그 스레드가 실행을 시작해야 할 루틴의 주소
  - KTHREAD : 커널 스레드 블록(Kernel Thread Block)
    - 커널안에 존재 - 커널만이 접근할 수 있다
    - 스레드의 스케줄링 및 동기화 정보
    - 이 스레드가 커널 모드에서 실행될 때 사용되는 커널 스택과 TEB에 대한 포인터를 가지고 있다
  - TEB : 스레드 환경 블록(Thread Environment Block)
    - 사용자 모드에서 실행될 때 접근되는 사용자 공간 자료구조
    - 스레드 식별자, 사용자 모드 스택 및 스레드 국지 저장소를 위한 배열을 가지고 있다
- 참고 : 그림 4.21 Windows 스레드의 자료 구조

### 4.7.2 Linux 스레드

- 3장에서 설명한 것 처럼 프로세스를 복제하는 기능을 가진 fork() 시스템 콜을 제공한다
- Linux는 clone() 시스템 콜을 이용하여 스레드를 생성할 수 있는 기능도 제공한다
- 그러나 `Linux는 프로세스와 스레드를 구별하지 않는다`
- 사실 Linux는 프로그램 내의 제어 흐름을 나타내기 위하여 `프로세스나 스레드보다 태스크라는 용어를 사용`한다
- Linux 커널이 태스크를 표현하는 방식 때문에 다양한 공유 수준이 가능하다
  - 시스템의 태스크 마다 고유한 커널 자료구조가 존재한다
- clone() 시스템 콜의 융통성은 컨테이너 개념으로 확장될 수 있다
  - 컨테이너 : 가상화 주제의 일종으로, 하나의 컴퓨터 시스템에서 여러 개의 독립된 시스템을 구현하는 기술이다
  - 컨테니어는 운영체제가 제공하는 가상화 기법으로 하나의 Linux 커널 아래 서로 격리되어 실행되는 여러 개의 Linux 시스템(컨테이너)을 생성하는 것을 가능하게 한다
  - clone()에 전달된 특정 플래그가 부모와 자식 태스크 사이의 정보 공유량에 따라 프로세스 처럼 작동하는 태스크를 생성하느냐 또는 스레드를 생성하느냐를 구분하는 것 처럼, Linux 컨테이너를 생성하도록 clone()에 전달할 수 있는 다른 플래그가 있다
  - 컨테이너는 18장에서 더 자세히 다룰 것이다

## 4.8 요약(Summary)

- 스레드는 CPU 사용의 기본 단위를 나타내며, 동일한 프로세스에 속하는 쓰레드는 코드 및 데이터를 포함하여 많은 프로세스 자원을 공유한다
- 다중 스레드 응용 프로그램에는 응답성, 자원 공유, 경제성, 효율성이라는 4가지 주요 이점이 있다
- 여러 스레드가 진행 중인 경우 병행성이 존재하는 반면에 여러 스레드가 동시에 진행 중인 경우 병렬성이 존재한다
  - 단일 CPU가 있는 시스템에서는 오로지 병행성만 가능하고, 병렬성은 여러 CPU를 제공하는 다중 코어 시스템이 필요하다
- 다중 스레드 응용 프로그램을 설계하는 데 몇 가지 도전과제가 있다
  - 작업 분할 및 균형 조정, 서로 다른 스레드 간에 데이터 분할 및 데이터 종속성 식별이 포함된다
  - 다중 스레드 프로그램은 테스트 및 디버깅에 특히 어려움이 있다
- 데이터 병렬처리는 동일한 데이터의 부분 집합을 다른 컴퓨팅 코어에 분산시키고
  - 각 코어에서 동일한 연삭을 수행한다
  - 작업 병렬 처리는 여러 코어에 데이터가 아니라 작업을 분산시킨다
  - 각 작업은 고유한 연산을 실행한다
- 사용자 응용 프로그램은 사용자 수준 스레드를 생성하며, 이 스레드는 궁극적으로 CPU에서 실행되도록 커널 스레드에 매핑되어야 한다
  - 다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드에 매핑한다
  - 다른 접근 법으로는 일대일 및 다대다 모델이 있다
- 스레드 라이브러리는 스레드를 만들고 관리하기 위한 API를 제공한다
  - 세 가지 일반적인 스레드 라이브러리에는 Windows, Pthreads, Java 스레딩이 있다
    - Windows는 Windows 시스템 전용이며,
    - Pthreads는 UNIX, Linux 및 macOS와 같은 POSIX 호환 시스템에서 사용할 수 있다
    - Java 스레드는 Java 가상 머신을 지원하는 모든 시스템에서 실행된다
- 암묵적 스레딩에는 스레드가 아니라 작업을 식별하고 언어 또는 API 프레임 워크가 스레드를 만들고 관리할 수 있게 한다
  - 스레드 풀, fork join 프레임 워크 및 Grand Central Dispatch를 포함하여 암묵적 스레딩에 대한 몇 가지 접근 방법이 있다
  - 암묵적 스레딩은 프로그래머가 병행 및 병렬 응용 프로그램을 개발할 때 점점 더 보편적인 기술이 되고 있다
- 스레드는 비동기 도는 지연 취소를 사용하여 종료될 수 있다
  - 비동기 취소는 스레드가 업데이트를 수행하는 중이라도 스레드를 즉시 중지한다
  - 지연 취소는 스레드에 종료해야 한다고 통지하지만 스레드는 질서 정연하게 종료된다
  - 대부분의 경우 비동기 종료보다 지연 취소가 선호된다
- 다른 많은 운영체제와 달리 Linux는 프로세스와 스레드를 구분하지 않는다
  - 대신 각각을 태스크라고 한다
  - Linux clone() 시스템 콜을 사용하여 프로세스와 더 비슷하거나 스레드와 더 비슷한 태스크를 만들 수 있다

## 연습 문제

- https://cafemocamoca.tistory.com/299
- https://www.os-book.com/OS10/practice-exercises/PDF-practice-solu-dir/4.pdf
