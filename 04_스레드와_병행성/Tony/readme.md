# 4. 스레드와 병행성

- 3장에서 소개한 프로세스 모델 : 한 프로세스 -> 하나의 제어 스레드
- 현대 운영체제는 한 프로세스가 다중 스레드를 포함한다
- 다중 CPU를 제공하는 최신 다중 코어 시스템에서 스레드 사용을 통한 병렬 처리의 기회를 식별하는 것이 점차 중요해졌다

#### 이 장의 목표

- 스레드의 기본 구성요소를 식별하고, 스레드와 프로세스를 대조한다
- 다중 스레드 프로세스를 설계할 때의 주요 이점과 중대한 과제를 설명ㅎ나다
- 스레드 풀, 포크, 조인 및 그랜드 센트럴 디스패치를 포함하여 암시적 스레딩에 대한 다양한 접근 방식을 설명한다
- Pthread, Java 및 Windows 스레딩 API를 사용하여 다중 스레드 응용 프로그램을 설계한다

## 4.1 개요(Overview)

- 스레드는 CPU 이용의 기본 단위이다.
- 스레드는 스레드 ID, 프로그램 카운터(PC), 레지스터 집합 및 스택으로 구성된다.
- 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다
- 전통적인 프로세스는 하나의 제어 스레드를 가지고 있다
- 만일 프로세스가 다수의 제어 스레드를 가진다면, 프로세스는 동시에 여러 작업을 수행할 수 있다

### 4.1.1 동기 (Motivation)

- 현대 거의 모든 소프트웨어 응용프로그램들은 다중 스레드를 이용한다
- 다중 스레드 응용 프로그램 예시

  - 사진 축소판을 만드는 응용 프로그램
    - 별도의 스레드를 사용하여 개별 이미지에서 축소판을 생성
  - 웹 브라우저
    - 이미지 또는 텍스트 표시
    - 네트워크에서 데이터 검색
  - 워드 프로세서
    - 그래픽 표시
    - 키 입력 응답
    - 맞춤법 검사 등

- 애플리케이션은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다(병렬 처리)
- 대부분 운영체제 커널도 일반적으로 다중 스레드이다
  - ps -ef 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시할 수 있다
    - 커널 스레드는 커널 내부에서 실행되는 스레드이다

### 4.1.2 장점(Benefits)

- 다중 스레드 프로그래밍의 장점 4가지

#### 1. 응답성(responsiveness)

#### 2. 자원 공유

- 프로세스와 프로세스는 공유 메모리와 메시지 전달 기법을 통해서 자원을 공유할 수 있다
  - 프로그래머에 의해 명시적으로 처리 되어야 한다
- 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다
  - 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점이다

#### 3. 경제성(economy)

- 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다
- 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 context switching하는 것이 더 적은 비용이 든다
- 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다
- context switching은 일반적으로 프로세스 사이보다 스레드 사이에서 더 빠르다

#### 4. 규모 적응성(scalability)

- 다중 스레드의 이점은 다중 처리기(multi processing) 구조에서 더욱 증가할 수 있다
  - 각각의 스레드가 병렬로 수행되기 때문이다

## 4.2 다중 코어 프로그래밍(Multicore Programming)

- 컴퓨터는 단일CPU에서 다중 CPU 시스템으로 발전하였다
- 각 코어는 운영체제에 별도의 CPU로 보인다
- 병행성 vs 병렬성
  - 병행성 : 하나의 CPU에서 여러 작업을 동시에 수행하는 것
  - 병렬성 : 여러 CPU에서 여러 작업을 동시에 수행하는 것

### 4.2.1 프로그래밍 도전과제(Programming Challenges)

- 운영체제 설계자는 병렬 수행이 될 수 있도록 여러 코어를 활용하는 스케줄링 알고리즘을 개발해야 한다
- 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 하고 새로운 프로그램을 다중 스레드로 작성해야 한다

- 다중 코어 시스템을 위한 5개의 도전과제
  - (1) 태스크 인식 (identifying tasks)
    - 어플리케이션을 분석해서 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다
  - (2) 균형(balance)
    - 병렬 가능 태스크 -> 균등하게 분배
    - 다른 태스크에 비해 기여도가 적은 작업이 있을 수 있는데 이런 작업을 위해 별도의 코어를 사용하는 것은 그만한 가치가 없다
  - (3) 데이터 분리(data splitting)
    - 태스크가 접근하고 조작하는 데이터도 개별 코어에서 사용할 수 있도록 나누어져야 한다
  - (4) 데이터 종속성(data dependency)
    - 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다
    - 태스크 사이가 데이터 종속적인 경우에 종속성을 수용할 수 있도록 태스크 수행을 잘 동기화해야 한다
  - (5) 시험 및 디버깅(testing and debugging)
    - 프로그램이 다중 코엉에서 병렬로 시행될 때, 다양한실행 경로가 존재할 수 있다
    - 그런 병행 프로그램을 시험하고 디버깅하는 것은 단일 스레드 어플리케이션을 테스트하고 디버깅하는 것보다 근복적으로 훨씬 더 어렵다

### 4.2.2 병렬 실행의 유형

- 데이터의 병렬 실행 | 태스크의 병렬 실행

#### 데이터의 병렬 실행

- 테스크의 병렬 실행은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다
- 크기가 N인 배열의 내용을 더하는 경우
  - 단일 코어 시스템 : 0부터 N-1까지의 합을 계산
  - 다중 코어 시스템 : 0부터 N/2-1까지의 합을 계산하는 태스크와 N/2부터 N-1까지의 합을 계산하는 태스크를 각각 다른 코어에서 실행

#### 태스크의 병렬 실행

- 각 태스크(스레드)를 다수의 코어에 분배한다
- 스레드는 고유의 연산을 실행한다

## 4.3 다중 스레드 모델(Multithreading Models)

- 스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서

  - 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다

- 사용자 스레드는 커널 위에서 지원되며 커널의 지원없이 관리된다

  - 반면 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다

- 현대 운영체제들은 커널 스레드를 지원한다

- 이 절에선 사용자 스레드와 커널 스레드는 어떤 관계가 존재하는지 알아보자
  - 다대일
  - 일대일
  - 다대다

### 4.3.1 다대일 모델(Many to one model)

- `많은 사용자 수준 스레드`를 `하나의 커널 스레드`로 매핑한다
- 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다(4.4절 참고)
- 한번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다
- 다중 코어 시스템이 표준이 되면서 이 모델은 거의 사용되지 않는다

### 4.3.2 일대일 모델(One to one model)

- 각 사용자 스레드를 각각 하나의 커널 스레드로 매핑한다
- 이 모델은 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다
- 또한 이 모델은 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다
- 이 모델의 유일한 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며, 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다는 것이다
- Linux는 Windows 운영체제 제품군과 함게 일대일 모델을 구현한다

### 4.3.3 다대다 모델(Many to many model)

- 다대일 모델과 일대일 모델의 장점을 결합한 모델이다
- 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플렉싱(multiplexing)한다

  - 멀티플렉싱(다중화) : 하나의 회선 또는 전송로(유선의 경우 1조의 케이블, 무선의 경우 1조의 송수신기)를 분할하여 개별적으로 독립된 다수의 신호를 결합하여 한 신호로 만든 후 공동의 통신로로 동시에 전송하는 기술
    - https://terms.naver.com/entry.naver?docId=2754894&cid=50307&categoryId=50307

- 변형 => 두 수준 모델(two-level model)

  - 멀티플렉싱시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용한다

- 다대다 모델이 논의된 모델 중 가장 융통성있지만 실제로 구현하긴 어렵다

  - 또한 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었다

- 결과적으로 대부분의 운영체제는 이제 일대일 모델을 사용한다
- 그러나 4.5절에서 일부 현대 병행 라이브러리는 개발자가 ㅐㅌ스크를 식별하면 다대다 모델을 사용하여 스레드에 매핑될 수 있게 한다
