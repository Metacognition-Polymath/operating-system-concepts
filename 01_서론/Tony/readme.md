# Part1 : Overview

- chapter 1 : Introduction
- chapter 2 : Operating System Structures
- `운영체제`는 컴퓨터 `사용자`와 컴퓨터 `하드웨어` 사이에서 `중개자` 역할을 한다
- 운영 체제의 목적
  - 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공
- 운영체제란?
  - `컴퓨터 하드웨어를 관리하는 소프트웨어`
- 운영체제는 매우 덩치가 크고 복잡하므로 부분별로 생성되어야 한다
  - 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 하며, 이 부분들의 입력과 출력, 동작은 주의를 기울여 정의해야 한다

# 1. 서론(Introduction)

- 운영체제(operating system)는 `하드웨어를 관리`하는 소프트웨어이다
- 운영체제는 `응용 프로그램을 위한 기반`을 제공하며
- 컴퓨터 사용자와 컴퓨터 `하드웨어 사이에서 중재자 역할`을 수행한다

- 운영체제는 어느 곳에나 존재한다

  - 사물인터넷을 포함하는 기기
  - 스마트폰
  - 개인용 컴퓨터
  - 클라우드 컴퓨팅 환경
  - ... 등

- 운영체제의 역할을 탐구하기 위하여 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다
  - 구성과 구조 지식 -> CPU, 메모리 및 입출력 장치와 저장장치가 포함된다
- 운영체제의 근본적인 책임은 이러한 `자원들을 프로그램에 할당`하는 것이다
- 이 장에서는

  - 현대 컴퓨터 시스템의 주요 구성요소와 운영체제가 제공하는 기능에 대한 일반적인 개관을 제공한다
  - 이 책의 나머지 부분을 위한 다수의 주제, 운영체제에 사용되는 자료구조, 계산환경 및 공개 소스 및 무료 운영체제를 다룬다

- 이 장의 목표
  - 컴퓨터 시슽템의 일반적인 구성과 인터럽트의 역할을 기술한다
  - 현대 다중 처리기 컴퓨터 시스템의 구성요소에 관해 기술한다
  - 사용자 모드에서 커널 모드로의 전환에 대해 설명한다
  - 다양한 컴퓨팅 환경에서 운영체제가 어떻게 사용되는지 논의한다
  - 무료 및 공개 소스 운영체제의 예를 제공한다

## 1.1 운영체제가 할 일 (What Operating Systems Do)

![그림1-1](./images_01/%EA%B7%B8%EB%A6%BC1-1.jpeg)

- 그림1.1 컴퓨터 시스템 구성요소에 대한 개략적 구성도

- 컴퓨터 시스템의 주요 네 가지 구성요소

  - 사용자, 응용 프로그램, 운영체제, 하드웨어

- 하드웨어
  - 중앙 처리 장치(CPU), 메모리, 입출력 장치로 구성되어, 기본 계산용 자원을 제공한다
- 응용 프로그램
  - e.g. 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등
    - 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될지를 정의한다
- 운영체제

  - 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정

- 운영체제의 역할을 좀 더 이해하기 위해 `사용자`와 `시스템` 두 관점에서 살펴본다

### 1.1.1 사용자 관점(user view)

#### PC 사용자 관점

- 컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다

- 많은 사용자는 랩톱 혹은 `모니터, 키보드, 마우스로 구성된 PC` 앞에서 작업한다

  - 이러한 시스템은 한 `사용자가 자원을 독점`하도록 설계되었으며 목표는 사용자가 `수행하는 작업`(또는 놀이)를 `최대화`하는 것이다
  - 대부분 `사용의 용이성`을 위해 설계
  - `성능에 약간 신경`을 씀
  - 하드웨어와 소프트웨어 간의 자원이 어떻게 공유되느냐의 `자원의 이용에는 전혀 신경쓰지 않는다`

#### 모바일 장치 사용자 관점

- 특징
  - 셀룰러 또는 무선 기술을 통해 네트워크에 연결
    - 셀룰러 : 통신 요금을 내고 와이파이 없이도 이용가능
  - 터치스크린
  - 음성인식 인터페이스
- 이런 컴퓨터 운영체제와 응용 프로그램은 사용자의 개입없이 작동하도록 설계되어 있다

### 1.1.2 시스템 관점(system view)

#### 자원 할당자(resource allocator)

- 컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다
- 운영체제를 자원 할당자(resource allocator)로 볼 수 있다
  - 자원 : CPU, 메모리, 저장 장치, 입출력 장치 등
- 운영체제는 이런 자원의 관리자로서 동작한다
  - 서로 상충할 수도 있는 많은 요청 -> 효율적이고 공정하게 운영할 수 있도록 자원할당

#### 제어 프로그램(control program)

- 여러 가지 입출력 장치와 사용자 프로그램을 제어할 필요성을 강조
- 제어프로그램은 `컴퓨터의 부적절한 사용을 방지`하기 위해 `사용자 프로그램의 수행을 제어`
- 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다

### 1.1.3 운영체제의 정의

- 운영체제가 많은 역할과 기능을 수행한다는 것을 알았다
  - 컴퓨터의 설계와 `용도가` 수없이 `많기 때문`
    - 컴퓨터의 용도 예 : 게임기, 케이블 TV 수신기, 산업제어 시스템의 기반 등

#### 컴퓨터의 역사

- 무엇을 할 수 있을지 알기 위한 실험으로 시작
- 고정 목적 시스템 전용
  - 군사용 : 암호 깨기, 탄도 계산 등
  - 정부업무 : 인구조사 계산 등
- 대형 컴퓨터로 발전 -> 운영체제가 탄생
- 1960년대 무어의 법칙
  - 직접 회로의 트랜지스터 수가 18개월마다 2배씩 증가
- 컴퓨터는 기능이 확대되고 크기가 작어졌으며 용도가 다양해졌고 다양한 운영체제가 등장
  - 자세한 역사는 부록 A를 참고

#### 운영체제의 정의

- 일반적으로 운영체제에 대한 적합한 정의는 없다
- 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다
  - 컴퓨팅 시스템의 기본 목표 : 프로그램을 실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것
    - 하드웨어는 이 목표를 가지고 구성된다
    - 오로지 하드웨어만으로 사용하기가 쉽지 않으므로 응용 프로그램이 개발된다
- 응용프로그램
  - 응용 프로그램 : 사용자가 컴퓨터를 사용하는 데 필요한 기능을 제공하는 프로그램
    - vscode, chrome, word, excel 등
  - 이러한 프로그램에는 입출력 장치 제어와 같은 특정 공통 작업이 필요하다
    - 입출력 장치 제어 : 마우스, 키보드 제어
  - 자원을 제어하고 할당하는 일반적인 기능은 운영체제라는 하나의 소프트웨어로 통합된다

#### 운영체제에 포함되는 요소

- 운영체제에 포함되는 요소에 보편적인 요소에 보편적인 정의는 없다

#### 단순한 관점

- "운영체제"를 주문할 때 공급 업체가 제공하는 모든 것을 포함한다는 것
  - 그러나 포함된 기능은 시스템마다 크게 다르다
    - 일부 시스템은 메가 바이트 미만의 공간을 차지하고 전체화면 편집기가 없는 반면
    - 다른 시스템은 기가바이트의 공간이 필요하며 그래픽 윈도 시스템을 기반으로 한다

#### 더욱 일반적인 정의와 우리가 지지하는 것

- 운영체제는 컴퓨터가 컴퓨터에서 `항상 실행되는 프로그램`(일반적으로 `커널`이라고 함)이다
  - [커널 위키 백과](<https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)>)
- 커널과 함께 두 가지 다른 유형의 프로그램이 있다
  - 시스템 프로그램
    - 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는 프로그램
  - 응용 프로그램
    - 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 응용 프로그램

#### 운영체제 구성 요소

- 1998년엔 운영체제에 너무 많은 기능을 포함하여 응용프로그램 공급업체의 경쟁을 막았다면서 Microsoft가 유죄를 선고받았다
- 그러나 오늘날 모바일 기기의 운영체제를 살펴보면 운영체제를 구성하는 기능의 수가 다시 증가하고 있음을 알 수 있다
- `모바일 운영체제`에는 핵심 `커널`뿐만 아니라 `미들웨어`(응용 프로그램 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크)도 포함된다

  - e.g. iOS, Android
    - 핵심 커널
    - 미들웨어
      - 데이터베이스, 멀티미디어, 그래픽 지원

- 요약

  - 운영체제에 포함되는 요소
    - 커널 : 항상 실행 중인 프로그램
    - 미들웨어 : 응용 프로그램 개발을 쉽게 하고 기능을 제공하는 프로그램
    - 시스템 프로그램 : 시스템 실행 중에 시스템을 관리하는데 도움이 되는 프로그램

- 본 교재의 대부분은 범용 운영체제의 커널과 관련이 있지만 운영체제 설계 및 연산을 모두 설명하는 데 필요한 다른 구성요소에 대해서도 설명한다

#### 왜 운영체제를 공부하는가?

- 컴퓨터 관련 산업에 종사하는 사람은 많지만 운영체제를 만들거나 수정하는 데는 소수의 사람만 참여한다
- 그렇다면 왜 운영체제와 그들의 작동방식을 공부하는가?
  - 단순하게 거의 모든 코드가 운영체제 위에서 실행되므로 `운영체제 작동방식에 대한 지식`은 `적절하고 효율적이고 효과적이며 안전한 프로그래밍`에 중요하기 때문이다
  - 운영체제의 기본 지식, 컴퓨터 하드웨어 구동 방식 및 응용 프로그램에 제공하는 내용을 이해하는 것은
    - 운영체제를 작성하는 사람들에게 필수적일 뿐만 아니라
    - 그 위에서 프로그램을 작성하고 운영체제를 사용하는 사람들에게도 매우 유용하다

## 1.2 컴퓨터 시스템의 구성(Computer system organization)

![그림1-2](./images_01/%EA%B7%B8%EB%A6%BC1-2.jpeg)

- 현대의 범용 컴퓨터 시스템
  - 하나이상의 `CPU`와 `구성요소`와 `공유 메모리` 사이의 액세스를 제공하는 공통 `버스`를 통해 연결된 여러 장치 컨트롤러로 구성된다
  - https://jongmin92.github.io/2019/02/18/Programming/computer-structure/

#### 장치 컨트롤러

- 각 장치 컨트롤러는 특정 유형의 장치를 담당한다
  - 컨트롤러에 따라 둘 이상의 장치가 연결될 수도 있다
  - e.g. 하나의 시스템 USB 포트는 여러 장치를 연결할 수 있는 USB 허브에 연결할 수 있다
  - 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적레지스터 집합을 유지관리한다
    - 버퍼 : 버퍼는 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역을 말합니다. 일시적으로 데이터를 보관하기 때문에 버퍼는 사용 후에 데이터를 폐기합니다.
      - 참고 : https://beenii.tistory.com/101
    - 레지스터 : 레지스터는 CPU가 요청을 처리하는 데이터의 임시저장 공간입니다. 공간은 작고 가격은 비싸지만 CPU에 직접 연결되어 있어 연산속도가 매우 빠릅니다.
      - 참고 : https://beenii.tistory.com/101
  - 장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다

#### 장치 드라이버

- 일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다
  - 장치 드라이버는 장치 컨트롤러의 작동을 잘 알고 있고 나머지 운영체제의 장치에 대한 일관된 인터페이스를 제공한다
  - CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다
  - 공유 메모리를 질서 있게 엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 엑세스를 동기화한다

#### 다음절에서

- 다음절에서 시스템의 세 가지 주요 측면에 중점을 두어 이러한 시스템의 작동방식의 기본 사항에 대해 설명한다
  - CPU의 조치가 필요한 이벤트에 대해 경고하는 인터럽트부터 살펴볼 것이다
  - 그런 다음 저장 장치 구조 및 입출력 구조에 대해 설명한다

### 1.2.1 인터럽트(Interrupts)

- 일반적인 컴퓨터 작업(입출력을 수행하는 프로그램)을 고려하자
- 입출력 작업을 시작하기 위해 `장치 드라이버`는 `장치 컨트롤러의 적절한 레지스터`에 `값을 적재`한다
- `장치 컨트롤러는` 이러한 `레지스터의 내용을 검사`하여 `수행할 작업을 결정`한다
  - e.g. 키보드에서 문자 읽기
- 컨트롤러는 `장치`에서 `로컬 버퍼로` `데이터 전송`을 시작한다
- 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다
- 그런 다음 장치 드라이버는 읽기 요청이면 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘긴다
- 다른 작업의 경우 장치 드라이버는 "쓰기 완료" 또는 "장치 사용 중"과 같은 상태 정보를 반환한다
- **그러나 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 어떻게 알리는가?**
  - 이는 `인터럽트를 통해` 이루어진다

#### 1.2.1.1 개요(Overview)

- 하드웨어는 어느 순간이든 시스템 버스를 통해 `CPU에 신호를 보내 인터럽트를 발생`시킬 수 있다
  - 컴퓨터 시스템에는 많은 버스가 있을 수 있지만 `시스템 버스`는 주요 `구성요소 사이의 주요 통신경로`이다
- `인터럽트`는 다른 많은 목적으로도 사용되며 `운영체제와 하드웨어의 상호 작용 방식`의 핵심 부분이다
- CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다
  - 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다
  - 그리고 인터럽트 서비스 루틴이 실행된다
  - 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다
- 이러한 연산의 시간을 일정(time line)이 그림 1.3에 있다

![그림1-3](./images_01/%EA%B7%B8%EB%A6%BC1-3.jpeg)

- 그림 1.3 출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정

- 인터럽트는 컴퓨터 구조의 중요한 부분이다
- 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다
- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다
  - 서비스 루틴
    - 인터럽트 고유 핸들러 호출
- 인터럽트는 매우 빈번하게 발생 -> 빠르게 처리되어야 함
  - 필요한 속도를 제공하기 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다
  - 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다
  - 일반적으로 포인터들의 테이블은 하위 메모리에 저장된다(첫 100개 정도의 위치)
    - 이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다
- 인터럽트가 요청되면 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 인터럽트 벡터가 인터럽트 요청과 함게 주어진 고유의 유일한 장치 번호로 색인된다

  - Windows나 Unix 같은 서로 다른 운영체제가 이러한 방법으로 인터럽트를 처리한다

- 인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다
  - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(e.g. 레지스터의 값을 변경하여)가 있다면
  - 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다
  - 인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것 처럼 다시 시작된다

#### 1.2.1.2 구현(Implementation)

![그림1-4](./images_01/%EA%B7%B8%EB%A6%BC1-4.jpeg)

- 그림 1.4 인터럽트-구동 방식의 입출력 사이클

- 기본 인터럽트 메커니즘은 다음과 같이 작동한다

  - CPU 하드웨어에는 인터럽트 요청 라인(interrupt request line)이라는 선이 있는데, 이는 하나의 명령어의 실행을 완료할 때마다 CPU가 이 선을 감지한다
  - CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을 감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 `인터럽트 핸들러 루틴`(interrupt-handler routine)으로 점프한다
  - 그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다
  - 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다
  - 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생(raise) 시키고 CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch - 보내다)하고 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear)
  - 그림 1.4는 인터럽트-구동 입출력 사이클을 요약한 것이다

- 방금 설명한 기본 인터럽트 기법은 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동깅 이벤트에 CPU가 대응할 수 있게 한다
- 그러나 최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다

  - 1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다
  - 2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다
  - 3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다

- 최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다
- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다
  - 하나는 복구 할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 마스크 불가능 인터럽트(nonmaskable interrupt)이다
  - 두 번째 인터럽트 라인은 마스킹 가능(maskable)이다.
    - 마스킹 가능한 인터럽트는 장치 컨트롤러가 서비스를 요청하기 위해 사용된다
  - 인터럽트 되어서는 안되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 꺼질 수 있다
- 벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이라는 것을 상기하자
  - 보충) 인터럽트 벡터가 인터럽트 요청과 함게 주어진 고유의 유일한 장치 번호로 색인된다 -> 1.3 참고
  - 그러나 실제로 컴퓨터에는 `인터럽트 벡터의 주소 개수`보다 `많은 장치(따라서 인터럽트 처리기)`가 있다
  - 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인을 사용`하는 것이다
  - 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다
  - 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다
    - 이러한 구조는 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안이다

![그림1-5](./images_01/%EA%B7%B8%EB%A6%BC1-5.jpeg)

- 그림 1.5 Intel 처리기 이벤트-벡터 테이블

- 그림 1.5는 Intel 프로세서의 인터럽트 벡터 설계를 보여준다

  - 마스크 불가능한 0에서 31까지의 이벤트는 다양한 오류 조건을 알리는 데 사용된다
  - 마스크 가능한 32에서 255까지의 이벤트는 장치가 생성한 인터럽트 같은 그 외 인터럽트를 처리하기 위해 사용된다
  - 인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현한다
  - 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다

- 요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다(다른 목적으로 사용되는 것에 관해서는 교재 전체에서 논의할 것임)
  - 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다
  - 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다
  - 인터럽트는 시간에 민감함 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요하다

### 1.2.2 저장장치 구조(Storage Structure)

![그림1-6](./images_01/%EA%B7%B8%EB%A6%BC1-6.jpeg)

- 그림 1.6 저장장치 계층 구조

- CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 한다
- 범용 컴퓨터는 프로그램 대부분을 메인 메모리(random-access memory, 또는 RAM이라 불린다 - 재기록 가능한 메모리)에서 가져온다
  - 메인 메모리는 dynamic random-access memory(DRAM)라 불리는 반도체 기술로 구현된다
- 컴퓨터는 다른 형태의 메모리도 사용한다
  - 예를 들어, 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은 부트스트랩 프로그램이며 운영체제를 적재한다
  - RAM은 휘발성(전원이 꺼지거나 손실될 대 내용이 손실됨)이므로 부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다
  - 대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 펌웨어(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다
  - EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다
    - 또한 속도가 느리므로 주로 사용되지 않는 정적 프로그ㅓ램과 데이터가 포함되어 있다
    - 예를 들어, iPhone은 EEPROM을 사용하여 장치의 일련 번호 및 하드웨어 정보를 저장한다
- 모든 형태의 메모리는 바이트의 배열을 제공한다
  - 각 바이트는 자신의 주소를 가지고 있다
  - 상호 작용은 특정 메모리 주소들에 대한 일련의 `적재(load)`, 또는 `저장(store)` 명령을 통하여 이루어진다
    - 적재 명령은 메인 메모리로 부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것이다
    - 저장 명령은 레지스터의 내용을 메인 메모리로 옮긴다
  - 명시적인 적재, 저장 명령 외에, `CPU는 프로그램 카운터에 저장된 위치부터` 실행하기 위해 `메인 메모리에서 명령을 자동으로 적재`한다

#### 폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클

- 먼저 `메모리로부터 명령을 인출`해,
- 그 명령을 `명령 레지스터(instruction register)에 저장`한다
- 이어서 `명령을 해독`하고,
- 이는 메모리부터 피연산자를 인출하여 `내부 레지스터에 저장`하도록 유발할 수 있다
- `피연산자에 대해 명령을 실행`한 후에 `결과`가 `메모리에 다시 저장`될 수 있다
- 메모리 장치는 단지 일련의 메모리 주소만을 인식한다는 사실에 유의하라
- 메모리는 이들 주소 - 명령 카운터(instruction counter), 색인(indexing), 간접 주소(indirection), 리터럴 주소(literal addresses) 등 - 가 어떻게 생성되었는지 알지 못하며,
- 그것이 무언인지(명령인지 데이터인지) 알지 못한다
- 그러므로 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있다
- 우리는단지 실행 중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다
- 이상적으로는 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다
- 그러나 이는 대부분의 시스템에서 두 가지 이유로 불가능하다
  - 1. 메인 메모리는 모든 필요한 프로그램과 데이터를 여구히 저장하기에는 너무 작다
  - 2. 메인 메모리는 이미 언급한 것 처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다
- 그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다
- 보조저장장치의 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다

#### 보조저장장치

- 가장 일반적인 보조저장장치는 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치로, 프로그램과 데이터 모두를 위한 저장소를 제공한다
- 대부분의 프로그램(시스템 및 응용 프고르램)은 메모리에 적재될 때까지 보조저장장치에 저장된다
- 그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다
- `보조저장장치`는 메인 메모리보다 훨씬 `느리다`
  - 따라서 11장에서 논의할 것처럼, 2차 저장장치의 올바른 관리는 컴퓨터 시스템에서 가장 중요하다

#### 그 외 저장장치

- 그러나 더 큰 의미에서 레지스터, 메인 메모리 및 보조저장장치로 구성된 `저장장치구조`는 가능한 많은 `저장장치 시스템 설계 중 하나`일 뿐이다
- 다른 가능한 구성요소로
  - 캐시 메모리, CD-ROM 또는 Blu-ray, 자기 테이프 등이 있다
  - 다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수목적으로만 사용하기에 `매우 느리고 충분히 큰 장치`를 `3차 저장장치`라고 한다
  - 각 저장장치 시스템은 데이터를 저장하고 나중에 검색될 때까지 해당 데이터를 유지하는 기본 기능을 제공한다
  - 다양한 저장장치 시스템 간의 주요 차이점은 속도, 크기 및 휘발성에 있다
- 다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다(그림1.6)
  - 일반적으로 크기와 속도 사이에는 상충하는 측면이 있어서 메모리가 작고 빠를 수록 CPU에 더 가깝다
  - 그림에서 볼 수 있듯이 속도와 용량의 차이 외에도 다양한 저장장치 시스템은 휘발성 또는 비휘발성이다
  - 앞에서 ㅇ언급했듯이 휘발성 저장장치는 장치의 전원이 제거될 때 내용을 잃어버리므로 안전하게 보관하기 위해 데이터를 비휘발성 장치에 기록해야 한다
- 그림1.6 에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 반도체 메모리를 사용하여 구성된다
  - 네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다
  - NVM장치의 가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리다
  - 점차 랩톱, 데스크톱과 서버에서 장기 저장ㅊ에도 플래시 메모리가 사용되고 있다
  - 자장장치는 운영체제 구조에서 중요한 역할을 하기 때문에 교재에서 자주 참조할 것이다
  - 일반적으로 다음 용어를 사용할 것이다
    - `휘발성 저장장치`는 단순히 `메모리`라고 할 것이다. 특정 유형의 저장장치(예: 레지스터)를 강조해야 하는 경우 명시적으로 표현할 것이다
    - `비휘발성 저장장치`는 전원이 꺼졌을 때 내용을 유지한다. 이를 NVS(Non-Volatile Storage)라고 한다.
      - 대부분의 경우 NVS는 보조저장장치를 가리킨다
      - 이 유형의 저장장치는 다음 두 가지 유형으로 분류될 수 있다
        - 1. 기계적
          - 이러한 저장장치 시스템에는 몇 가지 예는 HDD, 광 디스크, 홀로그램 저장장치 및 자기 테이프이다
          - 특정 유형의 기계식 저장장치(예: 자기 테이프를) 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다
        - 2. 전자적
          - 이러한 저장장치 시스템의 몇 가지 예는 플래시 메모리, FRAM, NRAM 및 SSD이다
          - 전기적 저장장치는 NVM으로 언급될 것이다
          - 특정 유형의 전기적 저장장치(예: SSD)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다
        - 기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다
          - 반대로, 전기적 저장장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다
- 완전한 저장장치 시스템 설계는 방금 논의한 모든 요소의 균형을 맞추어야 한다
  - 가능한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에 필요한 만큼만 비싼 메모리를 사용해야 한다
  - 캐시는 두 구성요소 간에 액세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다

### 1.2.3 입출력 구조(I/O Structure)

![그림1-7](./images_01/%EA%B7%B8%EB%A6%BC1-7.jpeg)

- 그림1.7 현대 컴퓨터의 작동방식

- 운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치에 다양한 특정으로 인해 I/O 관리에 할애된다
- 이 절의 시작 부분에서 시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터라는 점을 상기하라
- 1.2.1절에 설명된 인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 `NVS I/O와 같은 대량 데이터 이동`에 사용될 때 높은 `오버헤드를 유발`할 수 있다
  - 이 문제를 해결하기 위해 `직접 메모리 엑세스(DMA)`가 사용된다
  - 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로 부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다
  - 속도가 느린 장치처럼 `한 바이트`마다 인터럽트가 발생하는 것이 `아니라` `블록 전송이 완료될 때마`다 `인터럽트가 발생`한다
  - 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다
- 몇몇 고가의 시스템은 버스 대신에 `스위치구조`를 사용한다
  - 이러한 시스템에서는 공유 버스를 사용하기 위한 사이클을 경쟁하지 않고 `다수의 구성요소가 다른 구성요소들과 동시에 통신`하는 것이 가능하다
  - 이 경우 DMA(직접 메모리 엑세스)의 사용은 더욱 효과적이다
  - 그림 1.7은 컴퓨터 시스템의 구성요소 간의 상호 작용을 보여준다

## 1.3 컴퓨터 시스템 구조(Computer System Architecture)

- 1.2절에서 전형적인 컴퓨터 시스템의 일반적인 구조를 소개하였다
- 컴퓨터 시스템은 사용된 범용 처리기(Processor)의 수에 따라 분류 가능한 다양한 방식으로 구성될 수 있다

### 1.3.1 단일 처리기 시스템(Single-Processor System)

- 몇 년전, 대부분의 컴퓨터 시스템은 단일 처리 코어를 가진 하나의 CPU를 포함하는 단일 프로레서를 사용했다
- 코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소이다
- 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다
- 이 시스템에는 다른 특수 목적 프로세서도 있다
  - 디스크, 키보드 및 그래픽 컨트롤러와 같은 장치별 프로세서 형태로 제공될 수도 있다
- 이 모든 전용 처리기(다른 특수 목적 프로세서 - 키보드, GPU 등)들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지는 않는다
  - 때로 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다
    - 예를들면, `디스크 컨트롤러 마이크로프로세서`는 `주 CPU로 부터` `연속된 요청을 받아들여`, `자기 고유의 디스크 큐`와 `스케줄링 알고리즘을 구현`한다
      - 이 배합(이것저것을 일정한 비율로 한데 섞어 합침)은 CPU가 직접 디스크 스케줄링을 해야 하는 오버헤드를 감소시킨다
  - PC의 키보드는 키스트로크를 CPU에 전송할 코드로 변환하는 마이크로프로세서를 가지고 있다
  - 다른 시스템 또는 환경에서는 전용 처리기가 하드웨어로 구현되는 저수준의 구성요소이다
- 운영체제는 이 처리기들과 통신할 수 없으며 이 처리기들은 독립적으로 자신의 작업을 처리한다
- 전용 마이크로 프로세서의 사용은 일반적인 형태이며 그렇다고 단일 처리기 시스템을 다중 처리기 시스템으로 변환하지는 않는다
- 단일 처리 코어를 가진 범용 CPU가 하나만 있는 경우 시스템은 단일 프로세서 시스템이다
  - 그러나 이 정의에 따르면, 현대 컴퓨터 시스템은 단일 프로세서 시스템이 거의 없다

### 1.3.2 다중 처리기 시스템(Multiprocessor System)

- 모바일 장치에서 서버에 이르기까지 최신 컴퓨터에서는 다중 처리기 시스템이 컴퓨팅 환경을 지배하고 있다.
- 일반적으로 이러한 시스템에는 각각 단일 코어 CPU가 있는 두 개 이상의 프로세서가 있다
- 프로세서의 컴퓨터 버스 및 때때로 클록, 메모리 및 주변 장치를 공유한다
- 다중 처리기 시스템의 주요 장점은 처리량 증가이다
- 즉, 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 처리할 수 있다
- 그러나 N 프로세서의 속도향상 비율은 N이 아니다

  - 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하게 유지하는 데 일정한 양의 오버헤드가 발생한다
  - 이 오버헤드와 공유 자원에 대한 경합은 추가 프로세서의 예상 이득을 낮춘다

#### SMP(Symmetric Multiprocessing)

- 가장 일반적인 다중 처리기 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는 SMP(symmetric multiprocessing)를 사용한다
  - symmetric : 대칭적인, 균형잡힌

![그림1-8](./images_01/%EA%B7%B8%EB%A6%BC1-8.jpeg)

- 그림 1.8 대칭형 다중 처리 구조

- 그림 1.8은 각각 자체 CPU를 가지는 두 개의 프로세서가 있는 일반적인 SMP 구조를 보여준다
  - 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라 자체 레지스터 세트가 있다 그러나 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다
- 이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는 것이다

  - N개의 CPU가 있으면 성능을 크게 저하하지 않으면서 N개의 프로세스를 실행할 수 있다
  - 그러나 CPU가 독립적이기 때문에 하나는 유휴상태이고 다른 하나는 과부하가 걸려 비효율적일 수 있다
  - 프로세서가 `특정 자료구조를 공유`하는 경우 이러한 비효율성을 피할 수 있다
  - 이 (특정 자료구조를 공유하는)형식의 다중 처리기 시스템을 사용하면
    - 프로세스 및 메모리와 같은 자원을 다양한 프로세서 간에 동적으로 공유할 수 있으며,
    - 프로세서 간의 작업 부하 분산을 낮출 수 있다
    - 이러한 시스템은 5장과 6장에서 볼 수 있듯이 신중하게 작성해야 한다

- 다중 처리기의 정의는 시간이 지남에 따라 발전해 왔으며, 이제는 `여러 개의 컴퓨팅 코어`가 `단일 칩에 상주`하는 다중 코어 시스템을 포함한다
  - 칩 내 통신이 칩 간 통신보다 빠르므로 다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적일 수 있다
  - 또한 여러 개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용하는데, 이는 노트북뿐만 아니라 모바일 장치의 중요한 문제이다

![그림1-9](./images_01/%EA%B7%B8%EB%A6%BC1-9.jpeg)

- 그림 1.9 하나의 칩에 두 개의 코어를 가지는 이중-코어 설계

- 그림 1.9에서는 같은 프로세서 칩에 두 개의 코어를 가지는 이중 코어 설계를 보여준다
  - 이 설계에서 각 코어에는 자체 레지스터 세트와 레벨1(L1) 캐시라고도 하는 자체 로컬 캐시가 있다
  - 또한 레벨2(L2) 캐시는 칩에 국한되지만 두 처리 코어에서 공유한다.
  - 아키텍처 대부분은 로컬 및 공유 캐시를 결합한 이 접근 방식을 채택한다
  - 로컬 하위 레벨 캐시는 일반적으로 상위 레벨 공유 캐시보다 작고 빠르다
  - 캐시, 메모리 및 버스 경합과 같은 아키텍처 고려 사항 외에도 N코어를 가지는 다중 코어 프로세서는 운영체제에 N개의 CPU 처럼 보인다
  - 이러한 특성은 운영체제 설계자 및 응용 프로그램 프로그래머에게 이러한처리 코어를 효율적으로 사용하는 코드를 개발하도록 압박한다
    - 이러한 쟁점은 4장에서 다룰 것이다
  - Windows, macOS 및 Linux를 포함한 거의 모든 최신 운영체제는 물론 Android 및 iOS 모바일 시스템도 다중 코어 SMP 시스템을 지원한다
  - 다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상된다
    - 그러나 앞에서 제한한 것 처럼 이러한 개념은 그다지 확장성이 좋지 않고, CPU를 너무 많이 추가하면 시스템 버스에 대한 경합이 병목 현상이 되어 성능이 저하되기 시작한다

#### NUMA(Non-Uniform Memory Access)

![그림1-10](./images_01/%EA%B7%B8%EB%A6%BC1-10.jpeg)

- 그림 1.10 NUMA 다중 처리 구조

- 다른 방법은 각 CPU(또는 CPU그룹)에 작고 빠른 로컬 버스를 통해 액세스 되는 자체 로컬 메모리를 제공하는 것이다
  - 모든 CPU가 공유 시스템 연결로 연결되어 모든 CPU가 하나의 물리 주소 공간을 공유한다
  - NUMA(non-uniform memory access)라고 하는 이 방법은 그림 1.10에 도시되어 있다
  - 장점은 CPU가 로컬 메모리에 액세스 할 때 빠를 뿐만 아니라, 시스템 상호 연결에 대한 경합도 없다는 것이다
  - 따라서 NUMA 시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다
- NUMA 시스템의 잠재적 단점은 CPU가 시스템 상호 연결을 통해 원격 메모리에 액세스해야 할 때 지연 시간이 증가하여 성능 저하가 발생할 수 있다는 것이다
  - 즉, 예를 들어 CPU0은 자체 로컬 메모리에 액세스 할 수 있는 만큼 빠르게 `CPU3의 로컬 메모리에 액세스` 할 수 없어 `성능이 저하`된다
    - 5.5.2절과 10.5.4절에서 논의된 것 처럼 운영체제는 `신중한 CPU 스케쥴링` 및 `메모리 관리`를 통해 이 `NUMA의 단점을 최소화`할 수 있다
- NUMA 시스템은 많은 수의 프로세서를 수용할 수 있도록 확장할 수 있으므로 고성능 컴퓨팅 시스템 뿐만 아니라 서버에서도 점점 인기를 얻고 있다

#### PC 마더보드

- 아래에 표시된 프로세서 소켓이 있는 데스크톱 PC 마더보드를 고려하자

![그림-PC마더보드](./images_01/%EA%B7%B8%EB%A6%BC-PC%EB%A7%88%EB%8D%94%EB%B3%B4%EB%93%9C.jpeg)

- 이 보드는 슬롯이 채워지면 온전히 작동하는 컴퓨터이다
- CPU를 포함하는 프로세서 소켓, DRAM 소켓, PCIe 버스 슬롯 및 다양한 유형의 I/O 커넥터로 구성된다
- 가장 저렴한 범용 CPU조차도 여러 개의 코어를 포함한다
- 일부 마더보드네은 여러 개의 프로세서 소켓이 있다
- 고급 컴퓨터 일수록 둘 이상의 시스템 보드를 허용하여 NUMA 시스템을 형성한다

#### 블레이드 서버

- 마지막으로 블레이드 서버는 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 섀시(chassis)안에 장착되는 형태를 가진다
- 블레이드 서버와 전통적인 다중 처리기 시스템과의 차이점은 각 블레이드-처리기 보드는 독립적으로 부팅될 수 있고 자기 자신의 운영체제를 수행한다는 것이다
- 어떤 블레이드-서버 보드는 자체가 다중 처리기이기도 하며 이 사실은 컴퓨터 유형 간의 경계를 모호하게 만든다
- 근본적으로 이 블레이드 서버는 여러 독립적인 다중 처리기 시스템으로 구성된다

### 1.3.3 클러스터형 시스템(Clustered System)

- 여러 CPU를 가진 시스템의 또 다른 유형은 클러스터형 시스템이다
  - 클러스터 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 굿어한다는점이 1.3.2절에서 설명한 다중 처리기 시스템과 차이가 난다
  - 각 노드는 통상 다중 코어 시스템이다
  - 이런 시스템은 약결합(loosely coupled)이라고 간주된다
  - 클러스터형(clustered)의 정의는 분명하지 않다. 만ㅎ은 상업용 패키지와 공개 소스 패키지들은 클러스터 시스템을 정의하고 왜 한 형태가 다른 형태보다 좋은지에 대한 문제에 답을 제시하는 데 어려움을 겪고 있다
  - 거리 통신망(local area network, LAN)이나 InfiniBand와 같은 고속의 상호 연결망(interconnect)으로 연결된다
- 클러스터링은 통상 높은 가용성(availability)을 제공하기 위해 사용된다
  - 즉, 클러스터 내 하나 이상의 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공된다
  - 일반적으로 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다
  - 클러스터 소프트웨어중 한 층이 클러스터 노드에서 실행된다
  - 각 노드는 하나 이상의 다른 노드(네트워크로 연결되어 있는)들을 감시한다
  - 만일 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받고, 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다
  - 사용자와 응용 프로그램의 클라이언트는 잠깐의 서비스 중단만을 경험하게 된다
  - 높은 가용성은 안정성을 향상해 많은 응용 프로그램에서 중요하다
  - 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능을 우하한 성능 저하(graceful degradation)라고 한다
  - 시스템의 정상적인 성능 저하를 넘어 단일 구성요소에 오류가 발생하여도 계속 작동할 수 있도록 결함허용 시스템이라고 한다
  - 결함허용에는 장애를 감지, 진단 및 가능한 경우 수정할 수 있는 기법이 필요하다
- 클러스터링은 비대칭적으로 구성될 수 있다
  - 비대칭형 클러스터링에서는 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 긴급대기(hot-standby) 모드 상태를 유지한다
  - 이 긴급 대기 모드의 호스트는 활성 서버들을 감시하는 작업만을 수행한다
  - 서버가 고장낱ㄴ다면 긴급 대기 모드의 호스트가 활성 서버가 된다
  - 대칭형 클러스터링에서는 둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시한다
  - 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적이다
  - 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행가능해야 한다
- 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다
  - 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로 단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공할 수 있다
  - 그렇지만 응용이 클러스터를 이용할 수 있도록 작성되어야 한다
  - 이는 `병렬화`라는 기법으로 프로그램을 컴퓨터의 개별 코어에서 혹은 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함한다
  - 전형적으로 이들 응용은 클러스터의 각 계산 노드가 문제 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 해답을 얻게 된다
- 다른 형태의 클러스로 병렬(parallel) 클러스터와 WAN을 이용한 클러스터링이 있다
  - 병렬 클러스터는 여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 한다
  - 운영체제의 대부분이 여러 호스트에 의한 이러한 동시 접근을 지원하지 않으므로 병렬 클러스터는 특수 소프트웨어 버전과 특별히 발매된 응용으로 달성한다
  - 예를 들면, Oracle Real Application Cluster는 병렬 클러스터에서 수행하도록 설계된 Oracle의 데이터베이스 버전이다
  - 각 기계는 Oracle을 수행하고 하나의 소프트웨어 층이 공유 된 디스크에 대한 접근을 관리한다
  - 각 기계는 데이터베이스 내의 모든 데이터에 대한 완전한 접근을 한다
  - 데이터에 대한 공유 접근을 제공하기 위하여, 시스템은 접근 간의 충돌이 발생하지 않는 것을 보장하기 위하여 접근 제어와 잠금 기법을 제공해야 한다
    - 분산 잠금 관리자(distributed lock manager, DLM)라고 불리는 이 기능은 몇몇의 클러스터 기술에 포함되어 있다
- 클러스터 기술은 급변하고 있다
  - 어떤 클러스터 제품은 수 킬로미터 떨어진 클러스터 노드들뿐 아니라 한 클러스터 안에서 수천개의 노드를 지원한다
    - 이러한 개선은 11.7.4에서 설명될 스토리지 전용 네트워크(storage-area network, SAN)에 의해 가능해졌다
    - SAN은 여러 호스트를 여러 저장장치에 부착할 수 있게 한다
    - 만일 응용과 데이터가 SAN에 저장 된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 응용을 배정할 수 있다
    - 호스트가 고장 나면 다른 호스트가 그 응용을 넘겨받는다
    - 데이터베이스 클러스터에서는 수십 개의 호스트가 동일한 데이터베이스를 공유할 수 있기 때문에 성능과 신뢰도를 매우 증가시키게 된다
    - 그림 1.11은 클러스터 시스템의 일반 구조를 보인다

![그림1-11](./images_01/%EA%B7%B8%EB%A6%BC1-11.jpeg)

- 그림 1.11 클러스터 시스템의 일반적인 구조

## 1.4 운영체제의 작동(Operating System Operations)

- 컴퓨터 시스템 구성 및 아키텍처에 대한 기본 정보를 살펴보았으므로 이제 운영체제에 대해 이야기할 준비가 되었다
  - `운영체제`는 `프로그램이 실행`되는 `환경을 제공`한다
- 컴퓨터의 전원을 켜거나 재부팅 할 때와 같이 `컴퓨터를 실행`하려면 `초기 프로그램을 실행`해야 한다
  - 초기 프로그램 또는 부트스트랩 프로그램은 단순한 형태를 띠는 경향이 있다
  - 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다
- CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기 까지 시스템의 모든 측면을 초기화 한다
- 부트스트랩 프로그램은 운영체제를 적재하는 방법과 시스템 실행을 시작하는 방법을 알아야 한다
  - 이 목표를 달성하려면 `부트스트랩 프로그램`이 `운영체제 커널을 찾아` `메모리에 적재`해야 한다
- 커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다
- 일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 `시스템 데몬`이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 `커널 외부에서 제공`된다
- Linux에서 첫 번째 시스템 프로그램은 "systemd"이며 다른 많은 데몬을 시작한다
  - 이 단계가 완료되면 시스템은 완전히 부팅되고 시스템은 어떤 이벤트가 발생할 때까지 기다린다
  - 실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없는 경우 운영체제는 조용히 앉아 무언가가 발생할 때까지 기다린다
- 이벤트는 거의 항상 인터럽트를 발생시켜 신호를 보낸다
  - 또 다른 형태의 인터럽트는 `트랩(또는 예외)`으로, 오류(e.g. 0으로 나누거나 유효하지 않은 메모리 액세스) 또는 사용자 프로그램의 특정 요청 때문에 발생하는 소프트웨어 생성 인터럽트이다
    - 이 특정 요청은 `시스템 콜이라는 특수 연산을 실행`하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다
      - 시스템 콜 예시 추측) 부팅 시 0x123456 에 접근할 수 없습니다 같은 경고창 뜨는 것
        - https://m.blog.naver.com/jh4l2656/70109548466

### 1.4.1 다중 프로그래밍과 다중 태스킹(multiprogramming and multitasking)

- 운영체제의 가장 중요한 측면 중 하나는 하나의 프로그램은 일반적으로 항상 CPU나 I/O 장치를 항상 바쁘게 유지할 수 없으므로
  - 여러 프로그램을 실행할 수 있다는 것이다
- 또한 사용자는 일반적으로 한 번에 둘 이상의 프로그램을 실행하려고 한다
- `다중 프로그래밍`은 CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다
  - 다중 프로그램 시스템에서 실행 중인 프로그램을 `프로세스`라고 한다

![그림1-12](./images_01/%EA%B7%B8%EB%A6%BC1-12.jpeg)

- 그림 1.12 다중 프로그래밍 시스템을 위한 메모리 배치

- 운영체제는 여러 프로세스를 동시에 메모리에 유지한다
  - 운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 시작한다
  - 결국 프로세스는 I/O 작업과 같은 일부 작업이 완료되기를 기다려야 할 수도 있다
  - 다중 프로그래밍 되지 않은 시스템에서는 CPU가 유휴 상태일 수 있다
  - 다중 프로그램 시스템에서 운영체제는 단순히 다른 프로세스로 전환한다
  - 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다
  - 하나 이상의 프로세스를 실행해야 하는 한 CPU는 유휴 상태가 아니다
- 이 아이디어는 다른 일상생활에서도 흔히 볼 수 있다
  - 변호사는 한 번에 단지 한 사람의 의뢰인만 상대하는 것이 아니다
  - 한 사건이 재판을 기다리거나 문서 작성을 기다릴 동안, 변호사는 또 다른 사건을 처리할 수 있다
  - 만일 변호사가 충분히 많은 의뢰인을 확보하고 있다면 변호사가 일이 없어서 쉬는 일은 발생하지 않는다
- 멀티 태스킹(multitasking)은 다중 프로그래밍의 논리적 확장이다

  - 멀티 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공하게 된다
  - 프로세스가 실행될 때 일반적으로 프로세스가 완료되거나 I/O를 수행하기 전에 짧은 시간 동안만 실행된다
  - 입출력은 대화식일 수 있다
    - 즉, 출력이 사용자를 위해 디스플레이되고, 인력은 사용자 키보드, 마우스 또는 터치스크린으로 부터 들어온다
  - 이런 대화식 입출력은 전형적으로 사람의 속도로 수행되므로, 완료 시 까지 상당히 긴 시간이 걸릴 수 있다
  - 예를 들면 입력은 사용자의 타이핑 속도에 제한을 받으며, 사람에게는 1초에 7문자가 빠른편이지만, 컴퓨터에겐 아주 느린 것이다
  - 이러한 대화식 입력이 진행되는 동안 CPU를 쉬게 하지 않고 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다

- 동시에 여러 프로세스를 메모리에 유지하려면 9장과 10장에서 다루는 `메모리 관리 방식`이 필요하다
- 또한 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 다음에 실행할 프로세스를 선택해야 한다
  - 이 결정을 내리는 것은 5장에서 논의될 `CPU 스케줄링`이다
- 마지막으로 여러 프로세스를 병행하게 실행하려면 `프로세스 스케줄링`, `디스크 저장장치 및 메모리 관리`를 포함하여 운영체제의 모든 단계에서 `서로 영향을 미치는 기능이 제한`되어야 한다
  - 이 책 전반에 걸쳐 논의한다
- 다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다

  - 적절한 응답 시간을 보장하는 더 일반적인 방법은 `가상 메모리(virtual memory)`인데, 이것은 `일부만 메모리에 적재된 프로세스의 실행`을 허용하는 기법이다(10장)

    - 가상 메모리 : 실제 주기억 장치보다 큰 메모리 영역을 제공하는 방법으로 사용

      - https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC

    - 이 기법의 주요한 이점은 프로그램이 물리 메모리의 크기보다 더 커도 된다는 것이다
    - 가상 메모리는 메인 메모리를 물리 메모리로부터 분리시킨다
    - 이러한 기법은 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해준다

- 다중 프로그래밍 및 다중 태스킹 시스템도 파일 시스템을 제공해야 한다(13 ~ 15장)
  - 파일 시스템은 보조 저장장치에 존재한다
  - 따라서 저장장치 관리가 제공되어야 한다(11장)
  - 또한 시스템은 부적절한 사용으로부터 자원을 보호해야 한다(17장)
  - 질서 있게 실행하려면 시스템은 프로세스 동기화 및 통신을 위한 기법을 제공해야 하며(6장 및 7장)
  - 프로세스가 서로를 영원히 기다리는 교착 상태에 빠지지 않도록 보장해야 한다(8장)

### 1.4.2 이중-모드와 다중모드 운용(Dual-mode and multimode operation)

- 운영 체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게 설계된 운영체제는 잘못된(또는 악의적인) 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 없도록 보장해야 한다
  - 윈도우 안전모드?
  - 시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자-정의 코드 실행을 구분할 수 있어야 한다
  - 대부분의 컴퓨터 시스템이 취하는 접근 방식은 다양한 실행 모드를 차별화 할 수 있는 하드웨어 지원을 제공하는 것이다
- 적어도 두 개의 독립된 연산모드, 즉 사용자 모드와 커널 모드를 필요로 한다
  - 커널모드 : 수퍼바이저 모드, 시스템 모드, 또는 특권 모드(privileged mode) 라고도 부른다
  - 모드 비트(mode bit)라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다
  - 이 비트는 커널 모드(0) 또는 사용자 모드(1)를 나타낸다
  - 모드 비트의 사용으로, 우리는 운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다
