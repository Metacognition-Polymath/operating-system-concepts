# Part1 : Overview

- chapter 1 : Introduction
- chapter 2 : Operating System Structures
- `운영체제`는 컴퓨터 `사용자`와 컴퓨터 `하드웨어` 사이에서 `중개자` 역할을 한다
- 운영 체제의 목적
  - 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공
- 운영체제란?
  - `컴퓨터 하드웨어를 관리하는 소프트웨어`
- 운영체제는 매우 덩치가 크고 복잡하므로 부분별로 생성되어야 한다
  - 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 하며, 이 부분들의 입력과 출력, 동작은 주의를 기울여 정의해야 한다

# 1. 서론(Introduction)

- 운영체제(operating system)는 `하드웨어를 관리`하는 소프트웨어이다
- 운영체제는 `응용 프로그램을 위한 기반`을 제공하며
- 컴퓨터 사용자와 컴퓨터 `하드웨어 사이에서 중재자 역할`을 수행한다

- 운영체제는 어느 곳에나 존재한다

  - 사물인터넷을 포함하는 기기
  - 스마트폰
  - 개인용 컴퓨터
  - 클라우드 컴퓨팅 환경
  - ... 등

- 운영체제의 역할을 탐구하기 위하여 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다
  - 구성과 구조 지식 -> CPU, 메모리 및 입출력 장치와 저장장치가 포함된다
- 운영체제의 근본적인 책임은 이러한 `자원들을 프로그램에 할당`하는 것이다
- 이 장에서는

  - 현대 컴퓨터 시스템의 주요 구성요소와 운영체제가 제공하는 기능에 대한 일반적인 개관을 제공한다
  - 이 책의 나머지 부분을 위한 다수의 주제, 운영체제에 사용되는 자료구조, 계산환경 및 공개 소스 및 무료 운영체제를 다룬다

- 이 장의 목표
  - 컴퓨터 시슽템의 일반적인 구성과 인터럽트의 역할을 기술한다
  - 현대 다중 처리기 컴퓨터 시스템의 구성요소에 관해 기술한다
  - 사용자 모드에서 커널 모드로의 전환에 대해 설명한다
  - 다양한 컴퓨팅 환경에서 운영체제가 어떻게 사용되는지 논의한다
  - 무료 및 공개 소스 운영체제의 예를 제공한다

## 1.1 운영체제가 할 일 (What Operating Systems Do)

![그림1-1](./images_01/%EA%B7%B8%EB%A6%BC1-1.jpeg)

- 그림1.1 컴퓨터 시스템 구성요소에 대한 개략적 구성도

- 컴퓨터 시스템의 주요 네 가지 구성요소

  - 사용자, 응용 프로그램, 운영체제, 하드웨어

- 하드웨어
  - 중앙 처리 장치(CPU), 메모리, 입출력 장치로 구성되어, 기본 계산용 자원을 제공한다
- 응용 프로그램
  - e.g. 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등
    - 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될지를 정의한다
- 운영체제

  - 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정

- 운영체제의 역할을 좀 더 이해하기 위해 `사용자`와 `시스템` 두 관점에서 살펴본다

### 1.1.1 사용자 관점(user view)

#### PC 사용자 관점

- 컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다

- 많은 사용자는 랩톱 혹은 `모니터, 키보드, 마우스로 구성된 PC` 앞에서 작업한다

  - 이러한 시스템은 한 `사용자가 자원을 독점`하도록 설계되었으며 목표는 사용자가 `수행하는 작업`(또는 놀이)를 `최대화`하는 것이다
  - 대부분 `사용의 용이성`을 위해 설계
  - `성능에 약간 신경`을 씀
  - 하드웨어와 소프트웨어 간의 자원이 어떻게 공유되느냐의 `자원의 이용에는 전혀 신경쓰지 않는다`

#### 모바일 장치 사용자 관점

- 특징
  - 셀룰러 또는 무선 기술을 통해 네트워크에 연결
    - 셀룰러 : 통신 요금을 내고 와이파이 없이도 이용가능
  - 터치스크린
  - 음성인식 인터페이스
- 이런 컴퓨터 운영체제와 응용 프로그램은 사용자의 개입없이 작동하도록 설계되어 있다

### 1.1.2 시스템 관점(system view)

#### 자원 할당자(resource allocator)

- 컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다
- 운영체제를 자원 할당자(resource allocator)로 볼 수 있다
  - 자원 : CPU, 메모리, 저장 장치, 입출력 장치 등
- 운영체제는 이런 자원의 관리자로서 동작한다
  - 서로 상충할 수도 있는 많은 요청 -> 효율적이고 공정하게 운영할 수 있도록 자원할당

#### 제어 프로그램(control program)

- 여러 가지 입출력 장치와 사용자 프로그램을 제어할 필요성을 강조
- 제어프로그램은 `컴퓨터의 부적절한 사용을 방지`하기 위해 `사용자 프로그램의 수행을 제어`
- 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다

### 1.1.3 운영체제의 정의

- 운영체제가 많은 역할과 기능을 수행한다는 것을 알았다
  - 컴퓨터의 설계와 `용도가` 수없이 `많기 때문`
    - 컴퓨터의 용도 예 : 게임기, 케이블 TV 수신기, 산업제어 시스템의 기반 등

#### 컴퓨터의 역사

- 무엇을 할 수 있을지 알기 위한 실험으로 시작
- 고정 목적 시스템 전용
  - 군사용 : 암호 깨기, 탄도 계산 등
  - 정부업무 : 인구조사 계산 등
- 대형 컴퓨터로 발전 -> 운영체제가 탄생
- 1960년대 무어의 법칙
  - 직접 회로의 트랜지스터 수가 18개월마다 2배씩 증가
- 컴퓨터는 기능이 확대되고 크기가 작어졌으며 용도가 다양해졌고 다양한 운영체제가 등장
  - 자세한 역사는 부록 A를 참고

#### 운영체제의 정의

- 일반적으로 운영체제에 대한 적합한 정의는 없다
- 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다
  - 컴퓨팅 시스템의 기본 목표 : 프로그램을 실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것
    - 하드웨어는 이 목표를 가지고 구성된다
    - 오로지 하드웨어만으로 사용하기가 쉽지 않으므로 응용 프로그램이 개발된다
- 응용프로그램
  - 응용 프로그램 : 사용자가 컴퓨터를 사용하는 데 필요한 기능을 제공하는 프로그램
    - vscode, chrome, word, excel 등
  - 이러한 프로그램에는 입출력 장치 제어와 같은 특정 공통 작업이 필요하다
    - 입출력 장치 제어 : 마우스, 키보드 제어
  - 자원을 제어하고 할당하는 일반적인 기능은 운영체제라는 하나의 소프트웨어로 통합된다

#### 운영체제에 포함되는 요소

- 운영체제에 포함되는 요소에 보편적인 요소에 보편적인 정의는 없다

#### 단순한 관점

- "운영체제"를 주문할 때 공급 업체가 제공하는 모든 것을 포함한다는 것
  - 그러나 포함된 기능은 시스템마다 크게 다르다
    - 일부 시스템은 메가 바이트 미만의 공간을 차지하고 전체화면 편집기가 없는 반면
    - 다른 시스템은 기가바이트의 공간이 필요하며 그래픽 윈도 시스템을 기반으로 한다

#### 더욱 일반적인 정의와 우리가 지지하는 것

- 운영체제는 컴퓨터가 컴퓨터에서 `항상 실행되는 프로그램`(일반적으로 `커널`이라고 함)이다
  - [커널 위키 백과](<https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)>)
- 커널과 함께 두 가지 다른 유형의 프로그램이 있다
  - 시스템 프로그램
    - 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는 프로그램
  - 응용 프로그램
    - 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 응용 프로그램

#### 운영체제 구성 요소

- 1998년엔 운영체제에 너무 많은 기능을 포함하여 응용프로그램 공급업체의 경쟁을 막았다면서 Microsoft가 유죄를 선고받았다
- 그러나 오늘날 모바일 기기의 운영체제를 살펴보면 운영체제를 구성하는 기능의 수가 다시 증가하고 있음을 알 수 있다
- `모바일 운영체제`에는 핵심 `커널`뿐만 아니라 `미들웨어`(응용 프로그램 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크)도 포함된다

  - e.g. iOS, Android
    - 핵심 커널
    - 미들웨어
      - 데이터베이스, 멀티미디어, 그래픽 지원

- 요약

  - 운영체제에 포함되는 요소
    - 커널 : 항상 실행 중인 프로그램
    - 미들웨어 : 응용 프로그램 개발을 쉽게 하고 기능을 제공하는 프로그램
    - 시스템 프로그램 : 시스템 실행 중에 시스템을 관리하는데 도움이 되는 프로그램

- 본 교재의 대부분은 범용 운영체제의 커널과 관련이 있지만 운영체제 설계 및 연산을 모두 설명하는 데 필요한 다른 구성요소에 대해서도 설명한다

#### 왜 운영체제를 공부하는가?

- 컴퓨터 관련 산업에 종사하는 사람은 많지만 운영체제를 만들거나 수정하는 데는 소수의 사람만 참여한다
- 그렇다면 왜 운영체제와 그들의 작동방식을 공부하는가?
  - 단순하게 거의 모든 코드가 운영체제 위에서 실행되므로 `운영체제 작동방식에 대한 지식`은 `적절하고 효율적이고 효과적이며 안전한 프로그래밍`에 중요하기 때문이다
  - 운영체제의 기본 지식, 컴퓨터 하드웨어 구동 방식 및 응용 프로그램에 제공하는 내용을 이해하는 것은
    - 운영체제를 작성하는 사람들에게 필수적일 뿐만 아니라
    - 그 위에서 프로그램을 작성하고 운영체제를 사용하는 사람들에게도 매우 유용하다

## 1.2 컴퓨터 시스템의 구성(Computer system organization)

![그림1-2](./images_01/%EA%B7%B8%EB%A6%BC1-2.jpeg)

- 현대의 범용 컴퓨터 시스템
  - 하나이상의 `CPU`와 `구성요소`와 `공유 메모리` 사이의 액세스를 제공하는 공통 `버스`를 통해 연결된 여러 장치 컨트롤러로 구성된다
  - https://jongmin92.github.io/2019/02/18/Programming/computer-structure/

#### 장치 컨트롤러

- 각 장치 컨트롤러는 특정 유형의 장치를 담당한다
  - 컨트롤러에 따라 둘 이상의 장치가 연결될 수도 있다
  - e.g. 하나의 시스템 USB 포트는 여러 장치를 연결할 수 있는 USB 허브에 연결할 수 있다
  - 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적레지스터 집합을 유지관리한다
    - 버퍼 : 버퍼는 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역을 말합니다. 일시적으로 데이터를 보관하기 때문에 버퍼는 사용 후에 데이터를 폐기합니다.
      - 참고 : https://beenii.tistory.com/101
    - 레지스터 : 레지스터는 CPU가 요청을 처리하는 데이터의 임시저장 공간입니다. 공간은 작고 가격은 비싸지만 CPU에 직접 연결되어 있어 연산속도가 매우 빠릅니다.
      - 참고 : https://beenii.tistory.com/101
  - 장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다

#### 장치 드라이버

- 일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다
  - 장치 드라이버는 장치 컨트롤러의 작동을 잘 알고 있고 나머지 운영체제의 장치에 대한 일관된 인터페이스를 제공한다
  - CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다
  - 공유 메모리를 질서 있게 엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 엑세스를 동기화한다

#### 다음절에서

- 다음절에서 시스템의 세 가지 주요 측면에 중점을 두어 이러한 시스템의 작동방식의 기본 사항에 대해 설명한다
  - CPU의 조치가 필요한 이벤트에 대해 경고하는 인터럽트부터 살펴볼 것이다
  - 그런 다음 저장 장치 구조 및 입출력 구조에 대해 설명한다

### 1.2.1 인터럽트(Interrupts)

- 일반적인 컴퓨터 작업(입출력을 수행하는 프로그램)을 고려하자
- 입출력 작업을 시작하기 위해 `장치 드라이버`는 `장치 컨트롤러의 적절한 레지스터`에 `값을 적재`한다
- `장치 컨트롤러는` 이러한 `레지스터의 내용을 검사`하여 `수행할 작업을 결정`한다
  - e.g. 키보드에서 문자 읽기
- 컨트롤러는 `장치`에서 `로컬 버퍼로` `데이터 전송`을 시작한다
- 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다
- 그런 다음 장치 드라이버는 읽기 요청이면 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘긴다
- 다른 작업의 경우 장치 드라이버는 "쓰기 완료" 또는 "장치 사용 중"과 같은 상태 정보를 반환한다
- **그러나 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 어떻게 알리는가?**
  - 이는 `인터럽트를 통해` 이루어진다

#### 1.2.1.1 개요(Overview)

- 하드웨어는 어느 순간이든 시스템 버스를 통해 `CPU에 신호를 보내 인터럽트를 발생`시킬 수 있다
  - 컴퓨터 시스템에는 많은 버스가 있을 수 있지만 `시스템 버스`는 주요 `구성요소 사이의 주요 통신경로`이다
- `인터럽트`는 다른 많은 목적으로도 사용되며 `운영체제와 하드웨어의 상호 작용 방식`의 핵심 부분이다
- CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다
  - 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다
  - 그리고 인터럽트 서비스 루틴이 실행된다
  - 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다
- 이러한 연산의 시간을 일정(time line)이 그림 1.3에 있다

![그림1-3](./images_01/%EA%B7%B8%EB%A6%BC1-3.jpeg)

- 그림 1.3 출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정

- 인터럽트는 컴퓨터 구조의 중요한 부분이다
- 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다
- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다
  - 서비스 루틴
    - 인터럽트 고유 핸들러 호출
- 인터럽트는 매우 빈번하게 발생 -> 빠르게 처리되어야 함
  - 필요한 속도를 제공하기 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다
  - 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다
  - 일반적으로 포인터들의 테이블은 하위 메모리에 저장된다(첫 100개 정도의 위치)
    - 이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다
- 인터럽트가 요청되면 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 인터럽트 벡터가 인터럽트 요청과 함게 주어진 고유의 유일한 장치 번호로 색인된다

  - Windows나 Unix 같은 서로 다른 운영체제가 이러한 방법으로 인터럽트를 처리한다

- 인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다
  - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(e.g. 레지스터의 값을 변경하여)가 있다면
  - 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다
  - 인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것 처럼 다시 시작된다

#### 1.2.1.2 구현(Implementation)

![그림1-4](./images_01/%EA%B7%B8%EB%A6%BC1-4.jpeg)

- 그림 1.4 인터럽트-구동 방식의 입출력 사이클

- 기본 인터럽트 메커니즘은 다음과 같이 작동한다

  - CPU 하드웨어에는 인터럽트 요청 라인(interrupt request line)이라는 선이 있는데, 이는 하나의 명령어의 실행을 완료할 때마다 CPU가 이 선을 감지한다
  - CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을 감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 `인터럽트 핸들러 루틴`(interrupt-handler routine)으로 점프한다
  - 그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다
  - 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다
  - 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생(raise) 시키고 CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch - 보내다)하고 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear)
  - 그림 1.4는 인터럽트-구동 입출력 사이클을 요약한 것이다

- 방금 설명한 기본 인터럽트 기법은 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동깅 이벤트에 CPU가 대응할 수 있게 한다
- 그러나 최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다

  - 1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다
  - 2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다
  - 3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다

- 최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다
- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다
  - 하나는 복구 할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 마스크 불가능 인터럽트(nonmaskable interrupt)이다
  - 두 번째 인터럽트 라인은 마스킹 가능(maskable)이다.
    - 마스킹 가능한 인터럽트는 장치 컨트롤러가 서비스를 요청하기 위해 사용된다
  - 인터럽트 되어서는 안되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 꺼질 수 있다
- 벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이라는 것을 상기하자
  - 보충) 인터럽트 벡터가 인터럽트 요청과 함게 주어진 고유의 유일한 장치 번호로 색인된다 -> 1.3 참고
  - 그러나 실제로 컴퓨터에는 `인터럽트 벡터의 주소 개수`보다 `많은 장치(따라서 인터럽트 처리기)`가 있다
  - 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인을 사용`하는 것이다
  - 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다
  - 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다
    - 이러한 구조는 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안이다

![그림1-5](./images_01/%EA%B7%B8%EB%A6%BC1-5.jpeg)

- 그림 1.5 Intel 처리기 이벤트-벡터 테이블

- 그림 1.5는 Intel 프로세서의 인터럽트 벡터 설계를 보여준다

  - 마스크 불가능한 0에서 31까지의 이벤트는 다양한 오류 조건을 알리는 데 사용된다
  - 마스크 가능한 32에서 255까지의 이벤트는 장치가 생성한 인터럽트 같은 그 외 인터럽트를 처리하기 위해 사용된다
  - 인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현한다
  - 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다

- 요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다(다른 목적으로 사용되는 것에 관해서는 교재 전체에서 논의할 것임)
  - 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다
  - 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다
  - 인터럽트는 시간에 민감함 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요하다

### 1.2.2 저장장치 구조(Storage Structure)

![그림1-6](./images_01/%EA%B7%B8%EB%A6%BC1-6.jpeg)

- 그림 1.6 저장장치 계층 구조

- CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 한다
- 범용 컴퓨터는 프로그램 대부분을 메인 메모리(random-access memory, 또는 RAM이라 불린다 - 재기록 가능한 메모리)에서 가져온다
  - 메인 메모리는 dynamic random-access memory(DRAM)라 불리는 반도체 기술로 구현된다
- 컴퓨터는 다른 형태의 메모리도 사용한다
  - 예를 들어, 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은 부트스트랩 프로그램이며 운영체제를 적재한다
  - RAM은 휘발성(전원이 꺼지거나 손실될 대 내용이 손실됨)이므로 부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다
  - 대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 펌웨어(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다
  - EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다
    - 또한 속도가 느리므로 주로 사용되지 않는 정적 프로그ㅓ램과 데이터가 포함되어 있다
    - 예를 들어, iPhone은 EEPROM을 사용하여 장치의 일련 번호 및 하드웨어 정보를 저장한다
- 모든 형태의 메모리는 바이트의 배열을 제공한다
  - 각 바이트는 자신의 주소를 가지고 있다
  - 상호 작용은 특정 메모리 주소들에 대한 일련의 `적재(load)`, 또는 `저장(store)` 명령을 통하여 이루어진다
    - 적재 명령은 메인 메모리로 부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것이다
    - 저장 명령은 레지스터의 내용을 메인 메모리로 옮긴다
  - 명시적인 적재, 저장 명령 외에, `CPU는 프로그램 카운터에 저장된 위치부터` 실행하기 위해 `메인 메모리에서 명령을 자동으로 적재`한다

#### 폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클

- 먼저 `메모리로부터 명령을 인출`해,
- 그 명령을 `명령 레지스터(instruction register)에 저장`한다
- 이어서 `명령을 해독`하고,
- 이는 메모리부터 피연산자를 인출하여 `내부 레지스터에 저장`하도록 유발할 수 있다
- `피연산자에 대해 명령을 실행`한 후에 `결과`가 `메모리에 다시 저장`될 수 있다
- 메모리 장치는 단지 일련의 메모리 주소만을 인식한다는 사실에 유의하라
- 메모리는 이들 주소 - 명령 카운터(instruction counter), 색인(indexing), 간접 주소(indirection), 리터럴 주소(literal addresses) 등 - 가 어떻게 생성되었는지 알지 못하며,
- 그것이 무언인지(명령인지 데이터인지) 알지 못한다
- 그러므로 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있다
- 우리는단지 실행 중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다
- 이상적으로는 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다
- 그러나 이는 대부분의 시스템에서 두 가지 이유로 불가능하다
  - 1. 메인 메모리는 모든 필요한 프로그램과 데이터를 여구히 저장하기에는 너무 작다
  - 2. 메인 메모리는 이미 언급한 것 처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다
- 그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다
- 보조저장장치의 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다

#### 보조저장장치

- 가장 일반적인 보조저장장치는 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치로, 프로그램과 데이터 모두를 위한 저장소를 제공한다
- 대부분의 프로그램(시스템 및 응용 프고르램)은 메모리에 적재될 때까지 보조저장장치에 저장된다
- 그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다
- `보조저장장치`는 메인 메모리보다 훨씬 `느리다`
  - 따라서 11장에서 논의할 것처럼, 2차 저장장치의 올바른 관리는 컴퓨터 시스템에서 가장 중요하다

#### 그 외 저장장치

- 그러나 더 큰 의미에서 레지스터, 메인 메모리 및 보조저장장치로 구성된 `저장장치구조`는 가능한 많은 `저장장치 시스템 설계 중 하나`일 뿐이다
- 다른 가능한 구성요소로
  - 캐시 메모리, CD-ROM 또는 Blu-ray, 자기 테이프 등이 있다
  - 다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수목적으로만 사용하기에 `매우 느리고 충분히 큰 장치`를 `3차 저장장치`라고 한다
  - 각 저장장치 시스템은 데이터를 저장하고 나중에 검색될 때까지 해당 데이터를 유지하는 기본 기능을 제공한다
  - 다양한 저장장치 시스템 간의 주요 차이점은 속도, 크기 및 휘발성에 있다
- 다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다(그림1.6)
  - 일반적으로 크기와 속도 사이에는 상충하는 측면이 있어서 메모리가 작고 빠를 수록 CPU에 더 가깝다
  - 그림에서 볼 수 있듯이 속도와 용량의 차이 외에도 다양한 저장장치 시스템은 휘발성 또는 비휘발성이다
  - 앞에서 ㅇ언급했듯이 휘발성 저장장치는 장치의 전원이 제거될 때 내용을 잃어버리므로 안전하게 보관하기 위해 데이터를 비휘발성 장치에 기록해야 한다
- 그림1.6 에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 반도체 메모리를 사용하여 구성된다
  - 네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다
  - NVM장치의 가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리다
  - 점차 랩톱, 데스크톱과 서버에서 장기 저장ㅊ에도 플래시 메모리가 사용되고 있다
  - 자장장치는 운영체제 구조에서 중요한 역할을 하기 때문에 교재에서 자주 참조할 것이다
  - 일반적으로 다음 용어를 사용할 것이다
    - `휘발성 저장장치`는 단순히 `메모리`라고 할 것이다. 특정 유형의 저장장치(예: 레지스터)를 강조해야 하는 경우 명시적으로 표현할 것이다
    - `비휘발성 저장장치`는 전원이 꺼졌을 때 내용을 유지한다. 이를 NVS(Non-Volatile Storage)라고 한다.
      - 대부분의 경우 NVS는 보조저장장치를 가리킨다
      - 이 유형의 저장장치는 다음 두 가지 유형으로 분류될 수 있다
        - 1. 기계적
          - 이러한 저장장치 시스템에는 몇 가지 예는 HDD, 광 디스크, 홀로그램 저장장치 및 자기 테이프이다
          - 특정 유형의 기계식 저장장치(예: 자기 테이프를) 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다
        - 2. 전자적
          - 이러한 저장장치 시스템의 몇 가지 예는 플래시 메모리, FRAM, NRAM 및 SSD이다
          - 전기적 저장장치는 NVM으로 언급될 것이다
          - 특정 유형의 전기적 저장장치(예: SSD)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다
        - 기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다
          - 반대로, 전기적 저장장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다
- 완전한 저장장치 시스템 설계는 방금 논의한 모든 요소의 균형을 맞추어야 한다
  - 가능한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에 필요한 만큼만 비싼 메모리를 사용해야 한다
  - 캐시는 두 구성요소 간에 액세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다

### 1.2.3 입출력 구조(I/O Structure)

![그림1-7](./images_01/%EA%B7%B8%EB%A6%BC1-7.jpeg)

- 그림1.7 현대 컴퓨터의 작동방식

- 운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치에 다양한 특정으로 인해 I/O 관리에 할애된다
- 이 절의 시작 부분에서 시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터라는 점을 상기하라
- 1.2.1절에 설명된 인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 `NVS I/O와 같은 대량 데이터 이동`에 사용될 때 높은 `오버헤드를 유발`할 수 있다
  - 이 문제를 해결하기 위해 `직접 메모리 엑세스(DMA)`가 사용된다
  - 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로 부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다
  - 속도가 느린 장치처럼 `한 바이트`마다 인터럽트가 발생하는 것이 `아니라` `블록 전송이 완료될 때마`다 `인터럽트가 발생`한다
  - 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다
- 몇몇 고가의 시스템은 버스 대신에 `스위치구조`를 사용한다
  - 이러한 시스템에서는 공유 버스를 사용하기 위한 사이클을 경쟁하지 않고 `다수의 구성요소가 다른 구성요소들과 동시에 통신`하는 것이 가능하다
  - 이 경우 DMA(직접 메모리 엑세스)의 사용은 더욱 효과적이다
  - 그림 1.7은 컴퓨터 시스템의 구성요소 간의 상호 작용을 보여준다

## 1.3 컴퓨터 시스템 구조(Computer System Architecture)

- 1.2절에서 전형적인 컴퓨터 시스템의 일반적인 구조를 소개하였다
- 컴퓨터 시스템은 사용된 범용 처리기(Processor)의 수에 따라 분류 가능한 다양한 방식으로 구성될 수 있다

### 1.3.1 단일 처리기 시스템(Single-Processor System)

- 몇 년전, 대부분의 컴퓨터 시스템은 단일 처리 코어를 가진 하나의 CPU를 포함하는 단일 프로레서를 사용했다
- 코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소이다
- 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다
- 이 시스템에는 다른 특수 목적 프로세서도 있다
  - 디스크, 키보드 및 그래픽 컨트롤러와 같은 장치별 프로세서 형태로 제공될 수도 있다
- 이 모든 전용 처리기(다른 특수 목적 프로세서 - 키보드, GPU 등)들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지는 않는다
  - 때로 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다
    - 예를들면, `디스크 컨트롤러 마이크로프로세서`는 `주 CPU로 부터` `연속된 요청을 받아들여`, `자기 고유의 디스크 큐`와 `스케줄링 알고리즘을 구현`한다
      - 이 배합(이것저것을 일정한 비율로 한데 섞어 합침)은 CPU가 직접 디스크 스케줄링을 해야 하는 오버헤드를 감소시킨다
  - PC의 키보드는 키스트로크를 CPU에 전송할 코드로 변환하는 마이크로프로세서를 가지고 있다
  - 다른 시스템 또는 환경에서는 전용 처리기가 하드웨어로 구현되는 저수준의 구성요소이다
- 운영체제는 이 처리기들과 통신할 수 없으며 이 처리기들은 독립적으로 자신의 작업을 처리한다
- 전용 마이크로 프로세서의 사용은 일반적인 형태이며 그렇다고 단일 처리기 시스템을 다중 처리기 시스템으로 변환하지는 않는다
- 단일 처리 코어를 가진 범용 CPU가 하나만 있는 경우 시스템은 단일 프로세서 시스템이다
  - 그러나 이 정의에 따르면, 현대 컴퓨터 시스템은 단일 프로세서 시스템이 거의 없다

### 1.3.2 다중 처리기 시스템(Multiprocessor System)

- 모바일 장치에서 서버에 이르기까지 최신 컴퓨터에서는 다중 처리기 시스템이 컴퓨팅 환경을 지배하고 있다.
- 일반적으로 이러한 시스템에는 각각 단일 코어 CPU가 있는 두 개 이상의 프로세서가 있다
- 프로세서의 컴퓨터 버스 및 때때로 클록, 메모리 및 주변 장치를 공유한다
- 다중 처리기 시스템의 주요 장점은 처리량 증가이다
- 즉, 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 처리할 수 있다
- 그러나 N 프로세서의 속도향상 비율은 N이 아니다

  - 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하게 유지하는 데 일정한 양의 오버헤드가 발생한다
  - 이 오버헤드와 공유 자원에 대한 경합은 추가 프로세서의 예상 이득을 낮춘다

#### SMP(Symmetric Multiprocessing)

- 가장 일반적인 다중 처리기 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는 SMP(symmetric multiprocessing)를 사용한다
  - symmetric : 대칭적인, 균형잡힌

![그림1-8](./images_01/%EA%B7%B8%EB%A6%BC1-8.jpeg)

- 그림 1.8 대칭형 다중 처리 구조

- 그림 1.8은 각각 자체 CPU를 가지는 두 개의 프로세서가 있는 일반적인 SMP 구조를 보여준다
  - 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라 자체 레지스터 세트가 있다 그러나 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다
- 이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는 것이다

  - N개의 CPU가 있으면 성능을 크게 저하하지 않으면서 N개의 프로세스를 실행할 수 있다
  - 그러나 CPU가 독립적이기 때문에 하나는 유휴상태이고 다른 하나는 과부하가 걸려 비효율적일 수 있다
  - 프로세서가 `특정 자료구조를 공유`하는 경우 이러한 비효율성을 피할 수 있다
  - 이 (특정 자료구조를 공유하는)형식의 다중 처리기 시스템을 사용하면
    - 프로세스 및 메모리와 같은 자원을 다양한 프로세서 간에 동적으로 공유할 수 있으며,
    - 프로세서 간의 작업 부하 분산을 낮출 수 있다
    - 이러한 시스템은 5장과 6장에서 볼 수 있듯이 신중하게 작성해야 한다

- 다중 처리기의 정의는 시간이 지남에 따라 발전해 왔으며, 이제는 `여러 개의 컴퓨팅 코어`가 `단일 칩에 상주`하는 다중 코어 시스템을 포함한다
  - 칩 내 통신이 칩 간 통신보다 빠르므로 다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적일 수 있다
  - 또한 여러 개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용하는데, 이는 노트북뿐만 아니라 모바일 장치의 중요한 문제이다

![그림1-9](./images_01/%EA%B7%B8%EB%A6%BC1-9.jpeg)

- 그림 1.9 하나의 칩에 두 개의 코어를 가지는 이중-코어 설계

- 그림 1.9에서는 같은 프로세서 칩에 두 개의 코어를 가지는 이중 코어 설계를 보여준다
  - 이 설계에서 각 코어에는 자체 레지스터 세트와 레벨1(L1) 캐시라고도 하는 자체 로컬 캐시가 있다
  - 또한 레벨2(L2) 캐시는 칩에 국한되지만 두 처리 코어에서 공유한다.
  - 아키텍처 대부분은 로컬 및 공유 캐시를 결합한 이 접근 방식을 채택한다
  - 로컬 하위 레벨 캐시는 일반적으로 상위 레벨 공유 캐시보다 작고 빠르다
  - 캐시, 메모리 및 버스 경합과 같은 아키텍처 고려 사항 외에도 N코어를 가지는 다중 코어 프로세서는 운영체제에 N개의 CPU 처럼 보인다
  - 이러한 특성은 운영체제 설계자 및 응용 프로그램 프로그래머에게 이러한처리 코어를 효율적으로 사용하는 코드를 개발하도록 압박한다
    - 이러한 쟁점은 4장에서 다룰 것이다
  - Windows, macOS 및 Linux를 포함한 거의 모든 최신 운영체제는 물론 Android 및 iOS 모바일 시스템도 다중 코어 SMP 시스템을 지원한다
  - 다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상된다
    - 그러나 앞에서 제한한 것 처럼 이러한 개념은 그다지 확장성이 좋지 않고, CPU를 너무 많이 추가하면 시스템 버스에 대한 경합이 병목 현상이 되어 성능이 저하되기 시작한다

#### NUMA(Non-Uniform Memory Access)

![그림1-10](./images_01/%EA%B7%B8%EB%A6%BC1-10.jpeg)

- 그림 1.10 NUMA 다중 처리 구조

- 다른 방법은 각 CPU(또는 CPU그룹)에 작고 빠른 로컬 버스를 통해 액세스 되는 자체 로컬 메모리를 제공하는 것이다
  - 모든 CPU가 공유 시스템 연결로 연결되어 모든 CPU가 하나의 물리 주소 공간을 공유한다
  - NUMA(non-uniform memory access)라고 하는 이 방법은 그림 1.10에 도시되어 있다
  - 장점은 CPU가 로컬 메모리에 액세스 할 때 빠를 뿐만 아니라, 시스템 상호 연결에 대한 경합도 없다는 것이다
  - 따라서 NUMA 시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다
- NUMA 시스템의 잠재적 단점은 CPU가 시스템 상호 연결을 통해 원격 메모리에 액세스해야 할 때 지연 시간이 증가하여 성능 저하가 발생할 수 있다는 것이다
  - 즉, 예를 들어 CPU0은 자체 로컬 메모리에 액세스 할 수 있는 만큼 빠르게 `CPU3의 로컬 메모리에 액세스` 할 수 없어 `성능이 저하`된다
    - 5.5.2절과 10.5.4절에서 논의된 것 처럼 운영체제는 `신중한 CPU 스케쥴링` 및 `메모리 관리`를 통해 이 `NUMA의 단점을 최소화`할 수 있다
- NUMA 시스템은 많은 수의 프로세서를 수용할 수 있도록 확장할 수 있으므로 고성능 컴퓨팅 시스템 뿐만 아니라 서버에서도 점점 인기를 얻고 있다

#### PC 마더보드

- 아래에 표시된 프로세서 소켓이 있는 데스크톱 PC 마더보드를 고려하자

![그림-PC마더보드](./images_01/%EA%B7%B8%EB%A6%BC-PC%EB%A7%88%EB%8D%94%EB%B3%B4%EB%93%9C.jpeg)

- 이 보드는 슬롯이 채워지면 온전히 작동하는 컴퓨터이다
- CPU를 포함하는 프로세서 소켓, DRAM 소켓, PCIe 버스 슬롯 및 다양한 유형의 I/O 커넥터로 구성된다
- 가장 저렴한 범용 CPU조차도 여러 개의 코어를 포함한다
- 일부 마더보드네은 여러 개의 프로세서 소켓이 있다
- 고급 컴퓨터 일수록 둘 이상의 시스템 보드를 허용하여 NUMA 시스템을 형성한다

#### 블레이드 서버

- 마지막으로 블레이드 서버는 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 섀시(chassis)안에 장착되는 형태를 가진다
- 블레이드 서버와 전통적인 다중 처리기 시스템과의 차이점은 각 블레이드-처리기 보드는 독립적으로 부팅될 수 있고 자기 자신의 운영체제를 수행한다는 것이다
- 어떤 블레이드-서버 보드는 자체가 다중 처리기이기도 하며 이 사실은 컴퓨터 유형 간의 경계를 모호하게 만든다
- 근본적으로 이 블레이드 서버는 여러 독립적인 다중 처리기 시스템으로 구성된다

### 1.3.3 클러스터형 시스템(Clustered System)

- 여러 CPU를 가진 시스템의 또 다른 유형은 클러스터형 시스템이다
  - 클러스터 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 굿어한다는점이 1.3.2절에서 설명한 다중 처리기 시스템과 차이가 난다
  - 각 노드는 통상 다중 코어 시스템이다
  - 이런 시스템은 약결합(loosely coupled)이라고 간주된다
  - 클러스터형(clustered)의 정의는 분명하지 않다. 만ㅎ은 상업용 패키지와 공개 소스 패키지들은 클러스터 시스템을 정의하고 왜 한 형태가 다른 형태보다 좋은지에 대한 문제에 답을 제시하는 데 어려움을 겪고 있다
  - 거리 통신망(local area network, LAN)이나 InfiniBand와 같은 고속의 상호 연결망(interconnect)으로 연결된다
- 클러스터링은 통상 높은 가용성(availability)을 제공하기 위해 사용된다
  - 즉, 클러스터 내 하나 이상의 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공된다
  - 일반적으로 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다
  - 클러스터 소프트웨어중 한 층이 클러스터 노드에서 실행된다
  - 각 노드는 하나 이상의 다른 노드(네트워크로 연결되어 있는)들을 감시한다
  - 만일 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받고, 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다
  - 사용자와 응용 프로그램의 클라이언트는 잠깐의 서비스 중단만을 경험하게 된다
  - 높은 가용성은 안정성을 향상해 많은 응용 프로그램에서 중요하다
  - 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능을 우하한 성능 저하(graceful degradation)라고 한다
  - 시스템의 정상적인 성능 저하를 넘어 단일 구성요소에 오류가 발생하여도 계속 작동할 수 있도록 결함허용 시스템이라고 한다
  - 결함허용에는 장애를 감지, 진단 및 가능한 경우 수정할 수 있는 기법이 필요하다
- 클러스터링은 비대칭적으로 구성될 수 있다
  - 비대칭형 클러스터링에서는 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 긴급대기(hot-standby) 모드 상태를 유지한다
  - 이 긴급 대기 모드의 호스트는 활성 서버들을 감시하는 작업만을 수행한다
  - 서버가 고장낱ㄴ다면 긴급 대기 모드의 호스트가 활성 서버가 된다
  - 대칭형 클러스터링에서는 둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시한다
  - 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적이다
  - 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행가능해야 한다
- 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다
  - 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로 단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공할 수 있다
  - 그렇지만 응용이 클러스터를 이용할 수 있도록 작성되어야 한다
  - 이는 `병렬화`라는 기법으로 프로그램을 컴퓨터의 개별 코어에서 혹은 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함한다
  - 전형적으로 이들 응용은 클러스터의 각 계산 노드가 문제 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 해답을 얻게 된다
- 다른 형태의 클러스로 병렬(parallel) 클러스터와 WAN을 이용한 클러스터링이 있다
  - 병렬 클러스터는 여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 한다
  - 운영체제의 대부분이 여러 호스트에 의한 이러한 동시 접근을 지원하지 않으므로 병렬 클러스터는 특수 소프트웨어 버전과 특별히 발매된 응용으로 달성한다
  - 예를 들면, Oracle Real Application Cluster는 병렬 클러스터에서 수행하도록 설계된 Oracle의 데이터베이스 버전이다
  - 각 기계는 Oracle을 수행하고 하나의 소프트웨어 층이 공유 된 디스크에 대한 접근을 관리한다
  - 각 기계는 데이터베이스 내의 모든 데이터에 대한 완전한 접근을 한다
  - 데이터에 대한 공유 접근을 제공하기 위하여, 시스템은 접근 간의 충돌이 발생하지 않는 것을 보장하기 위하여 접근 제어와 잠금 기법을 제공해야 한다
    - 분산 잠금 관리자(distributed lock manager, DLM)라고 불리는 이 기능은 몇몇의 클러스터 기술에 포함되어 있다
- 클러스터 기술은 급변하고 있다
  - 어떤 클러스터 제품은 수 킬로미터 떨어진 클러스터 노드들뿐 아니라 한 클러스터 안에서 수천개의 노드를 지원한다
    - 이러한 개선은 11.7.4에서 설명될 스토리지 전용 네트워크(storage-area network, SAN)에 의해 가능해졌다
    - SAN은 여러 호스트를 여러 저장장치에 부착할 수 있게 한다
    - 만일 응용과 데이터가 SAN에 저장 된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 응용을 배정할 수 있다
    - 호스트가 고장 나면 다른 호스트가 그 응용을 넘겨받는다
    - 데이터베이스 클러스터에서는 수십 개의 호스트가 동일한 데이터베이스를 공유할 수 있기 때문에 성능과 신뢰도를 매우 증가시키게 된다
    - 그림 1.11은 클러스터 시스템의 일반 구조를 보인다

![그림1-11](./images_01/%EA%B7%B8%EB%A6%BC1-11.jpeg)

- 그림 1.11 클러스터 시스템의 일반적인 구조

## 1.4 운영체제의 작동(Operating System Operations)

- 컴퓨터 시스템 구성 및 아키텍처에 대한 기본 정보를 살펴보았으므로 이제 운영체제에 대해 이야기할 준비가 되었다
  - `운영체제`는 `프로그램이 실행`되는 `환경을 제공`한다
- 컴퓨터의 전원을 켜거나 재부팅 할 때와 같이 `컴퓨터를 실행`하려면 `초기 프로그램을 실행`해야 한다
  - 초기 프로그램 또는 부트스트랩 프로그램은 단순한 형태를 띠는 경향이 있다
  - 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다
- CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기 까지 시스템의 모든 측면을 초기화 한다
- 부트스트랩 프로그램은 운영체제를 적재하는 방법과 시스템 실행을 시작하는 방법을 알아야 한다
  - 이 목표를 달성하려면 `부트스트랩 프로그램`이 `운영체제 커널을 찾아` `메모리에 적재`해야 한다
- 커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다
- 일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 `시스템 데몬`이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 `커널 외부에서 제공`된다
- Linux에서 첫 번째 시스템 프로그램은 "systemd"이며 다른 많은 데몬을 시작한다
  - 이 단계가 완료되면 시스템은 완전히 부팅되고 시스템은 어떤 이벤트가 발생할 때까지 기다린다
  - 실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없는 경우 운영체제는 조용히 앉아 무언가가 발생할 때까지 기다린다
- 이벤트는 거의 항상 인터럽트를 발생시켜 신호를 보낸다
  - 또 다른 형태의 인터럽트는 `트랩(또는 예외)`으로, 오류(e.g. 0으로 나누거나 유효하지 않은 메모리 액세스) 또는 사용자 프로그램의 특정 요청 때문에 발생하는 소프트웨어 생성 인터럽트이다
    - 이 특정 요청은 `시스템 콜이라는 특수 연산을 실행`하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다
      - 시스템 콜 예시 추측) 부팅 시 0x123456 에 접근할 수 없습니다 같은 경고창 뜨는 것
        - https://m.blog.naver.com/jh4l2656/70109548466

### 1.4.1 다중 프로그래밍과 다중 태스킹(multiprogramming and multitasking)

- 운영체제의 가장 중요한 측면 중 하나는 하나의 프로그램은 일반적으로 항상 CPU나 I/O 장치를 항상 바쁘게 유지할 수 없으므로
  - 여러 프로그램을 실행할 수 있다는 것이다
- 또한 사용자는 일반적으로 한 번에 둘 이상의 프로그램을 실행하려고 한다
- `다중 프로그래밍`은 CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다
  - 다중 프로그램 시스템에서 실행 중인 프로그램을 `프로세스`라고 한다

![그림1-12](./images_01/%EA%B7%B8%EB%A6%BC1-12.jpeg)

- 그림 1.12 다중 프로그래밍 시스템을 위한 메모리 배치

- 운영체제는 여러 프로세스를 동시에 메모리에 유지한다
  - 운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 시작한다
  - 결국 프로세스는 I/O 작업과 같은 일부 작업이 완료되기를 기다려야 할 수도 있다
  - 다중 프로그래밍 되지 않은 시스템에서는 CPU가 유휴 상태일 수 있다
  - 다중 프로그램 시스템에서 운영체제는 단순히 다른 프로세스로 전환한다
  - 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다
  - 하나 이상의 프로세스를 실행해야 하는 한 CPU는 유휴 상태가 아니다
- 이 아이디어는 다른 일상생활에서도 흔히 볼 수 있다
  - 변호사는 한 번에 단지 한 사람의 의뢰인만 상대하는 것이 아니다
  - 한 사건이 재판을 기다리거나 문서 작성을 기다릴 동안, 변호사는 또 다른 사건을 처리할 수 있다
  - 만일 변호사가 충분히 많은 의뢰인을 확보하고 있다면 변호사가 일이 없어서 쉬는 일은 발생하지 않는다
- 멀티 태스킹(multitasking)은 다중 프로그래밍의 논리적 확장이다

  - 멀티 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공하게 된다
  - 프로세스가 실행될 때 일반적으로 프로세스가 완료되거나 I/O를 수행하기 전에 짧은 시간 동안만 실행된다
  - 입출력은 대화식일 수 있다
    - 즉, 출력이 사용자를 위해 디스플레이되고, 인력은 사용자 키보드, 마우스 또는 터치스크린으로 부터 들어온다
  - 이런 대화식 입출력은 전형적으로 사람의 속도로 수행되므로, 완료 시 까지 상당히 긴 시간이 걸릴 수 있다
  - 예를 들면 입력은 사용자의 타이핑 속도에 제한을 받으며, 사람에게는 1초에 7문자가 빠른편이지만, 컴퓨터에겐 아주 느린 것이다
  - 이러한 대화식 입력이 진행되는 동안 CPU를 쉬게 하지 않고 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다

- 동시에 여러 프로세스를 메모리에 유지하려면 9장과 10장에서 다루는 `메모리 관리 방식`이 필요하다
- 또한 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 다음에 실행할 프로세스를 선택해야 한다
  - 이 결정을 내리는 것은 5장에서 논의될 `CPU 스케줄링`이다
- 마지막으로 여러 프로세스를 병행하게 실행하려면 `프로세스 스케줄링`, `디스크 저장장치 및 메모리 관리`를 포함하여 운영체제의 모든 단계에서 `서로 영향을 미치는 기능이 제한`되어야 한다
  - 이 책 전반에 걸쳐 논의한다
- 다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다

  - 적절한 응답 시간을 보장하는 더 일반적인 방법은 `가상 메모리(virtual memory)`인데, 이것은 `일부만 메모리에 적재된 프로세스의 실행`을 허용하는 기법이다(10장)

    - 가상 메모리 : 실제 주기억 장치보다 큰 메모리 영역을 제공하는 방법으로 사용

      - https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC

    - 이 기법의 주요한 이점은 프로그램이 물리 메모리의 크기보다 더 커도 된다는 것이다
    - 가상 메모리는 메인 메모리를 물리 메모리로부터 분리시킨다
    - 이러한 기법은 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해준다

- 다중 프로그래밍 및 다중 태스킹 시스템도 파일 시스템을 제공해야 한다(13 ~ 15장)
  - 파일 시스템은 보조 저장장치에 존재한다
  - 따라서 저장장치 관리가 제공되어야 한다(11장)
  - 또한 시스템은 부적절한 사용으로부터 자원을 보호해야 한다(17장)
  - 질서 있게 실행하려면 시스템은 프로세스 동기화 및 통신을 위한 기법을 제공해야 하며(6장 및 7장)
  - 프로세스가 서로를 영원히 기다리는 교착 상태에 빠지지 않도록 보장해야 한다(8장)

### 1.4.2 이중-모드와 다중모드 운용(Dual-mode and multimode operation)

- 운영 체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게 설계된 운영체제는 잘못된(또는 악의적인) 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 없도록 보장해야 한다
  - 시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자-정의 코드 실행을 구분할 수 있어야 한다
  - 대부분의 컴퓨터 시스템이 취하는 접근 방식은 다양한 실행 모드를 차별화 할 수 있는 하드웨어 지원을 제공하는 것이다

![그림1-13](./images_01/%EA%B7%B8%EB%A6%BC1-13.jpeg)

- 그림 1.13 사용자 모드에서 커널 모드로의 전환

- 적어도 두 개의 독립된 연산모드, 즉 `사용자 모드`와 `커널 모드`를 필요로 한다

  - 커널모드 : 수퍼바이저 모드, 시스템 모드, 또는 특권 모드(privileged mode) 라고도 부른다
  - 모드 비트(mode bit)라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다
  - 이 비트는 커널 모드(0) 또는 사용자 모드(1)를 나타낸다
  - 컴퓨터 시스템이 `사용자 응용을 위해 실행` 될 때 -> 시스템은 `사용자 모드`에 있게 된다
  - 그러나 사용자 응용(user application)이 `운영체제로 부터 서비스를 요청`하면(시스템 콜을 통함)
    - 이 요청을 수행하기 위해 사용자 모드에서 `커널 모드로 전환`해야 한다

- 시스템 부트 시, 하드웨어는 커널 모드에서 시작한다

  - 이어 운영체제가 적재(load)되고, 사용자 모드에서 사용자 프로세스가 시작된다
  - 트랩이나 인터럽트가 발생할 때마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다(즉, 모드 비트를 0으로 변경)
  - 그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다
  - 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드(모드 비트를 1로 설정)로 전환한다

- 동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호하는 방법을 우리에게 제공한다

  - 우리는 악영향을 끼칠 수 있는 일부 명령을 특권 명령(privileged instruction)으로 지정함으로써 이러한 보호를 달성한다
  - 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다
  - 사용자 모드에서 특권 명령을 수행하려고 시도하면, 하드웨어는 이를 실행하지 않고, 불법적인 명령으로 간주해 운영체제로 트랩을 건다
  - 내 생각) sudo를 붙이는 것이 특권 명령에 대한 권한을 부여하는 것이 아닐까?

- 커널 모드로 전환하는 명령어가 특권 명령어의 예이다

  - 다른 예로는 I/O 제어, 타이머 관리 및 인터럽트 관리가 있다
  - 이 책 전반에 걸쳐 많은 다른 특권 명령이 논의 된다

- 모드의 개념은 두 가지 모드 이상으로 확장될 수 있다

  - 예를 들어, Intel 프로세서에는 4개의 분리된 보호 링이 있다
    - 여기서 링 0은 커널 모드이고 링 3은 사용자 모드이다
      - 링 1과 2는 다양한 운영체제 서비스에 사용되러 수 있지만 실제로는 거의 사용되지 않는다
  - ARMv8 시스템에는 7가지 모드가 있다
    - 가상화를 지원하는 CPU(18.1절)는 종종 VMM(virtual machine manager)이 시스템을 제어하는 시점을 표시하기 위한 별도의 모드를 가진다
      - 이 모드에서 VMM은 사용자 프로세스보다 많은 권한을 가지지만 커널 보다는 적은 권한을 가진다
      - 가상 머신을 생성 및 관리할 수 있으려면 이 레벨의 권한이 필요하고 CPU 상태를 변경하여 해당 작업을 수행할 수 있다

- 우리는 이제 컴퓨터 시스템에서 명령어 실행의 수명주기를 더 잘 이해할 수 있다
  - `초기 제어는 운영체제에` 있으며, 여기서 `명령은 커널 모드에서` 실행된다
  - `사용자 응용 프로그램`에 제어가 넘어가면 `모드는 사용자로` 설정된다
  - 결국 인터럽트, 트랩 또는 시스템 콜을 통해 제어가 운영체제로 다시 전환된다
  - Windows, Unix 및 Linux와 같은 대부분 최신 운영체제는 이러한 이중 모드 기능을 활용하고 운영체제를 보다 강력하게 보호한다
- 시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에 요청할 수 있는 방법을 제공한다
  - 시스템 콜은 일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취한다
  - 이 트랩은 보통의 trap 명령어를 통해 수행되지만 몇몇 시스템은 syscall 이라는 특정 명령어를 가지기도 한다
- 시스템 콜이 수행될 때, 시스템 콜은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다

  - 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다
  - 시스템 콜 서비스 루틴은 운영체제의 일부이다
  - `커널`은 `인터럽트를 발생시킨 명령을 검사`하여 `어떤 시스템 콜이 발생했는지를 결정`한다
  - 이때 전달된 인수(parameter(?))가 사용자 프로그램이 요청하는 서비스 유형을 표시한다
  - 요청이 필요로 하는 추가의 정보는 레지스터, 스택 또는 메모리로(이때는 메모링 위치에 대한 포인터가 레지스터에 전달된다) 전달될 수 있다
  - 커널은 인수(parameter)가 정확하고 합법적인지를 검증하고 요청을 수행한 후 제어를 시스템 콜 다음의 명령으로 복귀한다
    - 2.3절에서 시스템 콜에 대해 더 자세히 설명한다

- 하드웨어 보호 기능이 제공되면 모드 규칙을 위반하는 오류가 하드웨어에 의해 탐지된다
  - 이러한 오류는 일반적으로 운영체제가 처리한다
  - 사용자 프로그램이 불법적인 명령을 수행하려 하거나 사용자 주소 공간이 아닌 메모리에 접근을 시도하는 등과 같은 오류가 발생하면ㅣ, 하드웨어는 운영체제로 트랩을 발생시킨다
  - 트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘긴다
  - 프로그램 오류가 발생할 때 마다, 운영체제는 비정상적으로 프로그램을 종료시킨다
  - 이것은 사용자가 요청한 비정상적인 종료와 동일한 코드에 의해 처리된다
  - 적절한 오류 메시지가 주어지며, 프로그램의 메모리가 덤프된다
    - 메모리 덤프는 사용자나 프로그래머가 이를 조사하고, 프로그램을 수정하여 다시 실행시킬 수 있도록 통상 파일에 기록된다

### 1.4.3 타이머(timer)

- 우리는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다
  - 사용자 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 반드시 방지해야 한다
  - 이러한 목적을 달성하기 위해, 타이머(timer)를 사용할 수 있다
  - 타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정할 수 있다
  - 이 시간은 고정(e.g., 1/60초), 혹은 가변(e.g., 1ms ~ 1s)일 수 있다
  - 가변 타이머는 일반적으로 고정률의 클록(fixed-rate clock)과 계수기로 구현한다
  - 운영체제는 계수기 값을 설정한다
  - 클록이 똑딱(tick)할 때 마다 계수기가 감소한다
  - 계수기가 0이 될 때 인터럽트가 발생한다
  - 예를 들면, 1ms 클록의 10비트 계수기는 1ms 단위로 1ms에서 1,024ms 사이의 간격을 갖는 인터럽트를 허용한다
- 사용자에게 제어를 양도하기 전에, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지를 확인한다
  - 만약 타이머가 인터럽트를 발생하면 제어는 자동으로 운영체제에 넘어가며,
    - 운영체제는 인터럽트를 치명적인 오류로 취급하거나, 또는 프로그램에게 더 많은 시간을 줄 수 있다
  - 타이머 값을 변경하는 명령은 특권 명령이다

## 1.5 자원 관리(resource management)

- 앞에서 본 것처럼 `운영체제`는 `자원 관리자`이다
  - 시스템의 CPU, 메모리 공간, 파일-저장 공간 및 I/O 장치는 운영체제가 관리해야 하는 자원에 속한다

#### Linux 타이머

- Linux 시스템에서 커널 구성 매개변수 HZ는 타이머 인터럽트의 발생 빈도를 지정한다
  - 250HZ값은 타이머가 초당 250개의 인터럽트를 생성하거나 4ms마다 1개의 인터럽트를 발생하는 것을 의미한다
  - HZ의 값은 커널이 구성되는 방법과 커널이 실행되는 시스템 유형 및 아키텍처에 따라 다르다
  - 관련된 커널 변수는 jiffies이며 시스템 부팅 이후 발생한 타이머 인터럽트 개수를 나타낸다
  - 2장의 프로그래밍 프로젝트는 Linux 커널에서의 타이밍을 더 탐구한다

### 1.5.1 프로세스 관리(process management)

- 프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수 없다

  - 언급한 바와 같이 `실행 중인 프로그램`은 `프로세스`이다
  - PC에서 개별 사용자가 실행하는 문서편집 프로그램은 프로세스이다
  - 마찬가지로 모바일 장치 소셜 미디어 앱도 프로세스이다
  - 지금은 `프로세스`가 `실행 중인 프로그램의 인스턴스`라고 생각할 수 있지만 `나중에` 개념이 `더 일반적이라는 것을 알게 될 것`이다
  - 3장에서 설명한 대로 `프로세스가 서브프로세스를 작성`하여 `병행하게 실행할 수 있도록 하는 시스템 콜을 제공`할 수 있다

- `프로세스`는 자기 일을 수행하기 위해 CPU 시간, 메모리, 파일, 그리고 입출력 장치를 포함한 `여러 가지 자원을 필요`로 한다

  - 이러한 자원은 보통 실행되는 동안 할당된다
  - 프로세스가 생성될 때 획득하는 여러 가지 물리적 논리적 자원 외에, 여러 초기화 데이터(입력)도 아울러 전달될 수도 있다
  - 예를 들어, 웹 페이지의 내용을 화면에 표시하는 기능을 가진 웹 브라우저를 실행하는 프로세스를 고려하자
    - 프로세스는 URL을 입력으로 제공받으며 적절한 명령과 시스템 콜을 실행하여 원하는 정보를 얻고 화면에 표시한다
      - 내 생각) 링크 클릭 시 브라우저가 실행되면서 해당 URL로 이동하는 것 같다
    - 프로세스가 종료되면 운영체제는 재사용 가능한 자원을 회수한다

- 우리는 프로그램 그 자체는 프로세스가 아님을 강조한다

  - 즉, 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적(passive) 개체지만
    - 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터(program counter)를 가진 능동적(active)인 개체이다
    - 스레드는 4장에서 설명한다
  - 한 프로세스의 수행은 반드시 순차적이어야 한다
    - CPU는 그 포로세스가 끝날 때까지 그 프로세스의 명령들을 차례대로 수행한다
    - 게다가, 어느 한순간에는 그 프로세스를 위해 하나의 명령만 수행된다
    - 따라서 `두 개의 프로세스가 동일한 프로그램`과 연관되어 있더라도, 그들은 `두 개의 별도의 수행 순서로 간주`된다
    - 다중 스레드 프로세스는 여러 개의 프로그램 카운터를 가지고 있으며
      - 이 카운터들은 각 스레드가 실행할 다음 명령어를 가리키게 된다

- 한 프로세스는 한 시스템 내의 작업의 단위이다

  - 이러한 시스템은 프로세스의 집합으로 구성되는데, 프로세스 중 일부는 운영체제 프로세스들(시스템 코드를 수행하는 프로세스들)이며,
  - 나머지는 사용자 프로세스들(사용자 코드를 수행하는 프로세스들)이다
  - 이러한 모든 프로세스는 단일 CPU코어에서 멀티플렉싱하거나 여러 CPU코어에서 병렬로 병행하게 실행할 수 있다

- 운영체제는 프로세스 관리와 연관해 다음과 같은 활동에 대한 책임을 진다

  - 사용자 프로세스와 시스템 프로세스의 생성과 제거
  - CPU에 프로세스와 스레드 스케줄 하기
  - 프로세스의 일시 중지와 재수행
  - 프로세스 동기화를 위한 기법 제공
  - ㅍ프로세스 통신을 위한 기법 제공

- 우리는 3장 부터 7장에 걸쳐 프로세스 관리 기법을 논의한다

### 1.5.2 메모리 관리(Memory management)

- 1.2.2절에서 논의한 바와 같이, 메인 메모리는 현대 컴퓨터 시스템의 작동에 중추적인 역할을 한다

  - 메모리는 크기가 수십 만에서 수십 억까지의 범위를 갖는 바이트의 대용량 배열이다
  - 각 바이트는 자신의 주소를 가진다
  - 메인 메모리는 CPU와 입출력 장치에 의하여 공유되는, 빠른 접근이 가능한 데이터의 저장소이다
  - 폰 노이만의 컴퓨터에서는 CPU가 `명령어 인출 사이클(instruction fetch-cycle)` 동안 메인 메모리로부터 명령어를 `읽고`,
    - `자료 인출 사이클(data fetch-cycle)` 동안 메인 메모리로부터 데이터를 `읽거나 쓴다`.
  - 앞에서 설명한 대로 메인 메모리는 일반적으로 CPU가 직접 주소를 지정할 수 있고, 그리고 직접 접근할 수 있는 유일한 대량 메모리이다
    - 예를 들면, `CPU가 디스크에서 가져온 데이터를 처리`하려면,
      - 이들 데이터는 CPU가 생성한 입출력 호출에 의해 `먼저 메인 메모리로 전송`되어야 한다
      - 마찬 가지로 `CPU가 명령을 수행`하기 위해서는 `명령이 메인 메모리 내에 있어야` 한다

- 프로그램이 수행되기 위해서는 반드시 절대 주소로 매핑(mapping)되고 메모리에 적재되어야 한다

  - 프로그램을 수행하면서, 이러한 절대 주소를 생성하여 메모리의 프로그램 명령어와 데이터에 접근한다
  - 프로그램이 종료되면, 프로그램이 차지하던 메모리 공간은 가용공간으로 선언되고, 다음 프로그램이 적재되어 수행될 수 있다

- `CPU 이용률`과 `사용자에 대한 컴퓨터의 응답속도`를 `개선`하기 위해,
  - 우리는 `메모리에 여러 개의 프로그램을 유지`해야 하며 이를 위해서 `메모리 관리 기법이 필요`하다
  - 이러한 메모리 관리 기법에는 여러 종류가 있다
  - 이러한 기법은 메모리 관리에 대한 여러 접근 방법을 반영하는데, 각 알고리즘의 효율성은 특정 상황에 따라 다르다
  - 특정 시스템에 대한 메모리 관리 기법의 선택은 여러 요인에 의해 결정되지만, 특히 시스템의 하드웨어 설계에 좌우된다
  - 각 알고리즘은 자기를 위한 하드웨어 지원이 필요하다
  - 운영체제는 메모리 관리와 관련하여 다음과 같은 일을 담당해야 한다
    - 메모리의 어느 부분이 현재 사용되고 있으며 어느 프로세스에 의해 사용되고 있는지를 추적해야 한다
    - 필요에 따라 메모리 공간을 할당하고 회수해야 한다
    - 어떤 프로세스(또는 그 일부)들을 메모리에 적재하고 제거할 것인가를 결정해야 한다
  - 메모리 관리 기법은 9장과 10장에서 논의된다

### 1.5.3 파일 시스템 관리(File system management)

- 컴퓨터 시스템의 편리한 사용을 위해, 운영체제는 정보 저장장치에 대한 균일한 논리적 관점을 제공한다
  - 운영체제는 `저장장치의 물리적 특성을 추상화`하여 `논리적인 저장 단위인 '파일'을 정의`한다
  - 운영체제는 파일을 물리적 매체로 매칭하며, 저장장치를 통해 이들 파일에 접근한다
- 파일 관리는 가장 눈에 띄는 운영체제 구성요소 중의 하나이다
  - 컴퓨터는 여러 유형의 물리적 매체에 정보를 저장할 수 있다
  - 2차 저장장치가 가장 일반적이지만 3차 저장 장치도 가능하다
  - 이러한 각 매체는 자신의 특성과 물리적 구성을 가지고 있다
  - 대부분의 매체는 디스크 드라이브와 같은 장치에 의해 제어되며, 이들 장치 또한 자신의 독특한 특성이 있다
  - 이러한 속성에는 접근 속도, 용량, 데이터 전송률, 그리고 접근 방식(순차 접근 방식 또는 임의 접근 방식) 등이 있다
- 파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다
  - 일반적으로 파일은 프로그램(소스와 목적 프로그램 형태)과 데이터를 나타낸다
  - 데이터 파일은 숫자, 영문자, 영숫자 등으로 구성된다
  - 파일은 텍스트 파일과 같은 자유 형태일 수도 있고, 엄격하게 포맷된 형태(예를 들면, mp3 음악 파일과 같이 고정된 필드)일 수도 있다
  - 분명하게 파일의 개념은 지극히 일반적이다
- 운영체제는 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다
  - 또한, 파일은 사용하기 쉽도록 통상 디렉터리들로 구성된다
  - 마지막으로, 다수의 사용자가 파일에 접근하려고 할 때는 누구에 의해서, 그리고 어떤 방법으로 (예를 들면, 읽기, 쓰기, 첨가) 파일이 접근되어야 하는가를 통제하는 것이 바람직하다
- 운영체제는 파일 관리를 위하여 다음과 같은 일을 담당한다
  - 파일의 생성 및 제거
  - 디렉터리 생성 및 제거
  - 파일과 디렉터리를 조작하기 위한 프리미티브의 제공
  - 파일을 보조저장장치로 매핑
  - 안정적인(비휘발성) 저장 매체에 파일을 백업
- 파일 관리 기법은 13장, 14장, 15장에서 다룰 것이다

### 1.5.4 대용량 저장장치 관리(Mass storage management)

- 컴퓨터 시스템은 메인 메모리를 백업하기 위해 `보조저장장치`를 제공해야 한다
  - 대부분 최신 컴퓨터 시스템은 `HDD와 NVM` 장치를 프로그램 데이터 모두에 대한 주요 저장 매체로 사용한다
  - 컴파일러, 웹 브라우저, 워드 프로세서 및 게임을 포함한 프로그램 대부분은 메모리에 적재될 때 까지 이러한 장치에 저장된다
  - 그런 다음 프로그램은 장치를 처리 소스 및 대상으로 모두 사용한다
  - 따라서, 보조 저장장치의 적절한 관리는 컴퓨터 시스템에서 가장 중요하다
- 운영체제는 보조저장장치 관리와 관련하여 다음 활동을 담당한다
  - 마운팅과 언마운팅
  - 사용 가능 공간(free-space)의 관리
  - 저장장소 할당
  - 디스크 스케줄링
  - 저장장치 분할
  - 보호
- 보조저장장치는 매우 빈번하고 폭 넓게 사용되므로, 효율적으로 사용해야 한다
  - 컴퓨터의 동작 속도는 보조저장장치 서브시스템과 그것을 조작하는 알고리즘 속도에 의해 결정될 수 있다
  - 동시에 보조저장장치보다 더 느리고 비용은 적게 들고 때로는 용량이 더 큰 장치를 필요로 하는 경우도 많다
    - 디스크 데이터의 백업, 가끔 쓰이는 데이터 및 장기간 보존이 필요한 데이터를 저장하는 것이 대표적인 예이다
    - 자기 테이프 드라이브와 그 테이프, CD와 DVD 및 Blu-ray 드라이브와 플래터들은 전형적인 3차 저장장치의 예이다
- 3차 저장장치는 시스템 성능에는 중요하지 않지만 운영체제에 의해 관리되어야만 한다
  - 어떤 운영체제들은 이 역할을 직접 수행하고 다른 운영체제들은 이 역할을 응용 프로그램에게 맡기기도 한다
  - 운영체제가 제공해야 할 기능에는 마운트와 엍ㄴ마운트 기능, 프로세스의 배타적 사용을 위한 장치의 할당과 반환 그리고 보조저장장치로부터 3차 저장장치로의 데이터 이주 등이 포함된다
  - 보조저장장치와 3차 저장장치 관리 기법들은 11장에서 논의할 것이다

### 1.5.5 캐시 관리(cache management)

- 캐싱은 컴퓨터 시스템의 중요한 원리이다
  - 정보는 어떤 저장장치(메인 메모리와 같은)에 보관된다
  - 정보가 사용됨에 따라, 더 빠른 장치인 캐시에 일시적으로 복사된다
  - 그러므로 우리가 특정 정보가 필요할 경우, 우리는 먼저 캐시에 그 정보가 있는지를 조사해 보아야 한다
  - 만약 캐시에 있으면 우리는 그 정보를 캐시로부터 직접 사용하지만, 만일 캐시에 없다면 메인 메모리 시스템으로부터 그 정보를 가져와서 사용해야 하며, 이 때 이 정보가 다음에 곧 다시 사용될 확률이 높다는 가정하에 캐시에 넣는다
- 게다가 CPU 내부의 프로그램 가능한 레지스터들은 메인 메모리를 위한 고속의 캐시로 볼 수 있다
  - 프로그래머(또는, 컴파일러)는 어느 정보를 메인 메모리에 두고, 어느 정보를 레지스터에 둘 것인지를 결정하느 레지스터 할당 정책과 교체 알고리즘을 구한다
- 전적으로 하드웨어로 구현된 캐시도 있다
  - 예를 들어, 시스템 대부분은 `다음에 수행될 것으로 예상되는` 명령을 넣어 두는 `명령 캐시`를 갖고 있다
    - 만약 명령 캐시가 없다면, CPU는 메인 메모리로 부터 다음 명령을 인출해 올 동안 몇 사이클을 기다려야 한다
  - 유사한 이유로 시스템 대부분은 하나 이상의 고속 데이터 캐시를 가지고 있다
  - 이 책에서는 이 처럼 하드웨어만으로 구성된 캐시는 관심을 두지 않는다
    - 왜냐하면 이들은 운영체제로 제어할 수 없기 때문이다

![그림1-14](./images_01/%EA%B7%B8%EB%A6%BC1-14.jpeg)

- 그림1.14 다양한 유형의 저장장치의 특성

- 캐시 크기가 제한되어 있으므로 캐시 관리는 중요한 설계 문제이다

  - 그림 1.14를 살펴보면 알 수 있듯이 캐시 크기와 교체 정책을 신중하게 선택하면 성능이 크게 향상될 수 있다
  - 소프트웨어 제어 캐시의 교체 알고리즘은 10장에서 설명한다

- `저장장치의 계층 구조에서 각 수준 간의 정보 이동`은 하드웨어 설계나 제어하는 운영체제에 따라 명시적 또는 묵시적으로 이루어진다
  - 예를 들어, `캐시로부터 CPU 및 레지스터로의 데이터 전송`은 통상 `운영체제의 간섭 없이` 하드웨어적으로 이루어진다
    - 반면 `디스크와 메모리 간의 데이터 전송`은 통상 `운영체제에 의해 제어`된다

![그림1-15](./images_01/%EA%B7%B8%EB%A6%BC1-15.jpeg)

- 그림1.15 정수 A를 디스크로부터 레지스터로 이동하는 과정

- 메모리의 계층 구조에서, 동일한 데이터가 서로 다른 수준의 저장장치 시스템에 나타나게 된다
  - 예를들어, fB라는 파일에 있는 vA라는 변수가 1증가 되어야 한다고 생각해보자
    - 파일 B가 자기 디스크에 있다고 가정
    - 증가 연산은 먼저 vA가 있는 디스크 블록을 메인 메모리로 복사해오는 입출력 연산을 호출함으로써 진행된다
    - 이어서 vA를 캐시에 복사하고, 이어 vA를 다시 내부 레지스터로 복사한다
    - 따라서 vA의 복사본이 여러 곳에 존재하게 된다(그림 1.15 참조)
    - 내부 레지스터에서 증가가 일어나면, vA의 값은 여러 저장장치 시스템에서 서로 달라진다
    - vA의 값은 자기 디스크에 새로운 vA의 값이 다시 기록된 ㅇ후에야 비로소 같아진다
  - 어떤 시간에 오직 하나의 프로세스만 실행하는 환경에서는, 이러한 기법이 아무런 문제가 없다
    - 왜냐하면, 정수 A에 대한 접근은 항상 계층 구조의 최상윗값을 참조하기 때문이다
    - 그러나 CPU가 여러개의 프로세스 사이에서 이리저리 전환되는 다중 태스킹 환경에서는, 여러 개의 프로세스가 vA에 접근하기를 원할 경우 이들 각 프로세스가 가장 최근에 갱신된 vA의 값을 얻을 것을 보장하기 위해서는 극도의 주의가 필요하다
  - CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 갖고 있는 다중 처리기 환경하에서는 상황이 더욱 복잡해진다
    - 이런 환경에서는, vA의 복사본이 동시에 여러 캐시에 존재할 수 있다
    - 여러 개의 CPU가 모두 동시에 실행될 수 있으므로, 한 캐시에 있는 vA값이 갱신될 경우 vA가 존재하는 모든 캐시에 즉각적으로 반영되어야 한다
      - 이러한 상황을 `캐시 일관성 문제`라고 하며, 이는 일반적으로(운영체제보다 아래 수준에서 처리되는) 하드웨어적 문제이다
  - 분산 환경에서는 상황이 훨씬 더 복잡해진다
    - 이 환경에서 동일한 파일의 여러 사본(또는 복제본)을 다른 컴퓨터에 보관할 수 있다
    - 여러 복제본에 동시에 액세스하여 업데이트 할 수 있으므로 일부 분산 시스템은 복제본을 한 곳에서 업데이트 할 때 다른 모든 복제본을 가능한 빨리 최신 상태로 유지하는 것을 보장한다
    - 19장에서 논의한 것 처럼 이 보장을 달성하는 다양한 방법이 있다

### 1.5.6 입출력 시스템 관리(I/O System management)

- 운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다
  - 예를 들면, UNIX에서 입출력 장치의 특성은 `입출력 서브시스템`에 의해 운영체제 자체의 대부분으로부터 숨겨져 있다
- 입출력 시스템은 다음과 같이 구성되어 있다
  - 버퍼링, 캐시, 스풀링을 포함한 메모리 관리 구성요소
  - 일반적인 장치 드라이버 인터페이스
  - 특정 하드웨어 장치들을 위한 드라이버
- 단지 장치 드라이버만이 자신에게 지정된 특정 장치의 특성을 알고 있다
- 효율적인 입출력 서브시스템을 구성하기 위하여 인터럽트 핸들러와 장치 드라이버가 어떻게 사용되는가에 대해서 이 장의 앞부분에서 논의하였다
  - 12장에서 우리는 입출력 서브시스템이 다른 시스템 구성요소와 어떻게 인터페이스하며, 장치를 관리하고, 데이터를 전송하며, 입출력 완료를 알아내는지 논의한다

## 1.6 보안과 보호(Security ans Protection)

- 만일 컴퓨터 시스템이 다수의 사용자를가지며 다수 프로세스의 병행 수행을 허용한다면, 데이터에 대한 접근은 반드시 규제되어야 한다
  - 이를 위해 파일, 메모리 세그먼트, CPU 및 다른 자원들에 대해 운영체제로부터 적절한 허가를 획득한 프로세스만이 작업할 수 있도록 보장하는 기법이 필요하다
    - 내 생각) PC방 컴퓨터에서 system폴더에 접근을 제한 하는 것
  - 예를 들면, 메모리 주소 지정 하드웨어는 프로세스가 자신의 주소 영역에서만 실행될 수 있도록 보장한다
    - 타이머는 모든 프로세스가 CPU의 제어를 얻은 후 결국에는 제어를 양도하도록 보장한다
    - 여러 주변 장치의 무결성이 보호받도록, 장치 제어 레지스터들에 사용자가 접근할 수 없게 한다
- `보호(protection)`란 컴퓨터 시스템이 정의한 `자원에` 대해 프로그램, 프로세스, 또는 `사용자들의 접근을 제어`하는 기법이다

  - 이 기법은 시행될 제어에 대한 명세와 이들을 `강제 시행하는 방법`을 규정하는 수단을 반드시 `제공`해야 한다
  - 보호는 구성요소 서브시스템 간의 인터페이스 오류를 초기에 발견하면 종종 고장 난 서브시스템에 의해 정상적인 서브시스템이 오염되는 것을 방지할 수 있다
  - 보호되지 않은 자원은 권한이 없거나 또는 무자격 사용자에 의해 사용(또는 오용)되는 것을 방지할 수 없다
  - 보호 지향 시스템은 허가받은 사용과 그렇지 않은 사용을 구별하는 방법을 제공하는데, 17장에서 이를 검토한다

- 컴퓨터 시스템은 충분한 보호 기능이 있더라도 여전히 고장이 나거나 부적절한 접근을 허용할 수 있다
  - 사용자의 인증 정보(사용자 자신임을 시스템에게 알릴 수 있는 방법)가 도난당했다고 가정하자
    - 파일과 메모리 보호 기능이 작동하더라도 사용자의 데이터는 복사 또는 삭제될 수 있다
  - 이러한 외부 또는 내부의 `공격을 방어하는 것`이 바로 `보안` 기능이다
  - 이러한 공격은 시스템의 많은 범위에 대해 가능하고
    - 바이러스, 웜, 서비스 거부 공격(시스템의 자원을 전부 소모함으로써 다른 사용자들이 시스템에 접근할 수 없게 만듦), 식별자 도용, 서비스 도용(인가되지 않은 시스템의 사용) 등이 있다
  - 어떤 운영체제는 이 공격들의 일부를 막는 기능을 고려하고 있으며 다른 운영체제들은 이를 정책이나 부가적인 응용에 맡기고 있다
  - 보안 사고의 놀랄만한 증가로 인하여 운영체제의 보안 기능에 관한 연구와 구현이 급속도로 증가하고 있다
  - 보안은 16장에서 논의된다
- 보호와 보안을 제공하기 위해서는 시스템의 모든 사용자를 구분할 수 있어야 한다

  - 운영체제의 대부분은 사용자 이름과 연관된 `사용자 식별자(user IDs)`의 리스트를 유지한다
    - Windows 용어로는 `보안 식별자(security ID, SID)`라고 한다
  - 이 식별자는 사용자마다 할당되고 시스템에서 유일한 값을 가진다
  - 사용자가 로그인 할 때 인증 단계에서 사용자에게 맞는 적절한 식별자를 결정한다
  - 이 사용자 식별자는 사용자의 모든 프로세스나 스레드에 연관된다
  - 식별자를 사용자가 읽어야 할 필요가 있을 때 사용자 이름 리스트를 통하여 원래의 사용자 이름으로 변환된다

- 어떤 상황에서는 각 사용자가 아니라 사용자의 집합을 구분하기를 원한다

  - 예를 들면 UNIX 시스템에는 파일 소유주에게는 모든 연산을 허용하고 일부 사용자들에게는 읽기 연산만을 허용할 수도 있다
    - https://eunguru.tistory.com/93
  - 이를 위하여 그룹 이름과 그 그룹에 속한 사용자들을 정의할 필요가 있다
    - 그룹 기능은 시스템 전체에 존재하는 그룹 이름과 `그룹 식별자`의 리스트로 구현될 수 있다
    - 사용자는 운영체제를 설계했을 때의 결정에 따라 하나이상의 그룹에 속할 수 있다
    - 사용자의 그룹 식별자는 관련된 모든 프로세스나 스레드에 연관된다

- 시스템을 정상적으로 사용하는 동안 사용자 식별자와 그룹 식별자만 있으면 충분하다
  - 그러나 사용자는 때때로 원하는 작업을 수행하기 위해 `권한을 상승`해야 할 때가 있다
  - 예를 들어 사용자가 제한된 장치에 접근해야 할 때도 있다
  - 운영체제는 권한 상승을 허용하는 다양한 방법을 제공한다
  - 예를 들면 UNIX에서는 프로그램이 수행될 때 setuid 속성을 이용하여 현 사용자의 식별자가 아니라 접근하려고 하는 파일의 소유주 식별자를 이용하여 동작할 수 있다
  - 프로세스는 종료되거나 특권을 해제하기 전까지 이 `유효 사용자 식별자(effective user ID)`를 이용하여 수행된다

## 1.7 가상화(Virtualization)

- `가상화`는 단일 컴퓨터(CPU, 메모리, 디스크 드라이브, 네트워크 인터페이스 카드 등)의 하드웨어를 여러 가지 실행 환경으로 추상화하여 `개별 환경`이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들 수 있는 기술이다
  - 이러한 환경은 동시에 실행되고 서로 상호 작용할 수 있는 `다른 개별 운영체제(예: Windows 및 UNIX)로 볼 수 있다`
  - `가상 머신`의 사용자는 단일 운영체제에서 동시에 실행되는 다양한 프로세스 간에 전환할 수 있는 것과 동일한 방식으로 다양한 운영체제 간에 전환할 수 있다
- 가상화는 운영체제가 다른 운영체제 내에서 하나의 응용(application)처럼 수행될 수 있게 한다
  - 언뜻 보아서는 그러한 기능이 별 이유가 없는 것처럼 보인다
  - 그러나 가상화 산업은 방대하며 성장하고 있어 그 용도와 중요성을 입증하고 있다
- 넓게 말하면 가상화 소프트웨어는 에뮬레이션을 포함하는 클래스의 구성원이다
  - 소프트웨어로 컴퓨터 하드웨어 시뮬레이션 하는 에뮬레이션은 일반적으로 소스 CPU 유형이 대상 CPU 유형과 다른 경우에 사용된다
    - 에뮬레이션?
      - https://ko.wikipedia.org/wiki/%EC%97%90%EB%AE%AC%EB%A0%88%EC%9D%B4%ED%84%B0
      - http://www.smallpc.co.kr/ab-5940-12
      - 한 소프트웨어가 시스템 A에서는 구동되고 시스템 B에서는 구동되지 않을 때 시스템 B에서 시스템 A의 동작을 "에뮬레이션"합니다.
      - e.g. 안드로이드 에뮬레이터
    - 가상화
      - 가상화에서는 시스템 A를 B와 C 두 개의 서버로 분리합니다. 이 "가상" 서버들은 독립적인 소프트웨어 컨테이너(Container)로써 자체적으로 CPU, RAM, 스토리지, 네트워킹 등 소프트웨어 기반 자원에 접근할 수 있으며 독립적으로 재부팅도 가능합니다. 이 둘은 정확히 실제 하드웨어처럼 작동하며, 애플리케이션 또는 다른 컴퓨터는 그 차이점을 인지하지 못합니다.
    - 예를 들면, Apple사가 자신의 데스크톱과 랩톱 컴퓨터의 CPU를 IBM Power CPU에서 인텔 x86 CPU로 전환했을 때 "Rosetta"라는 에뮬레이션 설비를 포함하여 IBM CPU용으로 컴파일되었언 응용(application)을 인텔 CPU에서 수행할 수 있게 하였다
  - 이러한 개념이 한 기계를 위해 작성된 전체 운영체제를 다른 기계에서 수행되도록 확장될 수 있다
    - 그렇지만 에뮬레이션은 비용이 크다
    - 소스 시스템에서 수행되는 기계어 수준의 모든 명령은 목표 시스템에서 동등한 기능으로 번역되어야 하고, 종종 이는 여러 개의 목표 명령어가 되기도 한다
    - 만일 소스와 목표 CPU가 비슷한 성능 수준일 경우 에뮬레이트된 코드는 원래 코드보다 훨씬 느리게 수행된다

![그림1-16](./images_01/%EA%B7%B8%EB%A6%BC1-16.jpeg)

- 그림1.16 (a) 하나의 운영체제와 (b) 3개의 가상 머신을 실행시키는 컴퓨터

- 이와 달리 가상화에서는 특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용의 다른 운영체제 내에서 수행된다

  - 가상화는 다수 사용자가 작업을 병행 수행하기 위한 방법으로 IBM 대형 컴퓨터에 처음 등장하였다
  - 다수의 가상기계를 수행함으로써 많은 사용자들이 단일 사용자를 위해 설계된 시스템에서 작업을 수행할 수 있게 되었다
  - 후에 다수의 Microsoft Windows 응용(application)을 인텔 x86 CPU에서 실행하는 문제를 해결하기 위해 VMware가 Windows 상에서 수행되는 응용의 형태로 새로운 가상화 기술을 만들었다
  - 이 응용(application)은 게스트(guest)라 불리는 하나 이상의 Windows나 다른 x86용 운영체제 복사본들을 수행하며 각 게스트는 자신의 응용을 수행한다(그림 1.16참조)
  - Windows는 호스트 운영체제이고 VMware응용(application)은 가상 머신 관리자(VMM)이다
    - VMM은 게스트 운영체제를 수행하고 그들의 자원 이용을 관리하며 각 게스트를 서로로부터 보호한다

- 현대의 운영체제가 다수의 응용(application)을 신뢰성 있게 수행할 능력 이 있다고 해도, 가상화의 이용은 지속해서 성장하고 있다
  - 랩톱과 데스크톱에서 VMM은 체험을 위하거나 또는 다른 호스트용으로 작성된 운영체제상의 응용을 수행하기 위해 다수의 운영체제를 설치할 수 있게 한다
  - 예를 들면, x86 CPU 위에서 macOS를 수행하는 Apple 랩톱은 Windows 응용(application)을 수행하기 위해 Windows10 게스트를 수행할 수 있다
  - 다수운영체제를 위해 소프트웨어를 작성하는 회사는 가상화를 이용하여 하나의 물리 서버를 이용하여 이들 모든 운영체제를 수행하여 개발, 테스팅, 디버깅을 수행할 수 있다
  - 데이터 센터에서는 가상화가 계산 환경을 수행하고 관리하는 데 일반적인 방법이 되었다
  - VMware ESX 및 Citrix XenSever와 같은 VMM은 더는 호스트 운영체제에서 실행되는 것이 아니라 가상 머신 프로세스에게 서비스 및 자원 관리를 제공하는 호스트 운영체제 그 자체이다
- 가상화의 기능 및 구현에 대한 자세한 내용은 18장에서 확인할 수 있다

## 1.8 분산 시스템(Distributed Systems)

- 분산 시스템은 `물리적으로 떨어져 있는` 이기종 `컴퓨터들의 집합`이다
  - `분산 시스템의 컴퓨터들`은 사용자가 시스템 내의 다양한자원들을 접근할 수 있도록 `네트워크로 연결되어` 있다
  - 공유 자원에 대한 접근은 계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상시킨다
  - 몇몇 운영체제는 네트워크의 자세한 사항을 네트워크 인터페이스의 장치 드라이버에 포함시킴으로써 네트워크에 대한 접근을 파일 접근 형태로 일반화시킨다
  - 다른 운영체제들은 사용자가 특정 네트워크 기능을 명시적으로 호출하게 한다
  - 일반적으로 시스템 상에서는 두 모드가 혼재되어 있으며 그 예로 FTP와 NFS를 들 수 있다
  - 분산 시스템을 마드는 프로토콜은 시스템의 유용성과 대중성에 큰 영향을 줄 수 있다
- `네트워크`는 가장 단순하게 보면 두 개 이상 시스템 간의 통신 경로이다
  - 분산 시스템의 만허은 기능은 네트워킹에 의존하고 있다
  - 네트워크는 사용되는 프로토콜, 노드 간의 거리, 그리고 전송 매체에 따라 다르다
  - 비록 ATM과 여타 프로토콜들이 널리 사용되고 있지만 `TCP/IP`가 `가장 일반적인 네트워크 프로토콜`로 인터넷의 기본 구조를 제공한다
  - 모든 범용 운영체제를 포함하여 운영체제 대부분은 TCP/IP를 지원한다
  - 일부 시스템은 자신들의 필요를 위해 사유의 프로토콜을 지원한다
  - 운영체제의 입장에서 네트워크 프로토콜은 인터페이스 장치(예: 네트워크 어댑터 등), 이를 관리하는 장치 드라이버 및 데이터를 처리하는 소프트웨어가 있어야 한다. 이 개념은 이 책 전체에서 논의된다
- 네트워크는 노드 간의 `거리에 의해 유형이 결정`된다.
  - `근거리 통신망(LAN)`은 한 방, 한 층, 또는 한 건물에 존재한다
  - `광역 통신망(WAN)`은 건물, 도시 또는 국가 사이를 연결한다
    - 다국적 기업은 전 세계에 퍼져 있는 사무실을 연결하기 위해 WAN을 사용할 수 있다
    - 이들 네트워크는 하나 또는 다수의 프로토콜을 사용할 수 있다
  - 새로운 기술의 개발에 따라 새로운 형태의 네트워크가 생겨나고 있다
    - 예를 들면, `도시권 통신망(MAN)`은 한 도시 내의 건물들을 연결할 수 있다
    - `블루투스(BlueTooth)`와 802.11 장치는 무선 통신 기술을 사용하여 수 미터 짧은거리에서 통신하며 실질적으로 전화기와 헤드셋 사이 또는 스마트폰과 데스크톱 컴퓨터 사이에 `단거리 통신망(personal-area network, PAN)`을 만든다
- 네트워크에 사용되는 매체도 또한 다양하다
  - 이들은 구리 전선, 섬유 가닥, 또는 위성, 마이크로웨이브 접시 및 라디오 사이의 무선 전송 등을 포함한다
  - 계산 장치가 휴대폰에 연결되면 네트워크를 형성한다
  - 아주 짧은 적외선 통신도 네트워크를 위해 사용될 수 있다
  - 아주 초보적인 수준에서 컴퓨터는 통신할 때마다 네트워크를 사용하거나 생성한다
  - 이들 네트워크는 성능과 신뢰도에 차이가 있다
- 일부 운영체제는 네트워크 연결 제공 개념을 넘어서서 네트워크 및 분산 시스템 개념을 취했다
  - `네트워크 운영체제`는 다른 컴퓨터의 다른 프로세스가 메시지를 교환할 수 있도록 하는 통신 체계와 함께 네트워크를 통한 파일 공유와 같은 기능을 제공하는 운영체제이다
  - 네트워크 운영체제를 실행하는 컴퓨터는 네트워크를 인식하고 다른 네트워크 컴퓨터와 통신할 수 있지만 네트워크의 다른 모든 컴퓨터와는 자율적으로 작동한다
  - 분산 운영체제는 그에 비해 덜 자율적인 환경을 제공한다
  - 하나의 운영체제가 네트워크를 제어하는 것 처럼 보이기 위해 여러 컴퓨터가 밀접하게 통신한다
  - 우리는 19장에서 컴퓨터 네트워크와 분산 시스템을 다룬다

## 1.9 커널 자료구조(Kernel Data Structures)

- 이제 우리는 운영체제 구현의 중심이 되는 주제, 즉 시스템에서 데이터가 구조화되는 방법을 다룬다
- 이 절에서 우리는 운영체제에서 광범위하게 사용되는 다수의 기본 자료구조를 간략히 설명한다
- 이들 및 다른 구조에 대해 자세한 사항을 원하는 독자는 이 장의 끝에 있는 문헌 목록을 참고하길 바란다

### 1.9.1 리스트, 스택 및 큐(Lists, Stack, and Queues)

- 배열은 각 원소가 직접 접근될 수 있는 단순한 자료구조이다
  - 예를 들면, 메인 메모리는 하나의 배열로 구축된다
  - 저장된 데이터가 한 바이트보다 크면
    - 그 데이터에 다수의 바이트가 할당되면 그 데이터는 데이터 수 \* 데이터 크기로 주소 지정된다
  - 그렇지만 크기가 변하는 데이터는 어떻게 저장할까?
  - 또한 한 데이터를 제거하고 나머지 데이터를 유지해야 할 경우는 어떻게 하는가?
  - 이러한 상황에서는 배열 대신 다른 자료구조를 사용해야 한다
- 배열에 이어 아마도 리스트가 컴퓨터 과학에서 가장 근본적인 자료구조일 것이다
  - 배열의 각 항은 직접 접근할 수 있으나 리스트의 항은 특정 순서로 접근해야 한다
  - 즉, 리스트는 데이터 값들의 집단을 하나의 시퀀스로 표시한다
  - 이 구조를 구현하는 가장 일반적인 방법이 연결 리스트(linked list)이다
  - 연결 리스트에서는 각 항이 다른 하나에 연결되어 있다

![그림1-17_그림-18](./images_01/%EA%B7%B8%EB%A6%BC1-17-18.jpeg)

- 그림 1.17 단일 연결 리스트
- 그림 1.18 이중 연결 리스트

![그림1-19](./images_01/%EA%B7%B8%EB%A6%BC1-19.jpeg)

- 그림 1.19 원형 연결 리스트

- 연결 리스트는 다수의 유형이 있다

  - 단일 연결리스트에서 각 항은 그림 1.17과 같이 후속항을 가리킨다
  - 이중 연결리스트에서 한 항은 그림 1.18과 같이 이전 항과 후속 항을 가리킨다
  - 원형 연결리스트에서는 그림 1.19와 같이 리스트의 마지막 항이 null이 아니라 첫 항을 가리킨다

- 연결 리스트는 가변 수의 항들을 수용하며 항의 삭제와 삽입이 쉽다
  - 리스트를 사용할 경우 가능한 단점은 길이가 n인 리스트에서 특정 항을 인출할 때의 성능이 선형
  - 즉, O(n)이라는 점이다
    - 왜냐하면, 최악의 경우 전체 n개의 항을 전부 살펴보아야 할 수 있기 때문이다
  - 리스트는 자주 커널 알고리즘에 의해 직접 사용된다
  - 그렇지만 리스트는 자주 스택이나 큐 같은 보다 강력한 자료구조를 구축하는 데 사용된다
- `스택`은 순차적 순서를 가진 자료구조로 항을 넣거나 꺼내는 데 `후입선출(last in first out, LIFO)`을 사용한다
  - 즉, 스택에 마지막에 삽입된 항이 먼저 인출된다
  - 스택에 하을 삽입하거나 인출하는 일은 각각 `push`와 `pop`이라고 한다
  - 운영체제는 함수를 호출할 경우 종종 스택을 사용한다
  - 함수를 호출할 때 인수, 로컬 변수 및 복귀 주소 등이 스택에 푸쉬되고 함수로 부터 복귀할 때 이들 항을 스택으로부터 팝합다
- 반면 `큐`는 순차 순서의 자료구조로 선입선출(first in first out, FIFO)을 사용한다
  - 각 항은 삽입된 순서대로 큐로부터 제거된다
  - 일상 생활에서 큐를 사용하는 많은 예가 있다
    - 상점의 계산대에서 기다리는 사람들과 교통신호를 가디라는 자동차들이 그 예이다
  - 큐는 운영체제에서도 대단히 흔히 사용된다
    - 예를 들면, 프린터에 보내진 작업은 전형적으로 제출된 순서대로 인쇄된다
  - 우리가 5장에서 살펴보겠지만 CPU에서 수행을 기다리는 태스크들은 종종 큐로 구성된다

### 1.9.2 트리(tree)

![그림1-20](./images_01/%EA%B7%B8%EB%A6%BC1-20.jpeg)

- 이진 탐색 트리

- `트리`는 데이터의 서열을 표시하는 데 사용한 자료구조이다
- 트리 구조에서 데이터 값들은 부모-자식 관계로 연결된다
- `일반 트리(general tree)`에서 부모는 임의의 수의 자식을 가질 수 있다
- `이진 트리`에서 부모는 최대 두 개의 자식을 가질 수 있으며, 이들은 좌측 자식, 우측 자식이라 부른다
- `이진 탐색 트리`는 추가로 부모의 두 자식 사이에 좌측 자식 <= 우측 자식의 순서를 요구한다
  - 그림 1.20은 이진 탐색 트리의 예를 보인다
  - 이진 탐색 트리에서 한 항을 찾으려면 최악의 경우 성능이 `O(n)`이다
  - 이러한 상황을 방지하기 위해 우리는 `균형 이진 탐색 트리`를 만드는 알고리즘을 사용할 수 있다
    - 그 경우 n개의 항을 갖는 트리는 최대 깊이가 log(n)이며, 따라서 최악의 경우 성능은 `O(log(n))`을 보장한다
- 우리는 5.7.1절에서 Linux가 CPU 스케줄링 알고리즘의 일부로(red-black tree로 알려진) 균형이진 탐색 트리를 사용하는 것을 볼 것이다

### 1.9.3 해시 함수와 맵(Hash Functions and Maps)

![그림1-21](./images_01/%EA%B7%B8%EB%A6%BC1-21.jpeg)

- 그림 1.21 해시 맵

- `해시 함수`는 데이터를 입력으로 받아 이 데이터에 `산술 연산을 수행`하여 `하나의 수를 반환`한다
  - 이 수는 그 데이터를 인출하기 위해 테이블(전형적으로 하나의 배열)의 인덱스로 사용할 수 있다
  - 크기 n인 리스트에서 데이터를 찾는 데 최대 O(n)의 비교가 필요한 반면에 테이블에서 해시 함수를 사용하여 데이터를 인출할 경우 O(1)만큼 좋을 수도 있으며, 이는 상세 구현에 좌우된다
  - 이러한 성능 때문에 해시 함수는 운영체제에서 광범위 하게 사용된다
- 해시 함수의 한 어려운 점은 두 개의 서로 다른 입력이 하나의 출력 값을 가질 수 있다는 것이다
  - 즉, 이들이 테이블의 동일 위치로 색인 될 수 있다
  - 이를 우리는 해시 충돌(hash collision)이라 하며 테이블의 각 항에 연결 리스트를 두어 동일한 해시 값을 갖는 모든 항을 수록하게 한다
  - 물론 충돌이 많을 수록 해시 함수의 효율이 떨어지게 된다
- 해시 함수의 한 용도는 `해시 맵`을 구현하능 일이다
  - 해시 맵은 해시 함수를 사용하여 [키, 값]을 연관(또는 맵) 시킨다
  - 일단 매핑이 성립되면 키에 해시 함수를 사용하여 해시맵으로부터 그 값을 얻을 수 있다(그림 1.21)
  - 예를 들면, 한 사용자 이름이 한 패스워드로 매핑 된다고 하자
    - 패스워드 인증은 다음과 같이 진행될 수 있다
    - 한 사용자가 자신의 사용자 이름과 패스워드를 입력한다
    - 이어 사용자 이름에 해시 함수를 적용하여 그 결과 값으로 패스워드를 인출한다
    - 인출된 패스워드와 사용자가 인증을 위해 입력한 패스워드와 비교한다

### 1.9.4 비트맵(Bitmaps)

- 비트맵은 n개의 항의 상태를 나타내는 데 사용 가능한 n개의 이진 비트의 스트링이다
- 예를 들어, 다수의 자원이 있다
  - 각 자원의 가용 여부를 이진 비트의 값으로 표시한다
  - 0은 자원이 사용가능함을 표시하고
  - 1은 사용 불가능함을 표시한다(또는 그 반대로 할 수도 있다)
- 비트맨에서 i번째 위치의 값은 i번째 자원과 연관되어 있다
  - 예로 아래의 비트맵을 고려해 보자
    - 001011101
      - 자원 2,4,5,6,8은 사용 가능하지 않다
      - 자원 1,3,7은 사용 가능하다
- 비트맵의 힘은 이들의 공간 효율을 생각하면 자명하다
  - 만일 우리가 단일 비트 대신 8비트의 부울 값을 사용한다면 자료구조는 8배의 크기가 될 것이다
  - 따라서 비트맵은 대량의 자원의 가용성을 표시할 때 일반적으로 사용된다
  - 디스크 드라이브가 좋은 예가 될 수 있다
    - 중간 디스크의 디스크 드라이브는 디스크 블록이라 불리는 수천 개의 독립된 단위로 나누어진다
    - 각 디스크 블록의 가용 여부를 나타내기 위해 비트맵을 사용할 수 있다
- 요약하면, 운영체제의 구현에는 자료구조가 널리 사용된다
  - 따라서 우리가 커널 알고리즘과 그 구현을 살펴보면서 이 책 전체에서 여기서 논의된 구조와 추가의 구조들을 보게 될 것이다

#### Linux 커널 자료구조

- Linux 커널에서 사용되는 자료구조는 커널 소스 코드에서 확인할 수 있다
- Include 파일 `<linux/list.h>`는 커널 전체에서 사용되는 연결 리스트 자료구조의 세부 사항을 제공한다
- Linux에서 큐는 kfifo라고 하며, 구현은 소스코드의 kernel 디렉터리에 있는 kfifo.c 파일에서 찾을 수 있다
- Linux는 또한 red-black 트리를 사용하여 균형 이진 탐색 트리를 제공한다
- 자세한 내용은 include 파일 `<linux/rbtree.h>`에서 찾을 수 있다

## 1.10 계산 환경(Computing Environments)

- 지금까지 컴퓨터 시스템의 여러 면모와 이를 관리하는 운영체제를 간략히 살펴보았다
- 이제 우리는 다양한 계산 환경에서 운영체제가 어떻게 사용되는지 살펴본다

### 1.10.1 전통적 계산(Traditional Computing)

- 오늘날 웹 기술이 전통적인 계산의 경계를 확장하고 있다
  - 회사들은 자신의 내부 서버에 웹 접근을 제공하는 `포털(portals)`을 구현하고 있다
  - 네트워크 컴퓨터(또는 thin client)는 실질적으로 웹 기반 컴퓨팅을 이해하는 터미널을 말하며, 이들은 더 높은 보안이나 쉬운 보수가 필요한 경우 전통적인 워크스테이션을 대체하여 사용되고 있다
  - 모바일 컴퓨터는 PC와 동기화하여 회사 정보를 쉽게 휴대할 수 있다
  - 휴대용 컴퓨터는 무선 네트워크나 이동전화 망에 연결되어 회사의 웹 포털(아울러 다른 수많은 웹 자원)을 사용할 수 있게 한다
- 집에서 사용자 대부분은 하나의 컴퓨터가 느린 모뎀 연결을 통해 사무실이나 인터넷 또는 양쪽 모두에 연결되어 있는 환경이었다
  - 한때는 큰 비용이 들었던 네트워크 연결 속도는 싼 비용으로 이용 가능하며, 더 많은 데이터에 더 많은 접근을 가능하게 한다
  - 이러한 고속 연결은 홈 컴퓨터가 웹 페이지를 제공하고 프린터, 클라이언트 PC, 서버를 갖는 자신의 네트워크를 가질 수 있게 한다
  - 일부 홈은 계산 환경을 보안 침해로 부터 보호하기 위해 방화벽(firewall)을 가지고 있다
  - 방화벽ㅊ은 네트워크 장치간 통신을 제한한다
- 20세기 후반
  - 시분할 시스템
    - 자원의 일정량을 각 사용자에게 프로세스를 CPU에 하나씩 순환시켜 가면서 실행시키기 위하여
    - 타이머와 스케줄링 알고리즘을 이용
- 오늘날 전통적 시분할 시스템은 희귀한 시스템이 되었다
  - 동일한 스케줄링 기법이 워크스테이션과 서버에서 사용되고 있지만
  - 모든 프로세스는 한 사용자가 전부 소유하거나 단일 사용자와 운영체제가 소유하고 있는 형태를 취한다
  - 사용자 프로세스와 사용자에게 서비스를 제공하는 시스템 프로세스는 계산 시가을 빈번하게 얻을 수 있도록 관리된다
  - 예를 들어 PC상에서 작업하는동안 생성된, 동시에 다른 태스크를 수행할 수 있는 윈도들을 생각하라
  - 하나의 웹 브라우저조차도 현재 방문하는 각 웹사이트별로 한 프로세스를 갖도록 다수의 프로세스로 구성될 수 있으며 각 웹 브라우저들에 시분할이 적용된다

### 1.10.2 모바일 컴퓨팅

- 모바일 컴퓨팅은 휴대용 스마트폰과 태블릿 컴퓨터의 컴퓨팅 환경을 말한다
- 오늘날 휴대용 시스템은 이메일이나 웹 브라우징뿐만 아니라 음악 연주, 비디오, 디지털 책 읽기, 사진 촬영, 고품질 비디오의 녹화, 편집 등에 사용된다
- 온라인 서비스에 접근을 허용하기 위해 휴대장치는 전형적으로 IEEE 표준 802.11무선 또는 휴대 전화 데이터망을 사용한다
- 현재 휴대 컴퓨팅에서 두 개의 지배적인 운영체제는 Apple iOS와 Google Android이다
  - 2장에서 이들 두 원영체제를 더 자세히 검토한다

### 1.10.3 클라이언트 서버 컴퓨팅(Client server computing)

![그림1-22](./images_01/%EA%B7%B8%EB%A6%BC1-22.jpeg)

- 그림 1.22 클라이언트-서버 시스템의 일반적인 구조

- 현대 네트워크 구조는 서버 시스템이 클라이언트 시스템이 생성한 요청을 만족시키는 배치를 특징으로 한다.
- 클라이언트-서버 시스템이라 불리는 이 형태의 특수 분산 시스템은 그림 1.22에 묘사된 일반적인 구조를 가진다

- 서버 시스템은 대체적으로 계산 서버와 파일 서버로 분류될 수 있다
  - `계산-서버` 시스템은 클라이언트가 어떤 작업을(예를 들어, 데이터 읽기) 요청할 수 있는 인터페이스를 제공한다
    - 그 결과로 서버는 그 작업을 수행하고 결과를 클라이언트에게 돌려보낸다
    - 클라이언트의 데이터 요청에 응답하는 데이터베이스를 실행하고 있는 서버가 이러한 시스템의 한 예이다
  - `파일-서버` 시스템은 클라이언트가 파일을 생성, 갱신, 읽기 및 제거할 수 있는 파일 시스템 인터페이스를 제공한다
    - 이러한 시스템의 예로써 웹 브라우저 클라이언트에게 파일을 전달하는 웹 서버를 들 수 있다
    - 파일의 실제 내용은 기존 웹 페이지 부터 고화질 비디오와 같은 풍부한 멀티미디어 콘텐트에 이르기까지 매우 다양하다

### 1.10.4 피어간 계산(Peer-to-peer computing)

![그림1-23](./images_01/%EA%B7%B8%EB%A6%BC1-23.jpeg)

- 그림 1.23 중앙 집중 서비스가 없는 피어 간 시스템

- 이 모델에서는 클라이언트와 서버가 서로 구별되지 않는다
- 대신 시스템상의 모든 노드가 피어로 간주되고 각 피어는 서비스를 요청하느냐 제공하느냐에 따라 클라이언트 및 서버로 동작한다
- 피어 간 시스템은 전통적인 클라이언트 서버에 비해 장점을 제공한다
  - 클라이언트 서버 시스템에서는 서버가 병목으로 작용한다
  - 그러나 피어 간 시스템에서는 서비스가 네트워크에 분산된 여러 노드에 의해 제공될 수 있다
- 발견 프로토콜이 제공되어야 한다
  - 그림 1.23이 그러한 각본을 보인다
- 내 생각) 토렌트
- Skype가 피어 간 계산의 또 다른 예이다
  - Skype는 클라이언트가 인터넷을 통해 IP상 음성(VolP, voice over IP)이라 알려진 기술로 음성 통화나 비디오 통화를 할 수 있게 한다
  - Skype는 절충형 피어 간 접근을 사용한다
  - 중앙형 로그인 서버를 가지며, 분산형 피어를 사용하여 두 피어가 서로 통신할 수 있게 한다

### 1.10.5 클라우드 컴퓨팅(Cloud computing)

- 클라우드 컴퓨팅은 계산, 저장장치는 물론 응용(application)조차도 네트워크를 통한 서비스로 제공하는 계산 유형이다
- 어떤 면에서 `클라우드 컴퓨팅`은 `가상화를 그 기능의 기반`으로 사용하기 때문에 가상화의 논리적 확장이다
- 예를 들면 아마존 Elastic Compute Cloud(ec2) 설비는 수천의 서버, 수백만의 가상 머신 및 페타 바이트의 저장장치를 인터넷상의 누구든지 사용할 수 있게 한다
- 사용자는 자신이 사용하는 자원량에 따라 매월 사용료를 지불한다
- 아래를 포함하여 여러 유형의 클라우드 컴퓨팅이 존재한다

  - 공중 클라우드 - 서비스를 위해 지불 가능한 사람은 누구나 인터넷을 통해 사용가능한 클라우드
  - 사유 클라우드 - 한 회사가 사용하기 위해 운영하는 클라우드
  - 혼합형 클라우드 - 공공과 사유 부분을 모두 포함하는 클라우드
  - 소프트웨어 서비스(Software as a service, SaaS) - 인터넷을 통해 사용 가능한 하나 이상의 응용(application)
    - 예) Google Docs, Salesforce.com
  - 플랫폼 서비스(platform as a service, PaaS) - 인터넷을 통해 사용하도록 응용(application)에 맞게 준비된 소프트웨어 스택
    - 예) 데이터베이스 서버
  - 하부구조 서비스(infrastructure as a service, IaaS) - 인터넷을 통해 사용 가능한 서버나 저장장치
    - 예) 생산 데이터의 백업 복사본을 만들기 위한 저장장치

- 클라우드 컴퓨팅 환경은 다수 유형의 조합을 제공하기 떼ㅐ문에 이들 클라우드 컴퓨팅 유형들은 서로 독립적이 아니다
  - 예를 들면 한 조직이 공중 서비스로 SaaS와 IaaS를 모두 제공할 수 있다

![그림1-24](./images_01/%EA%B7%B8%EB%A6%BC1-24.jpeg)

- 클라우드 컴퓨팅

- 그림 1.24는 Iaas를 제공하는 공중 클라우드를 보인다
- 클라우드 서비스와 클라우드 사용자 인터페이스가 모두 방화벽에 의해 보호되는 것에 유의하라

### 1.10.6 실시간 내장형 시스템(Real time embedded system)

- 내장형 시스템은 현재 가장 유행하는 컴퓨터의 형태이다
- 이 장치들은 자동차 엔진, 공장용 로봇에서 광학 드라이브 및 전자파 오븐 등 어느 곳에서나 볼 수 있다
- 이 내장형 시스템들은 매우 다양하다
  - 어떤 시스템은 UNIX와 같은 범용 운영체제를 수행시키면서 특수 목적을 가진 응용프로그램을 수행시키는 형태를 갖는다
  - 다른 시스템은 필요한 기능만을 제공하는 내장형 운영체제를 가지고 있는 하드웨어 형태를 취한다
  - 또 다른 시스템은 운영체제 없이 필요한작업을 수행하는 응용 전용 칩(application-specific integrated circuits, ASICs)만을 갖는하드웨어 장치들이다
- 내장형 시스템은 거의 `실시간 운영체제`를 수행한다
  - 실시간 시스템은 처리기의 작동이나 데이터의 흐름에 엄격한 시간 제약이 있을 때 사용된다
- 5장에서 운영체제에 실시간 기능을 구현하는 데 필요한 스케줄링 설비를 고려하고 20장에서 Linux 운영체제의 실시간 구성요소에 대해 논의한다

## 1.11 무료 및 공개 소스 운영체제(Free and open source operating systems)

- 방대한 양의 무료 소프트웨어 및 공개 소스 릴리스를 통해 운영체제에 관한 연구가 쉬워졌다
- 무료 운영체제와 공개 소스 운영체제는 컴파일된 이진 코드가 아닌 소스 코드형식으로 제공된다
- 무료 소프트웨어(때로는 free/libre software라고도 함)는 소스코드를 공개할 뿐만 아니라 무료 사용, 재배포 및 수정을 허용하도록 라이선스를 받게 된다
- 공개 소프트웨어가 반드시 그러한 라이선스를 제공하지는 않는다
- 일부 공개 소프트웨어는 '무료'가 아니다
- GNU/Linux는 가장 유명한 공개 소스 운영체제이며, 일부 배포판은 무료이고 다른 배포판은 단지 공개 소스일 뿐이다
- 비공개 소스 운영체제
  - Microsoft Windows
- 하이브리드 방식
  - Apple의 macOS
    - Darwin이라는 공개 소스 커널이 포함되어 있지만
    - 독점적인 비공개 소스 구성요소도 포함되어 있다

### 1.11.1 역사

- 현대 컴퓨팅의 초기(1950년대)에 소프트웨어는일반적으로 소스 코드와 함께 제공되었다
- MIT의 Tech Model Railroad Club의 원래 해커(컴퓨터 애호가)는 다른 사람들이 작업할 수 있도록 프로그램을 서랍에 남겨 두었다
- "Homebrew" 사용자 그룹은 자신들의 회의 중에 코드를 교환하였다

### 1.11.2 무료 운영체제

- 소프트웨어 사용 및 재배포를 제한하려는 움직임에 대응하기 위해 1984년 Richard Stallman은 GNU라는 free UNIX 호환 운영체제를 개발하기 시작하였다
  - 'free'는 가격이 아니라 사용의 자유를 의미한다
- 자유 소프트웨어 운동은 소프트웨어의 금전적 거래를 반대하는 것이 아니라 사용자가 다음과 같은 네 가지 자유가 보장되어야 한다고 주장한다
  - 1. 자유롭게 소프트웨어를 실행 시킬 권리
  - 2. 소스 코드를 분석하고 수정할 권리
  - 3. 코드 수정 없이 배포하거나 판매할 권리
  - 4. 코드를 수정하여 배포하거나 판매할 권리
- 1985년에 Stallman은 모든 소프트웨어가 자유로워야 한다는 GNU 선언문을 발표하였다
  - 또한 자유 소프트웨어의 사용 및 개발을 장려하기 위해 `자유 소프트웨어 재단(FSF)`을 설립하였다
- GNU General Public License(GPL)는 자유 소프트웨어가 공개되는일반 라이선스 방식이다
  - 기본적으로 GPL에서는 소스코드를 바이너리와 함께 배포하고 모든 사본(수정된 버전 포함)을 동일한 GPL라이선스로 배포해야 한다

### 1.11.3 GNU/Linux

- 무료 및 공개 소스 운영체제의 예로 GNU/Linux를 고려하자
- GNU/Linux 운영체제
  - 커널만 말할 때는 Linux라고 하지만
  - GNU 도구를 포함한 전체 운영체제는 GNU/Linux라고 부른다

### 1.11.4 BSD Unix

- BSD UNIX는 Linux보다 오래되고 복잡한 역사를 가지고 있다
- 1978년에 AT&Tdml vktodanffh cnfqkfgkduTek
- Linux와 마찬가지로 FreeBSD, NetBSD, ... 등 여러 배포판이 존재한다
- 버전 제어 시스템
  - subversion
  - git
- macOS의 핵심 커널 구성요소인 Darwin은 BSD UNIX에 기반을 두고 있으며 공개소스화 되어 있다

### 1.11.5 Solaris

- Solaris는 Sun Microsystems사의 Unix 기반 사용 운영체제이다

### 1.11.6 학습 도구로서 공개 소스 시스템 (Open Source Systems as Learning Tools)

- 공개 소스 운영체제를 공부하는 또 다른 장점은 다양성이다
- GNU/Linux와 BSD UNIX는 둘 다 공개 소스 운영체제이지만 각각의 목표, 유틸리티, 라이선싱 및 목적을 갖는다

#### 운영체제의 학습

- 현재가 운영체제를 학습하기에 가장 쉬운 시기이다
- 오픈소스 운동이 운영체제를 덮쳐 많은 운영체제가 `소스`와 `이진(실행 가능)` 포맷으로 이용 가능하게 되었다
  - 두 포맷으로 이용 가능한 운영체제의 리스트에는 Linux, BSD UNIX, Solaris 및 macOS 일부가 있다
- 오픈 소스 운영체제의 등장은 학생에서 운영체제 개발자로 쉽게 전향할 수 있게 만들었다
- 약간의 지식, 약간의 노력과 인터넷 연결이 있으면 학생이라도 새로운 운영체제 배포판을 만들 수 있다
- 몇 년 전만해도 소스코드를 보기가 어렵거나 아에 불가능했다
- 이제는 그러한 접근이 가능하다

## 1.12 요약

- 운영체제는 컴퓨터 하드웨어를 관리하고 응용 프로그램 실행 환경을 제공하는 소프트웨어이다
- 인터럽트는 하드웨어가 운영체제와 상호 작용하는 주요 방법이다
- 하드웨어 장치는 CPU에 신호를 보내 인터럽트를 촉발하여 일부 이벤트에 주의가 필요하다는 것을 CPU에 경고한다
  - 인터럽트는 인터럽트 핸들러에 의해 관리된다
- 컴퓨터가 프로그램을 실행하려면 프로그램이 메인 메모리에 있어야 한다
  - 이 메모리는 프로세서가 직접 액세스 할 수 있는 유일한 대용량 저장장소이다
- 메인메모리는 일반적으로 전원을 끄거나 잃을 때 내용이 손실되는 휘발성 저장장치이다
- 비휘발성 저장장치는 메인 메모리의 확장이며 대량의 데이터를 영구적으로 보유할 수 있다
- 가장 일반적인 비휘할성 저장장치는 프로그램과 데이터를 모두 저장할 수 있는 하드디스크이다
- 컴퓨터 시스템의 다양한 저장장치 시스템은 속도와 비용에 따라 계층 구조로 구성할 수 있다
  - 레벨이 높을 수록 비싸지만 속도가 빠르다
  - 계층이 내려갈 수록 일반적으로 비트당 비용은 감소하고 반면액세스 시간은 증가한다
- 최신 컴퓨터 아키텍처는 각 CPU에 여러 컴퓨팅 코어가 포함된 다중 처리기 시스템이다
- CPU를 최대한 활용하기 위해 최신 운영체제는 다중 프로그래밍을 사용하여 여러 작업을 동시에 메모리에 적재할 수 있으므로 항상 CPU가 실행할 작업이 있게 보장한다
- 다중 태스킹은 CPU 스케줄링 알고리즘이 프로세스 간에 빠르게 전환하여 사용자에게 빠른 응답 시간을 제공하는 다중 프로그래밍의 확장이다
- 사용자 프로그램이 시스템의 올바른 작동을 방해하지 않도록 시스템 하드웨에는 사용자 모드와 커널 모드의 두 가지 모드가 있다
- 다양한 명령어가 특권을 가지며 커널 모드에서만 실행될 수 있다
  - 예를 들어 커널 모드로 전환하는명령, I/O 제어, 타이머 관리 및 인터럽트 관리가 이러한 명령어들 이다
- 프로세스는 운영체제의 기본 작업 단위이다
  - 프로세스 관리에는 프로세스 생성 및 삭제와 프로세스 간 통신 및 동기화 기법 제공이 포함된다
- 운영체제는 사용 중인 메모리 영역과 사용 중인 프로세스를 추적하여 메모리를 관리한다
  - 또한 메모리 공간을 동적으로 할당하고 해제해야 한다
- 저장장치 공간은 운영체제에서 관리한다
  - 이러한 책무에는 파일 및 디렉터리를 나타내는 파일 시스템을 제공하고 대용량 저장장치의 공간을 관리하는 것이 포함된다
- 운영체제는 운영체제 및 사용자를 보호하고 안전하게 만들기 위한 기법을 제공한다
  - 보호 조치는 컴퓨터 시스템에서 사용 가능한자원에 대한 프로세스 또는 사용자의 액세스를 제어한다
- 가상화에는 컴퓨터 하드웨어를 여러 가지 실행 환경으로 추상화하는 작업이 포함된다
- 운영체제에서 사용되는 자료구조에는 리스트, 스택, 큐, 트리 및 맵이 포함된다
- 컴퓨팅은 전통적인 컴퓨팅, 모바일 컴퓨팅, 클라이언트-서버 시스템, 피어간 시스템, 클라우드 컴퓨팅 및 실시간 임베디드 시스템을 포함한 다양한 환경에서 이루어 진다
- 무료 및 공개 소스 운영체제는 소스 코드 형식으로 제공된다
  - 무료 소프트웨어는 무료로 사용, 재배포 및 수정이 가능하다
  - GNU/Linux, FreeBSD 및 Solaris는 널리 사용되는 공개 소스 시스템의 예이다

## 연습 문제

- https://kkalkkalparrot.tistory.com/52
- https://engineeringcode.tistory.com/138

- 1.1 운영체제의 세 가지 주요 목적은 무엇인가
- 1.2 컴퓨팅 하드웨어를 효율적으로 사용하려면 운영체제가 필요하다고 강조하였다
  - 운영체제가 이 원칙을 버리고 자원을 낭비하는 것이 적절한 때는 언제인가?
  - 그러한 시스템이 실제로 낭비하는 것이 아닌 이유는 무엇인가?
- 1.3 실시간 환경을 위해 운영체제를 작성할 때 프로그래머가 극복해야 하는 주요 어려움은 무엇인가?
- 1.4 운영체제의 다양한정의를 염두에 두고 운영체제에 웹 브라우저 및 메일 프로그램과 같은 응용 프로그램이 포함되어야 하는지 생각해보라
  - 포함시킨다와 포함시키지 않는다는 주장 모두의 입장에서 논증하라
- 1.5 커널 모드와 사용자 모드의 구별은 기본적인 형태의 보호(보안)로서 어떤 기능을 하는가?
- 1.6 다음 중 특권 명령이어야 하는 명령어는 무엇인가?
- 1.7 일부 초기 컴퓨터는 운영체제를 사용자 작업이나 운영체제 자체에서 수정할 수 없는 메모리 파틴션에 배치하여 운영체제를 보호하였다
  - 이러한 기법에서 발생할 수 있다고 생각되는 두 가지 어려움을 설명하라
- 1.8 일부 CPU는 세 개 이상의 작동 모드를 제공한다
  - 이 다중 모드를 사용할 수 있는 두 가지 경우는 무엇인가?
- 1.9 타이머는 현재 시간을 계산하는 데 사용될 수 있다.
  - 어떻게 계산이 가능한지 간단하게 설명하라
- 1.10 캐시가 유요한 두 가지 이유를 제시하라
  - 어떤 문제를 해결할 수 있는가?
  - 어던 문제를 야기하는가?
  - 캐시의 크기를 캐싱하는 장치만큼 크게 만들 수 있다면 (예: 디스크의 크기와 같은 캐시) 캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 무엇인가?
- 1.11 분산 시스템의 클라이언트-서버 시스템과 피어 간 모델의 차이를 설명하라
