
# 1. 서론
운영체제(operating system)는 컴퓨터 하드웨어를 관리하는 프로그램이다.  
또한 응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 실행한다.

운영체제는 덩치가 매우 크고 복잡하기 때문에 부분별로 생성되어야 한다. 각 부분은 전체 시스템 윤곽에 잘 부합하여야 하며, 각 부분의 입력과 출력, 동작은 명확하게 정의되어야 한다.

<br>

## 1.1. 운영체제가 하는 일

- 컴퓨터 시스템은 대개 네 가지 구성요소인 **하드웨어, 운영체제, 응용 프로그램, 사용자**로 구분할 수 있다.  
    - '**하드웨어**'는 **중앙처리장치(CPU), 메모리 및 입출력(I/O)** 장치로 구성되어 **기본 계산용 자원**을 제공한다.
    - '**응용 프로그램**'인 워드 프로세서 스프레드시트, 컴파일러, 그리고 웹 브라우저 등은 사용자의 계산 문제를 해결하기 위해 **이들 자원이 어떻게 사용될지를 정의**한다.

<br>

### 1.1.1. 사용자 관점
컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.

**1. 모니터, 키보드, 마우스 및 시스템 유니트로 구성된 pc의 사용자**
- 이러한 시스템은 한 사용자가 자원들 독점하도록 설계되었으며, 목표는 사용자가 실행하는 작업(또는 놀이)를 최대화하는 것이다.  
- 성능도 중요하지만 이런 시스템들은 다수 사용자의 요구사항을 만족시키기 보다는 한 사용자가 사용하기에 적합하도록 최적화된다.  
<br>

**2. 대형 컴퓨터나 미니 컴퓨터에 연결된 터미널의 사용자**
- 다른 사용자들은 동일한 컴퓨터를 다른 터미널을 통해 접근하고 있다.
- 이들 사용자들은 자원을 공유하며 정보를 교환할 수 있다.  
- 이 경우 운영체제는 자원 이용을 극대화하도록 설계된다.  
<br>

**3. 다른 워크스테이션과 서버의 네트워크에 연결된 워크스테이션의 사용자**
- 이들 사용자들은 자신이 맘대로 할 수 있는 전용 자원을 갖지만, 
- 또한 네트워킹과 서버-파일, 계산 및 프린트 서버를 공유한다.  
<br>

**4. 휴대용 컴퓨터 (개인 사용자들을 위한 독립형 장치)**
- 일부는 회선으로 직접 또는 무선 모뎀이나 네트워킹을 통해 네트워크에 연결된다.
- 전력과 속도, 인터페이스 제약 때문에 이들은 원격 연산의 실행이 비교적 적다.
<br>

**5. 사용자 관점이 존재하지 않거나 매우 작은 경우**
- 예) 가전제품, 자동차 내의 내장형 컴퓨터
- 이들 컴퓨터나 운영체제는 사용자의 개입 없이 작동하도록 설계되어 있다.

<br>
<br>

### 1.1.2. 시스템 관점
**1. '자원 할당자' 관점**
- 컴퓨터의 관점에서 '운영체제'는 '하드웨어'와 가장 친밀한 프로그램이다.
- 따라서 운영체제를 **자원 할당자(resource allocator)**로 볼 수 있다.
- 컴퓨터 시스템은 문제를 해결하기 위해 요구되는 여러 가지 자원들(하드웨어와 소프트웨어) 즉 CPU 시간, 메모리 공간, 파일 저장 공간, 입출력장치 등을 가진다.

**2. 운영체제는 '제어 프로그램'**
- 운영체제는 여러 입출력장치와 사용자 프로그램을 제어하는 '제어 프로그램'이라고 보는 관점이 있다. 
- 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 실행을 제어한다.

<br>
<br>

### 1.1.3. 운영체제의 정의
- 일반적으로 운영체제에 대한 완벽한 정의는 없다.

- 보통 우리가 따르는 정의에 의하면, 운영체제는 컴퓨터에서 항상 실행되는 프로그램으로 '**커널**'이라 불린다.

- 이때, 커널과 대비하여 두 유형의 다른 프로그램이 존재한다.  
(1) '시스템 프로그램' - 운영체제와 연관되어 있으나 커널의 일부분이 아닌 프로그램  
(2) '응용 프로그램' - 시스템의 운영과는 상관이 없는 다른 모든 프로그램

<br>

- **운영체제가 존재하는 이유**
    - 우선, 컴퓨터의 근본 목적은 '사용자 프로그램을 실행하고, 사용자의 문제를 보다 쉽게 해결해주기 위함'이다.
    - 이 목적을 위해 하드웨어가 제작 되었고, 순수 하드웨어만으로는 사용하기 쉽지 않아 응용 프로그램이 개발되었다.
    - 다양한 프로그램들은 입출력장치의 통제와 같은 공통적인 연산을 필요로 한다.
    - 여기에 **자원을 제어하고 할당하는 기능을 하나의 소프트웨어로 통합한 것**이 '운영체제'다.

<br>

- **참고 : 비트(bit)**
    - 비트는 컴퓨터 저장장치의 기본 단위로, 컴퓨터의 모든 저장장치는 비트의 집합에 기반을 둔다.
    - 비트는 0과 1의 두 값 중 한 가지를 표현할 수 있다.
    - 바이트(byte)는 8비트이고, 대부분의 컴퓨터에서 편리한 가장 작은 저장 묶음
    - 1KB는 1024바이트, 1MB는 1024\*1024 바이트, 1GB는 1024\*1024\*1024 바이트이다.

<br>

- **참고 2 : 워드(word)**
    - 대상 컴퓨터의 선천적인(native) 저장 단위를 뜻함
    - 일반적으로 하나 이상의 바이트로 구성된다.
    - 예를 들어, 어떤 컴퓨터는 64비트(8바이트) 워드를 이동시킬 수 있는 명령어를 제공한다. 

<br>
<br>
<br>

## 1.2. 컴퓨터 시스템의 구성

<br>

- **참고 : 운영체제와 오픈소스**
    - 오픈 소스 운동은 운영체제 영역까지 확대되었으며, 많은 운영체제가 소스와 이진(실행가능)의 형태로 배포되었다.
    - Linux, BSD Unix, Solaris 및 Mac OS X의 일부가 포함된다.
    - 즉, 운영체제의 소스코드 자체를 조사하여 찾을 수 있고, 적은 수의 CPU, 메모리 및 저장장치 자원이 지원되던 시절에 어떻게 동작했는지 공부할 수 있다.

<br>
<br>

### 1.2.1. 컴퓨터 시스템 동작(Computer-System Operation)

- 현대의 범용 컴퓨터 시스템은 **여러 개의 장치 제어기와 하나 이상의 CPU로 구성**되어 있으며, 이들은 **공유 메모리에 대한 접근을 제공하는 '공통 버스**'를 통해 연결되어 있다.
    - 각 장치 제어기는 특정 장치(예 : 디스크 드라이브, 오디오 장치, 비디오 디스플레이 등)를 관리한다.
    - CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병행 실행될 수 있다.
    - 공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공되며, 그 기능은 메모리 접근을 동기화하는 일이다.

<br>

- 컴퓨터가 구동을 시작하기 위해서는(예 : 전원이 켜지거나 재부트될 때) 실행할 **초기 프로그램(부트스트랩 프로그램(bootstrap program**)을 가지고 있어야 한다.

    - 부트스트랩 프로그램은 매우 단순한 형태를 가지는 것이 일반적이며
    - 보통 '펌웨어'로 알려져 있는 컴퓨터 내의 읽기 전용 메모리(ROM, Read-Only Memory) 또는 EEPROM에 저장된다.    
    - 부트스트랩 프로그램은 CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 **시스템의 모든 면을 초기화**한다.  
    
    <br>

    - 또한 부트스트랩 프로그램은 **운영체제를 '적재'하는 방법 및 '실행'을 시작하는 방법**을 알아야 한다.  
        - 운영체제의 커널을 찾아 메모리에 적재하고,  
        - 그 다음 운영체제는 'init'과 같은 첫 번째 프로세스를 실행하고,  
        - 어떤 사건(event)이 발생하기를 기다린다.  
        <br>
        - 사건이 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 '인터럽트(interrupt)에 의해 신호가 보내어진다.
            - 하드웨어는 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있고,              
            - 소프트웨어는 시스템 호출(system call 또는 모니터 호출)이라 불리는 특별한 연산을 실행하여 인터럽트를 발생시킬 수 있다.  
        <br>
        - CPU가 인터럽트되면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다.
            - 이 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다.
        - 그리고 인터럽트 서비스 루틴이 실행된다.
        - 인터럽트 서비스 루틴 실행이 완료되면 CPU는 인터럽트 되었던 연산을 재개한다.

<br>
<br>

- '**인터럽트**'는 컴퓨터 구조의 중요한 부분이다.  
    - 인터럽트는 적절한 서비스 루틴으로 제어를 전달하고, 이 루틴은 이어 인터럽트 고유의 핸들러(handler)를 호출한다.

    <br>

    - 그러나 **인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있다.** 따라서 대신 '**인터럽트 루틴에 대한 포인터들의 테이블**'을 이용할 수 있다. 
        - 중간 루틴을 둘 필요 없이 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.
        - 일반적으로 포인터들의 테이블은 하위 메모리에 저장된다. 이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다.
       - 인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 '인터럽트 벡터'가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.  
    <br>
    - 또한 인터럽트 구조는 **인터럽트된 명령의 주소를 반드시 저장**해야 한다.  
        - 최근의 구조에선 **시스템 스택에 복귀 주소를 저장**한다.  
        - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(예: 레지스터의 값을 변경하여)가 있다면, 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장해야 하며, 복귀하기 전에 상태를 복원해야 한다.  
    <br>    
    - 인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고,
    - 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생하지 않았던 것처럼 다시 시작된다.


<br>
<br>

### 1.2.2. 저장장치 구조(Storage Structure)

<br>

#### **메모리**



- **CPU는 오직 메모리로부터 명령을 적재할 수 있으며, 실행하고자 하는 프로그램은 모두 메모리에 저장**되어야 한다. 
    - 범용 컴퓨터는 **대부분의 프로그램을 읽기-쓰기 가능한 메모리인 주 메모리(Ramdom-Access Memory, 또는 RAM)에서 실행**시킨다.
    - 또한 컴퓨터는 다른 형태의 메모리, 'Read-Only memory(ROM)'을 사용한다. ROM은 변경 불가능한 특성을 가지며, 오직 정적인 프로그램만이 저장된다. (예 : 게임 카트리지 제작 등)
    - EEPROM은 자주 수정될 수 없고 따라서 대부분 정적 프로그램을 저장한다. (예 : 스마트폰은 공장 설치 프로그램을 저장하는 데 EEPROM을 사용.)

<br>

- 모든 형태의 메모리들은 '워드의 배열'을 제공하며, '각 워드는 고유의 주소'를 가지고 있다.

<br>

- 상호작용은 **특정 메모리 주소들에 대한 일련의 적재(load) 또는 저장(store) 명령**을 통하여 이루어진다.
    - 적재 명령 : '**주 메모리 -> CPU 내부의 레지스터**' // (주 메모리로부터 CPU 내부의 레지스터로 한 워드를 옮기는 것)  
    - 저장 명령 : '**주 메모리 <- CPU 내부의 레지스터**' // (반대로 레지스터의 내용을 주 메모리로 옮긴다.)

- 명시적인 적재, 저장 명령 외에 **CPU는 실행을 위해 자동적으로 주 메모리로부터 명령을 적재한다.**

<br>
<br>

- 폰 노이만 구조 시스템에서 실행되는 전형적인 '명령 - 실행' 사이클  
(1) 먼저 메모리로부터 명령을 인출해 그 명령을 명령 레지스터(instruction register)에 저장한다.  
(2) 이어서 명령을 해독하고,
(3) 명령은 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 
(4) 피연산자에 대해 명령을 실행한 후 결과가 메모리에 다시 저장될 수 있다.

<br>
<br>

- 메모리 장치는 '**연속적인 메모리 주소만을 인식**'한다는 사실을 유의하라.
    - 메모리는 주소(명령 카운터(instruction counter)), 색인(indexing), 간접 주소(indirection), 리터럴 주소(literal addresses) 등)가 **어떻게 생성되었는지 알지 못하며, 그것이 무엇인지(명령인지 데이터인지) 알지 못한다.** 
    - 그러므로 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있다.

    <br>

- 이상적으로는, 프로그램과 데이터가 주 메모리에 영구히 존재하길 바라지만 다음 두 가지 이유 때문에 불가능하다.  
    (1) 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.  
    (2) 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.

<br>
<br>

#### **여러 저장장치 시스템**

- 그러나 큰 관점에서 우리가 기술한 이러한 저장장치 구조(레지스터, 주 메모리, 자기 디스크 등으로 구성된)는 여러 가능한 저장장치 시스템 중 하나이다. 이외에도 캐시 메모리, CD-ROM, 자기테이프 등이 있다.   
    - 각 저장장치 시스템은 데이터를 저장하고 이들이 나중에 인출될 때까지 보관하는 기본 기능을 제공한다.   
    - 이 다양한 저장장치 시스템간의 주된 차이점은 **속도, 가격, 크기, 휘발성 등**이다.

<br>


- 저장장치 시스템의 넓은 다양성은 **속도와 가격**에 따라 하나의 계층으로 구성될 수 있다. 
    - 상위 수준은 가격이 비싸지만 빠르다.
    - 계층 구조 아래로 갈수록 일반적으로 비트당 비용은 감소하며, 반면에 접근 시간은 증가한다.  

<br>

- 서로 다른 비용과 속도를 갖는 것 외에도 여러 저장 시스템은 휘발성이거나 비휘발성이다.
    - 휘발성 저장장치는 전원이 제거되면 저장하고 있는 내용을 잃게 된다.
    - 데이터를 보관하려면 반드시 비휘발성 저장장치에 기록해야 한다.  

    <br>

    - 그림 1.4.에서 전자디스크 이상의 저장 시스템은 휘발성이며, 반면에 전자디스크 아래의 장치들은 비휘발성이다.  

    - 전자디스크는 휘발성 또는 비휘발성 중 하나가 되도록 설계할 수 있다.
        - 전자적 디스크는 **정상 작동 중에는 데이터를 휘발성인 큰 DRAM 배열에 저장**한다.
        - **그러나 많은 전자적 디스크 장치는 숨겨져 있는 자기 하드디스크와 예비 전력용 배터리를 포함하고 있다.**
        - **만일 외부 전원이 중단되면, 전자디스크의 제어기가 데이터를 RAM으로부터 자기디스크로 복사한다.**

    <br>

    - 다른 형태의 전자디스크는 '플래시 메모리'이다.
        - 카메라, 개인 휴대용 정보 단말기(PDA), 로봇에 널리 사용되고 있으며 점차 범용 컴퓨터의 이동성 디스크로 영역을 확대하고 있다.  
    
    <br>

    - 또 다른 형태의 비휘발성 저장장치 'NVRAM'
        - 배터리 장치를 가진 DRAM이라고 볼 수 있다.
        - DRAM만큼 빠르지만 비휘발성을 유지할 수 있는 기간이 제한된다.

<br>
<br>

- 완전한 메모리 시스템의 설계는 이러한 모든 요인들 간의 균형을 맞추어야 한다. 
    - 필요한 만큼만 값비싼 메모리를 사용하고, 가능한 한 많은 저렴한 비휘발성 메모리를 제공해야 한다.
    - **두 구성요소의 전송률 또는 접근 시간의 차이가 클 경우 성능을 개선하기 위해 '캐시'가 설치**될 수 있다

<p align = center> <img src = https://user-images.githubusercontent.com/101503543/214880044-ab1b601a-bf3e-4c00-85f4-68a303ae2fd6.png width = 80%, height = 80%></p>
