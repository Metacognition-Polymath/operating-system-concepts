
# 1. 서론
운영체제(operating system)는 컴퓨터 하드웨어를 관리하는 프로그램이다.  
또한 응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 실행한다.

운영체제는 덩치가 매우 크고 복잡하기 때문에 부분별로 생성되어야 한다. 각 부분은 전체 시스템 윤곽에 잘 부합하여야 하며, 각 부분의 입력과 출력, 동작은 명확하게 정의되어야 한다.

<br>

## 1.1. 운영체제가 하는 일

- 컴퓨터 시스템은 대개 네 가지 구성요소인 **하드웨어, 운영체제, 응용 프로그램, 사용자**로 구분할 수 있다.  
    - '**하드웨어**'는 **중앙처리장치(CPU), 메모리 및 입출력(I/O)** 장치로 구성되어 **기본 계산용 자원**을 제공한다.
    - '**응용 프로그램**'인 워드 프로세서 스프레드시트, 컴파일러, 그리고 웹 브라우저 등은 사용자의 계산 문제를 해결하기 위해 **이들 자원이 어떻게 사용될지를 정의**한다.

<br>

### 1.1.1. 사용자 관점
컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.

**1. 모니터, 키보드, 마우스 및 시스템 유니트로 구성된 pc의 사용자**
- 이러한 시스템은 한 사용자가 자원들 독점하도록 설계되었으며, 목표는 사용자가 실행하는 작업(또는 놀이)를 최대화하는 것이다.  
- 성능도 중요하지만 이런 시스템들은 다수 사용자의 요구사항을 만족시키기 보다는 한 사용자가 사용하기에 적합하도록 최적화된다.  
<br>

**2. 대형 컴퓨터나 미니 컴퓨터에 연결된 터미널의 사용자**
- 다른 사용자들은 동일한 컴퓨터를 다른 터미널을 통해 접근하고 있다.
- 이들 사용자들은 자원을 공유하며 정보를 교환할 수 있다.  
- 이 경우 운영체제는 자원 이용을 극대화하도록 설계된다.  
<br>

**3. 다른 워크스테이션과 서버의 네트워크에 연결된 워크스테이션의 사용자**
- 이들 사용자들은 자신이 맘대로 할 수 있는 전용 자원을 갖지만, 
- 또한 네트워킹과 서버-파일, 계산 및 프린트 서버를 공유한다.  
<br>

**4. 휴대용 컴퓨터 (개인 사용자들을 위한 독립형 장치)**
- 일부는 회선으로 직접 또는 무선 모뎀이나 네트워킹을 통해 네트워크에 연결된다.
- 전력과 속도, 인터페이스 제약 때문에 이들은 원격 연산의 실행이 비교적 적다.
<br>

**5. 사용자 관점이 존재하지 않거나 매우 작은 경우**
- 예) 가전제품, 자동차 내의 내장형 컴퓨터
- 이들 컴퓨터나 운영체제는 사용자의 개입 없이 작동하도록 설계되어 있다.

<br>
<br>

### 1.1.2. 시스템 관점
**1. '자원 할당자' 관점**
- 컴퓨터의 관점에서 '운영체제'는 '하드웨어'와 가장 친밀한 프로그램이다.
- 따라서 운영체제를 **자원 할당자(resource allocator)**로 볼 수 있다.
- 컴퓨터 시스템은 문제를 해결하기 위해 요구되는 여러 가지 자원들(하드웨어와 소프트웨어) 즉 CPU 시간, 메모리 공간, 파일 저장 공간, 입출력장치 등을 가진다.

**2. 운영체제는 '제어 프로그램'**
- 운영체제는 여러 입출력장치와 사용자 프로그램을 제어하는 '제어 프로그램'이라고 보는 관점이 있다. 
- 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 실행을 제어한다.

<br>
<br>

### 1.1.3. 운영체제의 정의
- 일반적으로 운영체제에 대한 완벽한 정의는 없다.

- 보통 우리가 따르는 정의에 의하면, 운영체제는 컴퓨터에서 항상 실행되는 프로그램으로 '**커널**'이라 불린다.

- 이때, 커널과 대비하여 두 유형의 다른 프로그램이 존재한다.  
(1) '시스템 프로그램' - 운영체제와 연관되어 있으나 커널의 일부분이 아닌 프로그램  
(2) '응용 프로그램' - 시스템의 운영과는 상관이 없는 다른 모든 프로그램

<br>

- **운영체제가 존재하는 이유**
    - 우선, 컴퓨터의 근본 목적은 '사용자 프로그램을 실행하고, 사용자의 문제를 보다 쉽게 해결해주기 위함'이다.
    - 이 목적을 위해 하드웨어가 제작 되었고, 순수 하드웨어만으로는 사용하기 쉽지 않아 응용 프로그램이 개발되었다.
    - 다양한 프로그램들은 입출력장치의 통제와 같은 공통적인 연산을 필요로 한다.
    - 여기에 **자원을 제어하고 할당하는 기능을 하나의 소프트웨어로 통합한 것**이 '운영체제'다.

<br>

- **참고 : 비트(bit)**
    - 비트는 컴퓨터 저장장치의 기본 단위로, 컴퓨터의 모든 저장장치는 비트의 집합에 기반을 둔다.
    - 비트는 0과 1의 두 값 중 한 가지를 표현할 수 있다.
    - 바이트(byte)는 8비트이고, 대부분의 컴퓨터에서 편리한 가장 작은 저장 묶음
    - 1KB는 1024바이트, 1MB는 1024\*1024 바이트, 1GB는 1024\*1024\*1024 바이트이다.

<br>

- **참고 2 : 워드(word)**
    - 대상 컴퓨터의 선천적인(native) 저장 단위를 뜻함
    - 일반적으로 하나 이상의 바이트로 구성된다.
    - 예를 들어, 어떤 컴퓨터는 64비트(8바이트) 워드를 이동시킬 수 있는 명령어를 제공한다. 

<br>
<br>
<br>

## 1.2. 컴퓨터 시스템의 구성

<br>

- **참고 : 운영체제와 오픈소스**
    - 오픈 소스 운동은 운영체제 영역까지 확대되었으며, 많은 운영체제가 소스와 이진(실행가능)의 형태로 배포되었다.
    - Linux, BSD Unix, Solaris 및 Mac OS X의 일부가 포함된다.
    - 즉, 운영체제의 소스코드 자체를 조사하여 찾을 수 있고, 적은 수의 CPU, 메모리 및 저장장치 자원이 지원되던 시절에 어떻게 동작했는지 공부할 수 있다.

<br>
<br>

### 1.2.1. 컴퓨터 시스템 동작(Computer-System Operation)

- 현대의 범용 컴퓨터 시스템은 **여러 개의 장치 제어기와 하나 이상의 CPU로 구성**되어 있으며, 이들은 **공유 메모리에 대한 접근을 제공하는 '공통 버스**'를 통해 연결되어 있다.
    - 각 장치 제어기는 특정 장치(예 : 디스크 드라이브, 오디오 장치, 비디오 디스플레이 등)를 관리한다.
    - CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병행 실행될 수 있다.
    - 공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공되며, 그 기능은 메모리 접근을 동기화하는 일이다.

<br>

- 컴퓨터가 구동을 시작하기 위해서는(예 : 전원이 켜지거나 재부트될 때) 실행할 **초기 프로그램(부트스트랩 프로그램(bootstrap program**)을 가지고 있어야 한다.

    - 부트스트랩 프로그램은 매우 단순한 형태를 가지는 것이 일반적이며
    - 보통 '펌웨어'로 알려져 있는 컴퓨터 내의 읽기 전용 메모리(ROM, Read-Only Memory) 또는 EEPROM에 저장된다.    
    - 부트스트랩 프로그램은 CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 **시스템의 모든 면을 초기화**한다.  

    <br>

    - 또한 부트스트랩 프로그램은 **운영체제를 '적재'하는 방법 및 '실행'을 시작하는 방법**을 알아야 한다.  
        - 운영체제의 커널을 찾아 메모리에 적재하고,  
        - 그 다음 운영체제는 'init'과 같은 첫 번째 프로세스를 실행하고,  
        - 어떤 사건(event)이 발생하기를 기다린다.  

        <br>

        - 사건이 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 '인터럽트(interrupt)에 의해 신호가 보내어진다.
            - 하드웨어는 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있고,              
            - 소프트웨어는 시스템 호출(system call 또는 모니터 호출)이라 불리는 특별한 연산을 실행하여 인터럽트를 발생시킬 수 있다.  

        <br>

        - CPU가 인터럽트되면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다.
            - 이 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다.
        - 그리고 인터럽트 서비스 루틴이 실행된다.
        - 인터럽트 서비스 루틴 실행이 완료되면 CPU는 인터럽트 되었던 연산을 재개한다.

<br>
<br>

- '**인터럽트**'는 컴퓨터 구조의 중요한 부분이다.  
    - 인터럽트는 적절한 서비스 루틴으로 제어를 전달하고, 이 루틴은 이어 인터럽트 고유의 핸들러(handler)를 호출한다.

    <br>

    - 그러나 **인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있다.** 따라서 대신 '**인터럽트 루틴에 대한 포인터들의 테이블**'을 이용할 수 있다. 
        - 중간 루틴을 둘 필요 없이 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.
        - 일반적으로 포인터들의 테이블은 하위 메모리에 저장된다. 이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다.
       - 인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 '인터럽트 벡터'가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.  

    <br>

    - 또한 인터럽트 구조는 **인터럽트된 명령의 주소를 반드시 저장**해야 한다.  
        - 최근의 구조에선 **시스템 스택에 복귀 주소를 저장**한다.  
        - 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(예: 레지스터의 값을 변경하여)가 있다면, 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장해야 하며, 복귀하기 전에 상태를 복원해야 한다.  

    <br>    
    
    - 인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고,
    - 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생하지 않았던 것처럼 다시 시작된다.


<br>
<br>

### 1.2.2. 저장장치 구조(Storage Structure)

<br>

#### **메모리**



- **CPU는 오직 메모리로부터 명령을 적재할 수 있으며, 실행하고자 하는 프로그램은 모두 메모리에 저장**되어야 한다. 
    - 범용 컴퓨터는 **대부분의 프로그램을 읽기-쓰기 가능한 메모리인 주 메모리(Ramdom-Access Memory, 또는 RAM)에서 실행**시킨다.
    - 또한 컴퓨터는 다른 형태의 메모리, 'Read-Only memory(ROM)'을 사용한다. ROM은 변경 불가능한 특성을 가지며, 오직 정적인 프로그램만이 저장된다. (예 : 게임 카트리지 제작 등)
    - EEPROM은 자주 수정될 수 없고 따라서 대부분 정적 프로그램을 저장한다. (예 : 스마트폰은 공장 설치 프로그램을 저장하는 데 EEPROM을 사용.)

<br>

- 모든 형태의 메모리들은 '워드의 배열'을 제공하며, '각 워드는 고유의 주소'를 가지고 있다.

<br>

- 상호작용은 **특정 메모리 주소들에 대한 일련의 적재(load) 또는 저장(store) 명령**을 통하여 이루어진다.
    - 적재 명령 : '**주 메모리 -> CPU 내부의 레지스터**' // (주 메모리로부터 CPU 내부의 레지스터로 한 워드를 옮기는 것)  
    - 저장 명령 : '**주 메모리 <- CPU 내부의 레지스터**' // (반대로 레지스터의 내용을 주 메모리로 옮긴다.)

- 명시적인 적재, 저장 명령 외에 **CPU는 실행을 위해 자동적으로 주 메모리로부터 명령을 적재한다.**

<br>
<br>

- 폰 노이만 구조 시스템에서 실행되는 전형적인 '명령 - 실행' 사이클  
(1) 먼저 메모리로부터 명령을 인출해 그 명령을 명령 레지스터(instruction register)에 저장한다.  
(2) 이어서 명령을 해독하고,
(3) 명령은 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 
(4) 피연산자에 대해 명령을 실행한 후 결과가 메모리에 다시 저장될 수 있다.

<br>
<br>

- 메모리 장치는 '**연속적인 메모리 주소만을 인식**'한다는 사실을 유의하라.
    - 메모리는 주소(명령 카운터(instruction counter)), 색인(indexing), 간접 주소(indirection), 리터럴 주소(literal addresses) 등)가 **어떻게 생성되었는지 알지 못하며, 그것이 무엇인지(명령인지 데이터인지) 알지 못한다.** 
    - 그러므로 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있다.

    <br>

- 이상적으로는, 프로그램과 데이터가 주 메모리에 영구히 존재하길 바라지만 다음 두 가지 이유 때문에 불가능하다.  
    (1) 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.  
    (2) 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.

<br>
<br>

#### **여러 저장장치 시스템**

- 그러나 큰 관점에서 우리가 기술한 이러한 저장장치 구조(레지스터, 주 메모리, 자기 디스크 등으로 구성된)는 여러 가능한 저장장치 시스템 중 하나이다. 이외에도 캐시 메모리, CD-ROM, 자기테이프 등이 있다.   
    - 각 저장장치 시스템은 데이터를 저장하고 이들이 나중에 인출될 때까지 보관하는 기본 기능을 제공한다.   
    - 이 다양한 저장장치 시스템간의 주된 차이점은 **속도, 가격, 크기, 휘발성 등**이다.

<br>


- 저장장치 시스템의 넓은 다양성은 **속도와 가격**에 따라 하나의 계층으로 구성될 수 있다. 
    - 상위 수준은 가격이 비싸지만 빠르다.
    - 계층 구조 아래로 갈수록 일반적으로 비트당 비용은 감소하며, 반면에 접근 시간은 증가한다.  

<br>

- 서로 다른 비용과 속도를 갖는 것 외에도 여러 저장 시스템은 휘발성이거나 비휘발성이다.
    - 휘발성 저장장치는 전원이 제거되면 저장하고 있는 내용을 잃게 된다.
    - 데이터를 보관하려면 반드시 비휘발성 저장장치에 기록해야 한다.  

    <br>

    - 그림 1.4.에서 전자디스크 이상의 저장 시스템은 휘발성이며, 반면에 전자디스크 아래의 장치들은 비휘발성이다.  

    - 전자디스크는 휘발성 또는 비휘발성 중 하나가 되도록 설계할 수 있다.
        - 전자적 디스크는 **정상 작동 중에는 데이터를 휘발성인 큰 DRAM 배열에 저장**한다.
        - **그러나 많은 전자적 디스크 장치는 숨겨져 있는 자기 하드디스크와 예비 전력용 배터리를 포함하고 있다.**
        - **만일 외부 전원이 중단되면, 전자디스크의 제어기가 데이터를 RAM으로부터 자기디스크로 복사한다.**

    <br>

    - 다른 형태의 전자디스크는 '플래시 메모리'이다.
        - 카메라, 개인 휴대용 정보 단말기(PDA), 로봇에 널리 사용되고 있으며 점차 범용 컴퓨터의 이동성 디스크로 영역을 확대하고 있다.  
    
    <br>

    - 또 다른 형태의 비휘발성 저장장치 'NVRAM'
        - 배터리 장치를 가진 DRAM이라고 볼 수 있다.
        - DRAM만큼 빠르지만 비휘발성을 유지할 수 있는 기간이 제한된다.

<br>
<br>

- 완전한 메모리 시스템의 설계는 이러한 모든 요인들 간의 균형을 맞추어야 한다. 
    - 필요한 만큼만 값비싼 메모리를 사용하고, 가능한 한 많은 저렴한 비휘발성 메모리를 제공해야 한다.
    - **두 구성요소의 전송률 또는 접근 시간의 차이가 클 경우 성능을 개선하기 위해 '캐시'가 설치**될 수 있다

<p align = center> <img src = https://user-images.githubusercontent.com/101503543/214880044-ab1b601a-bf3e-4c00-85f4-68a303ae2fd6.png width = 80%, height = 80%></p>

<br>

### 1.2.3. 입출력 구조(I/O Structure)

- 저장장치는 컴퓨터 내의 여러 형태의 입출력장치 중 하나이다. 
- 운영체제 코드의 많은 부분들이 입출력을 관리하는 데 할애된다.  
<br>  
- 범용 컴퓨터 시스템은 **공통 버스**에 의해 연결된 **여러 개의 장치 제어기와 CPU들로 구성**된다. 

#### 장치 제어기
- 각 장치 제어기는 특정 타입의 장치를 담당하며, 장치 제어기에 따라 하나 이상의 장치가 부착될 수 있다.
- 장치 제어기는 약간의 **로컬 버퍼 저장장치**와 **특수 목적용 레지스터 집합**을 유지한다.  
- 장치 제어기는 자신이 제어하는 주변 장치와 자신의 로컬 버퍼 저장장치 사이의 **데이터 전송을 담당**한다.  
<br>
- 통상적으로 운영체제는 각 장치 제어기마다 **디바이스 드라이버**를 가지고 있다. 이 디바이스 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분들에게 장치에 대한 일관된 인터페이스를 제공한다.  
<br>
- 입출력 연산을 시작하기 위해 **디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재**한다. 
- 장치 제어기는 이어 취할 동작(예 : "키보드에서 한 문자를 읽어라")을 결정하기 위해 이들 레지스터의 내용을 조사한다.  
- **제어기는 장치로부터 자신의 로컬 버퍼로 데이터 전송을 시작**한다.  
- 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료했음을 **인터럽트를 이용하여 디바이스 드라이버에게 통보**한다. 
데이터 또는 데이터에 대한 포인터를 같이 반환할 수도 있다.
<br>
<br>

#### **DMA**
- 위의 [ **인터럽트 구동 방식의 입출력** ] 은 적은 양의 데이터를 전송하는 데에는 문제가 없으나 **디스크 입출력과 같은 대량의 데이터를 전송하는 데에는 높은 오버헤드를 초래**한다.
- 이 문제를 해결하기 위하여 [ **직접 메모리 접근(Direct memory Access, DMA) 장치 ] 가 사용**된다.
- 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 **장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송**한다.
- 속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생하는 것이 아니라 **블록 전송이 완료될 때마다 인터럽트가 발생**한다.
- 따라서 장치 제어기가 전송 작업을 실행하고 있는 동안 CPU는 다른 작업을 실행할 수 있다.  
<br>
- 몇몇 고가의 시스템은 버스 대신에 **스위치** 구조를 사용한다.  
    - 이러한 시스템에서는 **공유 버스를 사용하기 위한 사이클을 경쟁하지 않고** 다수의 구성요소들이 다른 구성요소들과 **동시에 통신하는 것이 가능**하다.  
    - **이 경우 DMA의 사용은 더욱 효과적**이다.

<br>
<br>

![image](https://user-images.githubusercontent.com/101503543/215237407-46ec0b82-fd3b-4b4b-a95a-e038b3f28d30.png)

<br>
<br>
<br>

## 1.3.컴퓨터 시스템 구조(Computer-System Architecture)

컴퓨터 시스템은 사용된 **범용 처리기의 개수**에 따라 다양한 방식으로 분류될 수 있다.

<br>

### 1.3.1. 단일처리기 시스템(Single-Processor System)

- 대부분의 시스템은 **하나의 처리기**를 사용하며, **전용 처리기**를 가지고 있다.

- 단일처리기 시스템은 사용자 프로세스의 명령어를 포함하여 범용 명령어 집합을 실행할 수 있는 **하나의 주 CPU를 가진다**.

- 전용 처리기는 디스크나 키보드 또는 그래픽 제어기와 같은 특정 장치 처리기의 형태로 제공되거나, 메인프레임에서와 같이 시스템의 구성요소들 간 데이터를 빠르게 전송할 수 있는 입출력 처리기와 같은 **범용 처리기**에 가까운 형태로 제공될 수 있다.

- 때로 **이 처리기들은 운영체제에 의해 관리**되기도 하는데, 운영체제는 이 처리기들이 실행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다.
    - 예를 들어,  디스크 제어기 마이크로프로세서는 주 CPU로부터 연속된 요청을 받아들여 자기 고유의 디스크 큐와 스케줄링 알고리즘을 구현한다.
    - 이 배합은 **CPU가 직접 디스크 스케줄링을 해야 하는 오버헤드를 감소**시킨다.  

<br>

- 전용 처리기의 사용은 일반적인 형태이며 그렇다고 단일처리기 시스템을 다중처리기 시스템으로 변환하지는 않는다. 범용처리기 CPU가 하나 있는 시스템은 단일처리기 시스템이다.

<br>
<br>

### 1.3.2. 다중처리기 시스템(Multiprocessor Systems)

- 단일처리기 시스템이 일반적이긴 하지만, 다중처리기 시스템(병렬 시스템 또는 강결합 시스템)은 점점 더 중요해지고 있다.

- 다중처리기 시스템은 매우 밀접한 통신을 하는 하나 이상의 처리기들을 가지며, 컴퓨터 버스, 클록, 때로는 메모리와 주변 장치를 공유한다.

<br>

#### **다중처리기 시스템의 3가지 주요 장점**

**1. 증가된 처리량(throughput)**
- 처리기 수를 증가시킴으로써 보다 짧은 시간 안에 많은 일을 실행하기를 바라지만, N개의 처리기를 사용할 경우 속도 증가율은 N배가 되지 않고 N보다 작다.
- 즉, **다수의 처리기가 하나의 태스크를 위해 협력할 경우 모든 부분이 정확히 동작하도록 유지하기 위해 약간의 오버헤드가 유발**된다. 
- 또한 공유 자원에 대한 경쟁이 더해져, 추가의 처리기에 의해 예상되는 이득을 떨어진다.

<br>

**2. 규모의 경제**
- 다중처리기 또한 여러 개의 단일 시스템에 비해 비용을 절약할 수 있는데, 이는 처리기가 주변장치, 대용량 저장장치, 전원 공급 장치를 공유하고 있기 때문이다.

<br>

**3. 증가된 신뢰성**
- 만약 기능들이 여러 개 처리기에 적절히 분산된다면 한 처리기가 고장나더라도 시스템이 정지하는 것이 아니라 단지 속도만 느려지게 된다.
- 예를 들어, 10개의 처리기에서 하나가 고장나면 나머지 9개 처리기가 작업을 나누어 실행할 수 있기 때문에, 따라서 전체 시스템이 완전히 고장나는 것이 아니라 단지 10% 정도 느리게 실행된다.

<br>

- 이처럼 하드웨어의 수준에 비례해 계속적인 서비스를 제공하는 능력을 우아한 퇴보(graceful degradation)라고 한다.  
- 어떤 시스템은 어느 하나의 구성요소의 고장에도 불구하고 동작을 계속할 수 있기 때문에 우아한 퇴보를 넘어 결함 허용(fault tolerant)적이라고 불린다.  
- 결함 허용 시스템은 오류를 탐지하고, 진단하고, 가능하다면 교정할 수 있게 하는 기법이 필요하다는 사실을 주목하라.

<br>

#### **다중처리기 시스템의 두 가지 형태**  

- **비대칭적 다중처리(asymmetric multiprocessing)**
    - 하나의 주 처리기가 시스템을 제어한다.
    - 다른 처리기들은 주 처리기의 명령을 실행하거나 미리 정의된 태스크를 실행한다.
    - 이러한 기법은 주종 관계를 정의한다.
    - 주 처리기는 작업을 스케줄하고, 종속 처리기에 작업을 할당한다.

<br>

- **대칭적 다중처리(symmetric multiprocessing)를 사용한다.**
    - 대칭적 다중처리(SMP)는 모든 처리기가 대등하다는 것으르 의미한다.
    - 처리기 간에는 주종 관계가 없다.
    - 각 처리기는 자신 고유의 레지스터 집합과 사적인 또는 지역적인 캐시를 가지고 있다. (반면 물리메모리는 모든 처리기가 공유)  
    - Windows, Windows XP, Solaris, Mac OS X, Linux 등 거의 모든 현대 운영체제가 SMP를 지원한다.  
    <br>
    - SMP의 예 : Solaris
        - **수십 개의 처리기를 장착하도록 구성**될 수 있으며, **각 처리기는 모두 Solaris를 실행**한다.
        - 이 모델의 장점 : **중대한 성능 저하를 일으키지 않고 많은 프로세스들이 동시에 실행될 수 있다**는 점(N개 CPU가 있으면 N개의 프로세스가 실행 가능)
        - 주의할 점
            - **데이터가 해당 처리기에 올바르게 전달되도록 반드시 조심스럽게 입출력을 제어해야 한다**.
            - 또한 CPU가 분리되어 있어 한 cPU가 쉬고 있는 상태에서 다른 CPU는 부하가 과다하여 비효율을 야기할 수 있다.
            - 이와 같은 비효율은 처리기들이 일부 자료 구조를 공유할 경우 피할 수 있다.  
            <br>
        - 이러한 형태의 다중 처리기 시스템은 다수의 처리기간에 프로세스 자원(메모리 같은)이 동적으로 공유되게 할 것이고, 처리기간의 불균형을 줄일 수 있다.
        - 이러한 시스템은 반드시 신중하게 설계되어야 한다. -> 6장 참고


<p align = center><img src=https://user-images.githubusercontent.com/101503543/215238890-c0e979b8-91ff-42fb-b775-afe7f0122761.png width = 80%, height = 80%></p>

<br>
<br>
<br>

### 대칭적 다중처리와 비대칭적 다중처리의 차이점

- 이 둘의 차이점은 하드웨어나 소프트웨어로부터 기인한다.

- 특수한 하드웨어가 다중처리기들을 차별화할 수 있으며, 또는 한 개의 주 처리기와 다수의 종 처리기를 허용하도록 소프트웨어를 설계할 수도 있다.
    - 예 : 동일한 하드웨어 상에서 Sun의 운영체제인 SunOS 버전 5(Solaris 2)는 대칭적 다중처리인 반면에, 버전 4는 비대칭적 다중처리를 제공한다.  

    <br>

- 다중처리는 계산 능력을 증대하기 위해 CPU를 추가한다.  
만일 CPU가 통합된 메모리 제어기를 가지고 있다면, CPU를 추가함으로써 시스템의 접근 가능한 메모리 양도 증가시키게 된다.

- 어느 경우든 다중처리는 **메모리 접근 모델을 일정한 메모리 접근(UMA)에서 차등 메모리 접근(NUMA) 형태로 변경할 수 있다.** 
    - UMA는 모든 CPU가 RAM을 접근하는데 걸리는 시간이 같은 경우로 정의된다.
    - NUMA의 경우, 메모리의 일부분에 접근하는 데 걸리는 시간이 다른 부분에 접근하는 데 걸리는 시간보다 길어지게 되며 성능에 불이익을 받게 된다.
    - 운영체제는 9.5.4절에서 논의될 자원 관리를 통하여 NUMA의 성능 불이익을 최소화할 수 있다.

<br>

- CPU를 설계하는 최근의 경향은 **하나의 칩에 여러 개의 코어(core)를 포함시키는 것**이다.
    - 근본적으로 이들은 **다중처리기 칩**이다.
    - **칩 내에서의 통신이 칩 사이의 통신보다 빠르기 때문에**
    - 또한 **현저히 적은 전력을 소모**하기 때문에
    - 다중 코어를 가진 하나의 칩이 하나의 코어를 가진 복수 칩보다 훨씬 더 효율적이다.
    - 결과적으로 **다중 코어 시스템은 특히 데이터베이스나 웹 서버와 같은, '서버 시스템'에 적합한 구조**이다.

<br>

- 그림 1.7은 같은 칩에 두 개의 코어가 장착된 이중-코어 설계이다.
    - 이 설계에서 **각 코어는 자신의 레지스터 집합과 지역 캐시를 가지고 있다**
    - 반면, 다른 설계에서는 공유 캐시 또는 지역과 공유 캐시가 조합된 형태를 사용할 수도 있다.
    - 캐시, 메모리 및 버스 경쟁과 같은 구조적 측면을 제외하면, 이 **다중 코어 CPU는 운영체제에게는 N개의 표준 처리기로 인식**되기 때문에 
    - 운영체제 설계자나 응용프로그래머에게 다중 코어 CPU는 매력적이다.

<br>



<br>
<br>
<br>

### 1.3.3. 클러스터형 시스템(Clustered Systems)

- 여러 CPU를 가진 시스템의 또 다른 유형은 '클러스터형 시스템'이다.
    - 다중 처리기 시스템과 마찬가지로 여러 개의 CPU들이 함께 계산 작업을 실행한다. 
    - 그러나 **둘 이상의 독자적 시스템 또는 노드들을 결합하여 구성한다는 점**에서 전형적인 다중처리기 시스템과 차이가 난다.  

<br>

- 클러스터형(clustered)의 정의는 분명하지 않다.
    - 많은 상업용 패키지들은 클러스터 시스템은 무엇이며 왜 한 형태가 다른 형태보다 좋은지에 대한 답을 제시하는 데 어려움을 겪고 있다.
    - 일반적으로 받아들여지는 정의에 의하면 **클러스터 컴퓨터는 저장 장치를 공유하고 근거리 통신망(Local Area Network, LAN)이나 InfiniBand와 같은 고속의 상호 연결망(interconnect)으로 연결된다**.  

<br>

- 클러스터링은 통상 높은 가용도(availability)를 제공하기 위해 사용된다. 
    - 즉, 클러스터 내 하나 이상의 컴퓨터 시스템이 고장나더라도 서비스는 계속 제공된다.
      - 클러스트 소프트웨어 중 한 층이 클러스터 노드에서 실행된다.
      - 각 노드는 하나 이상의 다른 노드(LAN으로 연결되어 있는)들을 감시한다.
      - 만일 감시받던 노드가 고장나면 감시하던 노드가 고장난 노드의 저장장치에 대한 소유권을 넘겨받고 그 노드에서 실행 중이던 응용 프로그램을 다시 시작시킨다.
      - 사용자와 응용 프로그램의 클라이언트는 잠시 동안의 서비스 중단만을 경험한다.

<br>

- 클러스터링은 비대칭적으로 또는 대칭적으로 구성될 수 있다. 
    - 비대칭형 클러스터링
        - 다른 컴퓨터들이 응용 프로그램을 실행시키는 동안 한 컴퓨터는 긴급 대기(hot-standby) 모드 상태를 유지한다. 
        - 긴급 대기 모드의 호스트는 활성 서버들을 감시하는 작업만을 실행한다.
        - 서버가 고장 난다면 긴급 대기 모드의 호스트가 활성 서버가 된다.
    - 대칭형 클러스터링
        - 대칭형 모드에서는 둘 이상의 호스트들이 응용 프로그램을 실행시키고 서로를 감시한다.
        - **가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적**이다.
        - 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행 가능해야 한다.  

<br>

- **클러스터가 네트워크로 연결된 여러 개의 컴퓨터 시스템으로 구성**되기 때문에 클러스터는 **고성능 계산(high-performance computing) 환경을 제공**하는 데 이용될 수 있다.
    - 응용 프로그램을 클러스터의 모든 컴퓨터에서 동시에 실행시킬 수 있기 때문에, 단일처리기 또는 SMP 시스템에 비해 현저히 나은 계산 능력을 제공할 수 있다.
    - 그러나 응용 프로그램이 클러스터의 이점을 활용하도록 **병렬화(parallelization)라는 기법을 사용하여 특별하게 작성**되어야 한다. 
    - 병렬화는 클러스터의 개별 컴퓨터에서 병렬적으로 실행될 수 있는 구성요소 단위로 응용 프로그램을 나눈다. 

<br>

- 다른 형태의 클러스터로, **병렬(parallel) 클러스터**와 **WAN을 이용한 클러스터링**이 있다.
    - 병렬 클러스터는 여러 호스트가 공유 저장장치 상의 동일한 데이터를 접근할 수 있게 한다.
    - 대부분의 운영체제가 여러 호스트에 의한 이러한 동시 접근을 지원하지 않으므로 병렬 클러스터는 특수 소프트웨어 버전과 특별한 릴리즈의 응용에 의해 달성된다.
    - 예 : Oracle Real Applicatio Cluster - 병렬 클러스터에서 실행하도록 설계된 Oracle의 데이터베이스 버전
        - 각 기계는 Oracle을 실행하고, 하나의 소프트웨어 층이 공유 디스크에 대한 접근을 관리한다. 
        - 각 기계는 데이터베이스 내의 모든 데이터에 대한 완전한 접근을 가진다.
        - 데이터에 대한 공유 접근을 제공하기 위하여 시스템은 접근 간의 충돌이 발생하지 않는 것을 보장하는 접근 제어와 잠금 기법을 제공해야 한다.
        - 분산 잠금 관리자(DLM, Distributed Lock Manager)라고 불리는 이 기능은 몇몇의 클러스터링 기술에 포함되어 있다.

<br>

<p align = center><img src = https://user-images.githubusercontent.com/101503543/215241306-f846ca90-28a9-472e-913f-7eab244732c2.png width=80%, height=80%></p>

<br>
<br> 
<br> 

## 1.4. 운영체제의 구조

- 운영체제는 프로그램이 실행될 환경을 제공한다.  
- 운영체제의 내부 구조는 매우 다양하지만, 많은 공통점들이 존재한다.

<br> 

- 운영체제의 가장 중요한 측면은 **다중 프로그램(multiprogram)**을 할 수 있는 능력이다.
    - 일반적으로 단일 프로그램은 CPU 또는 입출력장치를 항상 바쁘게 유지할 수 없다. 단일 사용자는 종종 여러 개의 프로그램을 실행시킨다. 
    - 다중 프로그래밍(multiprogramming)은 CPU가 항상 하나의 작업을 실행할 수 있게 구성함으로써 CPU 이용률을 증가시킨다.

<br>

<p align = center><img src = https://user-images.githubusercontent.com/101503543/215242504-3c59aa3b-a15e-4a1f-91a4-837ecfc29472.png width=80%, height=80%></p>

- 기본 아이디어는 다음과 같다(그림 1.9)
    - 운영체제는 **한 번에 여러 작업을 메모리에 적재**하는데, 주 메모리는 모든 작업을 저장하기에 너무 작기 때문에 처음에는 **디스크 상에 존재하는 작업 풀(pool)** 내에 작업들을 유지한다. 
        - 이 풀은 주 메모리 할당을 기다리며 **디스크에 존재하는 모든 프로세스들로 구성**된다.
        - 따라서 **메모리에 존재하는 작업 집합은 작업 풀 내에 유지되는 작업들의 일부**이다.

    <br>


    - **운영체제는 메모리 작업 중 하나를 선택해 실행**한다.
        - 결국 이 작업은 입출력의 종료를 기다리는 것처럼 어떤 일을 기다려야 한다.
        - 비 다중 프로그래밍(non-multiprogrammed) 시스템에서는 CPU가 쉬어야 한다. 하지만 **다중 프로그래밍 시스템에서는 운영체제가 단순히 다른 작업으로 전환해 그 작업을 실행한다.**
        - 따라서 실행될 작업이 하나라도 존재하는 한 CPU는 쉬지 않는다. 

    <br>

    - 다중 프로그래밍 시스템은 **여러 가지 시스템 자원(예 : CPU, 메모리, 주변장치)을 효율적으로 이용할 수 있는 환경을 제공하지만, 사용자가 컴퓨터 시스템과 상호작용할 수는 없다.**

    <br>
    <br>

    - **시분할(또는 멀티태스킹: multi-tasking**)은 다중 프로그래밍의 논리적 확장이다.
        - 시분할 시스템에서는 CPU가 다수의 작업들을 서로 교대로 실행하지만, 매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안 사용자들은 각자 자기의 프로그램과 상호작용할 수 있다.
        - 시분할 시스템은 대화식(interactive) 혹은, 실제 조작 가능한(hands-on) 컴퓨터 시스템을 필요로 하는데 **이 시스템은 사용자와 시스템 간에 직접적인 통신을 제공**한다.
        - 사용자는, 키보드나 마우스 같은 입력 장치를 사용하여 운영체제나 프로그램에 직접 명령하고 출력 장치의 즉각적인 응답을 기다린다. 따라서 응답 시간(response time)이 짧아야 하며, 통상 1초 정도 이내이다.

    <br>

    - **시분할 운영체제는 동시에 많은 사용자가 컴퓨터를 공유할 수 있게 한다.**
        - 시분할 시스템에서는 각각의 동작이나 명령은 대체로 짧은 경향이 있기 때문에 각 사용자는 단지 짧은 시간 동안만 CPU 시간이 필요하다.
        - **시스템이 한 사용자에서 다음 사용자로 빠르게 전환**되기 때문에, 각 사용자는 자신이 전체 컴퓨터를 전용하는 것처럼 느끼지만, **실제로는 다수의 사용자가 하나의 컴퓨터를 공유**한다.

    <br>

    - 시분할 운영체제는 각 사용자에게 시분할되는 컴퓨터의 작은 부분을 제공하기 위해 '**CPU 스케줄링'과 '다중 프로그래밍**'을 사용한다. 

        - 각 사용자는 메모리에 최소한 하나의 독립된 프로그램을 가지고 있다.
        - 메모리에 적재되어 있고, 실행되고 있는 프로그램을 일반적으로 [ **프로세스** ] 라고 한다.
        - 프로세스가 실행될 때는 전형적으로 자신이 종료되거나 입출력을 실행할 필요가 있을 때까지 아주 짧은 시간 동안만 실행된다.
        - 입출력은 대화식, 즉 입력은 사용자 키보드, 마우스 등의 장치로, 출력은 디스플레이 된다. 사람이 아무리 빠르게 입력해도 컴퓨터에겐 아주 느릴 것이다. 이러한 대화식 입력이 진행되는 동안 CPU를 쉬지 않게 하고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.

    <br>
    
    - **시분할과 다중 프로그래밍 운영체제**에서는 **메모리에 여러 작업이 동시에 유지**되어야 한다.
        - 만약 몇몇 작업이 메모리로 옮겨올 준비가 되었고, 그들 전부를 메모리에 보관할 만한 공간이 불충분하다면, 시스템은 그들 중 몇 개를 선택해야 한다.
        - 이러한 결정을 하는 것이 [작업 스케줄링 ] 이다. (5장 참고)

    <br>

    - 병행적으로 실행되는 다수의 작업은 '프로세스 스케줄링', 디스크 저장장치, 그리고 메모리 관리를 포함하여 운영체제 모든 단계에서 상호간에 영향을 미치는 능력이 제한될 필요가 있다. (이는 책 전반에 걸쳐 논의한다)

    <br>

    - 시분할 시스템에서 운영체제는 적잘한 응답 시간을 보장하기 위해 작업들을 **주 메모리에서 디스크로 적절하게 스왑인(swap-in) 또는 스왑아웃(swap-out)** 시킨다.
        - 이 목적을 달성할 수 있는 더 일반적인 방법은 **[ 가상 메모리(virtual memory) ]를 사용**하는 것인데, 이는 **일부만이 메모리에 있는 작업의 실행을 허용하는 기법**이다(9장 참고)
        - 이 기법의 주요 이점은 **프로그램이 물리 메모리의 크기보다 더 커도 된다는 것**
        - 가상 메모리는 주 메모리를 크고 균등한 저장장치의 배열로 추상화하여 사용자에게 보이는 논리 메모리를 물리 메모리로부터 분리시킨다.
        - 이러한 기법은 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해준다.

    <br>

    - 시분할 시스템은 반드시 **파일 시스템**도 제공해야 한다. (10장과 11장)
        - 파일 시스템은 다수의 디스크 상에 존재하므로, 디스크 관리 기법이 반드시 제공되어야 한다(12장)
        - 또한 시분할 시스템은 부적당한 사용으로부터 자원을 보호하기 위한 기법을 제공해야 한다(14장)
        - 작업이 질서정연하게 실행되기 위해서 시스템은 반드시 **작업 동기화와 통신 기법**을 제공해야 하며(6장), 
        - 작업이 서로를 영원히 기다리는 '교착상태(deadlock)'에 빠지지 않도록 해야 한다(7장)


<br>
<br>
<br>

## 1.5. 운영체제 동작(Operating System Operations)

- 앞에서 언급한 것처럼 현대의 운영체제는 인터럽트 구동식(interrupt driven)이다.
    - 즉, 운영체제는 무엇인가 일어나기(사건)를 기다리며 조용히 있다.

- **사건**은 거의 항상 **인터럽트나 트랩을 발생시켜 신호**를 보낸다.
    - **트랩(또는 예외)은 오류(예 : 0으로 나누기 또는 유효하지 않은 메모리 접근)** 혹은 사용자 프로그램의 운영체제 서비스 실행 요청에 의해 유발되는 **소프트웨어에 의해 생성된 인터럽트**이다.

- 운영체제의 인터럽트 구동식 특성은 시스템의 일반적 구조를 정의한다.
    - 각 타입의 인터럽트에 대해 어떠한 행동을 취해야 할지는 운영체제 내의 서로 다른 코드 세그먼트가 결정한다.
    - 하나의 인터럽트를 처리하기 위해 하나의 인터럽트 서비스 루틴이 제공된다.

- 운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에 사용자 프로그램의 오류가 현재 실행 중인 프로그램에만 문제를 일으키도록 보장해야 한다.
    - 공유 때문에 한 프로그램의 버그로 인하여 많은 프로그램들이 악영향을 받을 수 있다.
    - 예를 들어, 하나의 프로세스가 무한 루프에 빠진다면 다른 프로세스의 정상적인 동작을 방해할 수 있다.
    - 다중 프로그래밍 환경에서는 하나의 잘못된 프로그램이 다른 프로그램 코드나 데이터 또는 운영체제 자체를 변경할 수도 있다.

<br>
<br>

### 1.5.1. 이중 동작 모드(Dual-Mode Operation)

- 운영체제의 적절한 동작을 보장하기 위해 **운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다.**

<BR>

- 많은 운영체제가 선택하는 접근 방법은 **여러 실행 모드를 구분할 수 있도록 지원하는 하드웨어를 이용**하는 것이다.
    - 적어도 두 개의 독립된 동작 모드, 즉 '**사용자 모드'와 '커널 모드(슈퍼바이저 모드, 시스템 모드, 혹은 특권 모드(privileged mode))를 필요**로 한다.
    - 모드 비트(mode bit)라고 하는 하나의 비트가 **현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가**되었다. 이 비트는 **커널 모드(0) 또는 사용자 모드(1)를** 나타낸다.

- 모드 비트의 사용으로, 우리는 운영체제를 위하여 실행하는 작업과 사용자를 위해 실행하는 작업을 구분할 수 있다.
    - 컴퓨터 시스템이 사용자 응용을 위해 실행될 때 시스템은 사용자 모드에 있게 된다.
    - 그러나 사용자 응용이 운영체제로부터 서비스를 요청하면(시스템 호출을 통함) 이 요청을 실행하기 위해서는 사용자 모드에서 커널 모드로 전환해야 한다.

    - 시스템 부트 시 하드웨어는 커널 모드에서 시작된다.
        - 이어 운영체제가 적재되고, 사용자 모드에서 사용자 프로세스가 시작된다.
        - 트랩, 인터럽트가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다. (즉, 모드 비트를 0으로 변경)
        - 그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다.
    - 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드(모드 비트를 1로 설정)로 전환한다.

- 이처럼 동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호하는 방법을 우리에게 제공한다.

![image](https://user-images.githubusercontent.com/101503543/215243251-242fba46-e987-49a7-a961-361d035ee24e.png)



- 악 영향을 끼칠 수 있는 일부 명령을 특권 명령(privileged instruction)으로 지정함으로써 이러한 보호를 달성한다.
    - 하드웨어는 특권 명령이 커널 모드에서만 실행되도록 허용하고, 사용자 모드에서 특권 명령을 시도하면 하드웨어는 이를 불법적인 명령으로 간주해 운영체제로 트랩을 건다.
    - 커널 모드로 전환하는 명령어가 특권 명령의 한 예이다.
    - 또 다른 예는 '입출력 제어, 타이머 관리, 인터럽트 관리'를 위한 명령어 등이 있다.

- 컴퓨터 시스템의 명령 실행 주기
    - 초기 제어는 운영체제에게 있다. 여기서 명령어가 커널 모드에서 실행된다.
    - 제어가 사용자 응용으로 넘어가면 모드가 사용자 모드로 지정된다.
    - 결국 제어는 인터럽트, 트랩 또는 시스템 호출을 통하여 운영체제로 다시 넘어 오게 된다.

- 시스템 호출은 운영체제에 의해 실행될 동작을 사용자 프로세스가 요청할 수 있게 한다.
    - 시스템 호출은 컴퓨터 시스템의 처리기가 지원하는 기능에 따라 다양한 방법으로 호출되는데, 일반적으로 **인터럽트 벡터의 특정 위치로 트랩을 거는 형태**를 취한다.

- 시스템 호출이 실행될 때, 시스템 호출은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다.
    - 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다.(시스템 호출 서비스 루틴은 운영체제의 일부이다.)
    - 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 호출이 발생했는지를 결정한다.
    - 이때 전달된 인자가 사용자 프로그램이 요청하는 서비스 타입을 표시한다.  
    요청이 필요로 하는 추가의 정보는 **레지스터, 스택 또는 메모리를 통하여(이때는 메모리 위치에 대한 포인터가 레지스터에 전달된다) 전달될 수 있다.** 
    - 커널은 인자가 정확하고 합법적인지를 검증하고 요청을 실행한 후 제어를 시스템 호출 다음 명령으로 복귀시킨다.

<br>

- 하드웨어 보호 기능이 제공되면 **하드웨어는 모드 규칙을 위반하는 오류를 탐지**한다.
    - 이러한 오류는 **일반적으로 운영체제가 처리**한다.
    - 사용자 프로그래미 불법적인 명령을 실행하려 하거나, 사용자 주소 공간이 아닌 메모리에 접근을 시도하는 등과 같은 오류가 발생하면, **하드웨어는 운영체제로 트랩을 발생**시킨다.
    - 트랩은 인터럽트처럼 인터럽트 벡터를 통해 **제어를 운영체제에게 넘긴다**.
    - 프로그램 오류가 발생할 때마다 운영체제는 비정상적으로 프로그램을 종료시킨다.  
    이는 사용자가 요청한 비정상적인 종료와 동일한 코드에 의해 처리된다. 적절한 오류 메시지가 주어지고, 프로그램의 메모리가 덤프된다.
    - **메모리 덤프**는 사용자나 프로그래머가 이를 조사하고, 프로그램을 수정하여 다시 실행시킬 수 있도록 통상 파일에 기록된다.


<br>
<br>

### 1.5.2. 타이머

- 우리는 **운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장**해야 한다.
    - 사용자 프로그램이 무한 루프(infinite loop)에 빠지거나, 시스템 서비스를 호출하지 않아서 **제어가 운영체제로 복귀하지 않는 경우를 허용할 수 없다.** 
    - 이러한 목적을 달성하기 위해 '타이머(timer)를 사용할 수 있다.
    - 타이머는 지정된 시간 후 컴퓨터를 인터럽트하도록 설정할 수 있다.

- 사용자에게 제어를 양도하기 전에 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지 확인한다. 
    - 타이머가 인터럽트를 발생시키면 제어는 자동적으로 운영체제로 넘어가며, 운영체제는 인터럽트를 치명적인 오류로 취급하거나 또는 프로그램에게 더 많은 시간을 줄 수 있다. 
    - 타이머의 동작을 변경하는 명령은 분명한 특권 명령이다.
    - 따라서 사용자 프로그램이 너무 오래 실행되는 것을 방지하기 위해 타이머를 사용할 수 있다.

<br>
<br>
<br>

## 1.6. 프로세스 관리
