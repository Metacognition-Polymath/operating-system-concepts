
# 19장. 네트워크 및 분산 시스템

# 분산 시스템이란?

### 1.

> - **분산 시스템
:** 통신 네트워크에 의해 상호 연결된 느슨하게 결합된 노드들의 집합

- **분산 시스템의 노드는 크기와 기능이 다양할 수 있다.**
( 소형 마이크로 프로세서 ~ 개인형 컴퓨터 ~ 대규모 컴퓨터 시스템 등
같은 맥락으로 **프로세서, 사이트, 시스템 및 호스트**와 같은 이름으로 언급될 수 있다)

**- 분산 시스템의 기능?**
독립적인 시스템에서 가능하던 기능을 분산 시스템에서도 동일하게 사용 가능
(파일 저장, 응용 프로그램 실행 및 원격 프로시저 호출(RPC) 등)

**- 노드 간의 구성** 
1. 클라이언트 - 서버 구성 → **그림 19.1**
2. 피어 간 구성
등등..
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9697f51d-11e2-4a4b-9190-504872f6fba0/Untitled.png)

---

### 2.

> **[분산 시스템의 필요성 - 3가지]

1. 자원 공유** 
  - (예) 사이트 A의 사용자 → 사이트 B에 위치한 데이터베이스에 질의
         사이트 B의 사용자 → 사이트 A의 파일에 접근
  - ‘경제적, 효율적’
  
**2. 계산 속도 향상**
  - 분산 시스템을 통해 하위 계산을 여러 사이트에 분산할 수 있다. → 계산 속도 향상
  - 빅데이터 집합의 대규모 처리 (예 : 경향 파악을 위한 대량 고객 데이터 분석)
  - 또는 특정 사이트에 요청이 과부화된 경우, 작업 이동 및 재배치(Load balancing)를 통해
     부하를 해소 

**3. 신뢰성**
  - 분산 시스템은 하나의 사이트에 장애가 발생해도 나머지 사이트가 계속 작동
     → 일반적으로 충분한 **중복성**을 사용하므로, 일부 노드가 고장나도 시스템이 계속 작동 가능
  - ‘장애 감지’ 그리고 수리할 때 원활하게 통합하는 기법
> 

---

# 네트워크

### 3.

> **- 네트워크**
: 컴퓨터나 기타 기기들이 리소스를 공유하거나 데이터를 주고 받기 위해 유선 혹은 무선으로 연결되는 **통신체계**

**- 네트워크 프로토콜** 
: 네트워크 통신을 하기 위해서 통신에 참여하는 주체들이 따라야 하는 형식, 절차, 규약

- 네트워크가 가지고 있는 모든 기능을 하나의 프로토콜로 구현할 수 있을까? → XXX
  그래서 **네트워크의 기능별로 분리해서 여러 프로토콜을 구현**

- 그렇다면 네트워크 기능은 무엇이 있는가?
   **네트워크 기능을 계층 구조로 모델링한 것이 ‘OSI 7계층 모델’**
> 

---

### 4.

> **OSI 네트워크 모델 ( 7 layer )**
- 범용적인 네트워크 구조
- 네트워크 프로토콜에서 행해진 초기 작업 중 일부를 공식화하지만 1970년대 후반에 개발되어 현재 널리 사용되지는 않는다.

**TCP / IP stack ( 4 layer )** 
- 인터넷에 특화된 네트워크 구조
- 거의 모든 인터넷 사이트에 의해 채택되어 (아마도 가장 널리 채택되었을) 모델
   (인터넷 모델이라고도 함)
> 

---

### 5.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ec0f18e-441f-46ca-99b2-13760a5b0c0d/Untitled.png)

> 각 레이어에 맞게 프로토콜이 세분화돼서 구현
**각 레이어의 프로토콜은 하위 레이어의 프로토콜이 제공하는 기능을 사용하여 동작**

그리고 한 시스템의 각 층은 다른 시스템의 해당 층과 통신한다.
일반적으로 각 층에는 고유의 프로토콜을 가지고 있으며 특정 프로토콜을 사용하여 동위 층 간에 통신이 이루어진다.
> 

---

### 6.

- **층 7 : 응용 프로그램 층**
    - 사용자와 직접 상호 작용.
    - 파일 전송, 원격 로그인 프로토콜 및 이메일, 분산 데이터베이스의 스키마를 처리
    - 대표적인 프로토콜은 **HTTP, DNS, SMTP, FTP**가 있다.

- **층 6 : 프레젠테이션 층**
    - 애플리케이션 간의 통신에서 **메시지 포맷 관리하는 레이어**
    - 문자 변환 및 반이중 - 전이중 모드(문자 에코)를 포함하여 **네트워크의 여러 사이트 간의 형식 차이를 해결한다.**
    - 즉, **어떤 메시지 포맷으로 데이터가 오고 가게 만들 것인가** 에 대한 기능을 구현하는 레이어
    - 인코딩 ↔ 디코딩
    - 암호화 ↔ 복호화
    - 압축 ↔ 압축 풀기

 

- **층 5 : 세션 층**
    - 애플리케이션과의 통신에서 세션을 관리하는 레이어
    - 세션 또는 프로세스 간 통신 프로토콜을 구현한다.
    - **RPC**가 해당 레이어에서 동작

**⇒ 층 7, 6 ,5는 어플리케이션과 관련된 기능을 담당한다**
     TCP / IP 모델에서 이 3 계층을 묶어서 어플리케이션층으로 본다.

---

### 7.

- **층 4 : 전송 층**
    - 애플리케이션 간의 통신 담당 = 목적지 애플리케이션으로 데이터 전송
    - 노드 간 메시지 전송, 패킷 순서 유지 및 혼잡을 피하기 위해 흐름 제어 등을 담당
    - 목적지 애플리케이션으로 **어떤 식의 통신으로** 데이터를 전송할 것인가?
        - **TCP** - 안정적이고 신뢰할 수 있는 데이터 전송 보장
        - **UDP** - 필수 기능만 제공 / 데이터가 중간에 유실될 수 있고 데이터를 보내는 순서대로 받지 못할 수도 있음

- **층 3 : 네트워크 층**
    - 메시지를 패킷으로 나누고, 논리 주소 사이의 연결을 제공하고, 통신 네트워크에서의 패킷 라우팅을 담당.  (라우터는 이 층에서 작동)
    - 즉, 쉽게 말하면 **목적지 호스트로 데이터 전송하는 역할을 담당하는 레이어**
    - 호스트 간의 통신 담당**(IP)**
    - 또한 네트워크 간의 최적의 경로 결정하는 역할도 수행
    
      ⇒ 즉, 전체적인 경로를 담당
          각각 노드 사이의 데이터를 어떻게 전송할 것인가는 **데이터 링크 레이어**가 수행.
    
- **층 2 : 데이터 링크 층**
    - 직접 연결된 노드 간의 통신을 담당한다.
    - 물리 층에서 발생하는 오류 감지 및 복구를 포함하여 프레임 또는 고정 길이의 패킷 처리를 담당한다.
    - 네트워크 층의 경우 아이피 주소로 동작하지만, 데이터 링크에선 아이피 주소가 아닌 **MAC 주소 기반으로 통신** 
    **(물리 주소 = OS에 따라 물리 주소, Wi-Fi 주소라고 불림)**
    - **ARP** 프로토콜을 사용하여 IP 주소를 MAC 주소로 변환한다.
    - MAC 주소를 바탕으로 하나의 노드에서 다음 노드로 데이터를 보낼 수 있다.

- **층 1 : 물리층**
    - 물리 층은 비트 스트림의 물리 전송에 대한 기계적 및 전기적 세부 사항의 처리를 담당한다.
    - 물리 층에서, 데이터가 전기적 신호의 스트림으로 전송될 때 수신자가 데이터를 이진 데이터로 올바르게 해석할 수 있도록 통신 시스템은 **이진 0과 1의 전기적 표현**으로 이루어져야 함.
    - 이 층은 네트워킹 장치의 하드웨어에서 구현된다.
    - **물리적 매개체**를 통해(예 : 케이블 또는 무선의 신호) 데이터를 비트 단위로 전송하는 역할을 수행한다.
    

---

### 8.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5655452-7356-474a-b475-8f04563d7f09/Untitled.png)

---

### 9.

> *“언급한 바와 같이, 프로토콜 스택의 각 층은 다른 시스템의 동등한 층과 통신한다. **그러나 물리적으로 메시지는 응용 프로그램 층 또는 그 이상에서 시작하여 각 하위층을 차례로 통과한다.**”*
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c6a806a6-dd08-4d9c-a37a-d26fc11d0673/Untitled.png)

---

### 10.

> ***“이 때 각 층에서는 메시지를 수정할 수 있고, 수신 측의 동위 층에 대한 메시지 헤더 데이터를 포함할 수 있다. (… 중략 … ) 진행함에 따라 헤더를 분석, 수정 및 제거한다.”***
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/226c8c4b-672c-4c74-9f62-f62b5974fdf5/Untitled.png)

**⇒ 유념할 점**
    이 모든 과정은 **각각의 레이어마다 동작하는 프로토콜이 각자의 기능을 수행하며 이루어진다.**

---

### 11.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a955d775-065f-4bfe-b3a6-e62cbba663bc/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e13815f-448a-4cde-a880-48f4b796e707/Untitled.png)

- **OSI 모델과 TCP/IP 모델의 관계**

> - TCP / IP 프로토콜 스택은 OSI 모델보다 더 적은 수의 층을 가진다.
이론적으로는 각 OSI 계층의 여러 층의 기능을 결합하기 때문에 OSI 네트워킹보다 구현하기가 더 어렵지만 더 효율적이다.
> 

---

### 12.

> **Transport Layer**
End Point 간 신뢰성있는 데이터 전송을 담당하는 계층

- 신뢰성 : 데이터를 순차적, 안정적으로 전달
- 전송 : 포트 번호에 해당하는 프로세스에 데이터를 전달

예) 웹 브라우저를 통해 http 웹 사이트에 연결하려는 경우 브라우저는 TCP 전송 헤더에 포트 번호로 80을 사용하여 서버의 포트 80에 자동으로 연결을 시도한다.
> 

---

### 13.

> **만약 트랜스포트 계층이 없다면? (전송 계층의 중요성)**

- 데이터의 **순차 전송**이 원할하지 않음 (예 : 1 2 3  →  2 3 1 )
- **Flow(흐름 문제)** 
   원인 : 송수신자 간의 데이터 처리 속도 차이
- **Congestion (혼잡 문제)**
   원인 : 네트워크 데이터 처리 속도 (예 : 라우터가 패킷을 생략)
> 

---

### 14.

> **TCP (Transmission Control Protocol)**
- 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜
- 특징 : Connection 연결 (3 way-handshake) - 양방향 통신
- 데이터의 순차 전송을 보장
- **Flow Control (흐름 제어)**
  : ‘흐름 제어 상태’를 수신자의 **ACK 패킷으로 반환** → 발신자에게 속도 저하 or 속도 증가 경고
- **Congestion Control (혼잡 제어)
  :** 송신자와 수신자 사이의 네트워크(및 일반적으로 라우터)의 상태를 어림 계산하려고 시도.
    ACK를 받지 않은 패킷 수를 확인하여 연결에서 생략된 패킷을 모니터링하고 생략된 패킷이 너무 많으면 송신자는 패킷을 보내는 속도를 늦춘다.
- Error Detection (오류 감지)
> 

---

### 15.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a762c188-cf1a-4f9b-b78b-80924a9a674b/Untitled.png)

---

### 16.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/648c75a5-901d-4216-a5b8-833d72e3a141/Untitled.png)

> - 시퀀스 넘버
: 다른 호스트로 전달되는 세그먼트는 여러 개의 서로 다른 경로를 거치며 세그먼트의 순서가 뒤바뀔 수 있습니다. 이를 **수신 측에서 재조립하기 위해 사용되는 Numbe**r입니다.

- ACK
: 수신자의 입장에서 송신자로부터 앞으로 받아야 할 다음 데이터의 Sequence Number입니다. 이는 모든 선행하는 바이트들(존재할 경우)에 대한 **수신에 대한 확인응답이 됩니다**
> 

---

### 17.

- **19.3.4.2 - TCP (Transmission Control Protocol)**

> *“TCP는 신뢰할 수 있고 연결 지향적인 전송 프로토콜이다.”*
> 

- **TCP 데이터 전송 방식**

> 1. Client가 패킷 송신
2. Server에서 ACK 송신
3. ACK를 수신하지 못하면 재전송
> 

---

### 18.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/196864bb-aa85-4c57-a5f8-880daec32c6a/Untitled.png)

---

### 19.

- TCP의 문제점

> - 전송의 신뢰성은 보장하지만…
- 매번 Connection을 연결해서 시간 손실 발생 (3 way handshake)
- 패킷을 조금만 손실해도 재전송해야 함
> 

- UDP (User Datagram Protocol)

> - TCP보다 신뢰성이 떨어지면 전송 속도가 일반적으로 빠른 프로토콜
- Connectionless (3 way - handshake X)
- Error Detection
- 비교적 데이터의 신뢰성이 중요하지 않을 떄 사용 (예 : 영상 스트리밍)
> 

---

### 20.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/faaa03b7-0de7-4d57-8cf7-1800feee9917/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2554b9af-5c8c-44bc-95e0-174837c6783b/Untitled.png)

> 소스 포트 번호, 목적지 포트 번호, 길이 및 체크섬의 네 가지 필드만 포함
> 

---

### 21.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1b60fd2-0992-48e8-a2a0-5a37964cb845/Untitled.png)

⇒ **네트워크에 의해 처리되는 신뢰성 보장**을 원한다면 **TCP와 같은 다른 전송 프로토콜을 사용해야**만 한다.

---

## 분산 시스템의 설계 문제

### 22.

### 견고성

> 1. 장애 감지  - 심장박동(heartbeat) 절차
2. 재구성 - 정상 모드를 계속할 수 있도록 재구성
3. 장애 복구 - 단계적, 부드럽게 통합

**+ 결함 허용성 
:** 통신 장애, 특정 기기 고장, 등 어느 정도 허용이 되어야 한다는 뜻
  → 중복성 but 현실적으로 비용 큼
> 

---

### 23.

### 투명성

> “*분산 시스템의 여러 프로세서와 저장장치를 사용자에게 투명하게 만드는 것은 많은 설계자에게 주요 과제였다. 이상적으로 분산 시스템은 사용자에게 기존의 중앙 집중형 시스템처럼 보여야 한다. ”*
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e5f0fec-02e1-4383-aea3-44f3c0f48bcd/Untitled.png)

---

### 24.

### 확장성

> **: 증가하는 서비스 부하에 적응할 수 있는 시스템의 능력**

“**확장 가능한 시스템은 이러한 문제 없이 성장할 수 있는 잠재력을 가져야 한다.”**
예) 신도시의 4차선 도로 → 단지가 100개 이상으로 늘어난다면?

**단계적**으로 확장할 수 있는 능력이 특히 중요.

⇒ 확장 가능한 설계는 높은 서비스 부하를 견뎌야 하며, 사용자 수의 성장을 수용해야 하고, 추가된 자원을 간단하게 통합할 수 있어야 한다.
> 

---

## 분산 시스템 예시 - 캐시와 일관성 문제

### 25.

- **AWS S3 / AWS CloudFront**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4cd935fa-caa6-48ae-ba56-8ca6c5d76bac/Untitled.png)

> 클라이언트 시스템은 로컬로 캐시된 데이터 사본이 마스터 사본과 일치하는지(따라서 사용할 수 있는지) 결정하는 문제에 직면한다.

클라이언트 시스템이 캐시된 데이터가 최신 버전이 아니라고 판단하면 추가 액세스를 허용하기 전에 최신 데이터 사본을 캐시해야 한다.
> 

---

### 26

- **Write-through policy**
    - 가장 간단한 정책으로, 데이터를 변경할 때 캐시와 백엔드 저장소를 동시에 쓰는 방식을 의미한다.
    - 장점 - 데이터의 일관성과 신뢰성 보장
    - 단점 - 데이터를 쓰는 작업이 두 번 발생하므로 작업 속도가 느려진다. 
    또한 정보가 서버로 전송될 때까지 모든 쓰기 액세스가 기다려야 하므로 쓰기 성능 저하를 기다린다.

- **delayed-write policy**
    - 지연-쓰기 정책 - 데이터를 먼저 캐시에 쓰고 나중에 백엔드 저장소로 전달하는 방식을 의미
    - 즉, write-back 캐싱으로, 마스터 복사본에 대한 업데이트를 지연시킴
    - 수정 사항은 캐시에 기록된 다음 나중에 일정 시간 이후 또는 특정 이벤트 때에 서버에 기록된다.
    - 이를 통해 쓰기 작업의 지연 시간을 줄일 수 있다.
    - 그러나 데이터가 캐시에만 저장되기 때문에 만약 사용자 시스템이 크래시되면 기록되지 않은 데이터가 있을 경우 데이터가 손실될 수 있다.
