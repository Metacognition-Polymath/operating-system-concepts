# 19. 네트워크 및 분산 시스템

- 분산 시스템 : 메모리나 시계를 공유하지 않는 프로세서 모음
  - 각 노드에는 자체 로컬 메모리가 있다
  - 노드는 고속버스와 같은 다양한 네트워크를 통해 서로 통신한다
  - 분산 시스템은 분산 서비스를 사용해왔다
  - 분산 시스템의 응용 프로그램들
    - 대규모 클라우드 파일 및 사진 저장 서비스
    - 대규모 데이터 집합의 경향에 대한 비즈니스 동향 분석
    - 과학 데이터의 병렬 처리 등
    - 인터넷
- 이 장에서는 분산 시스템의 일반적인 구조와 이들을 상호 연결하는 네트워크에 대해 설명한다
- 또한 현재 분산 시스템 설계의 `유형`과 `역할`의 주요 차이점을 대조한다
- 마지막으로 분산 파일 시스템의 일부 기본 설계 및 설계 당면과제를 조사한다

#### 이 장의 목표

- 네트워크 및 `분산 시스템의 장점`을 설명한다
- 분산 시스템을 상호 연결하는 `네트워크`에 대한 고수준의 `개요`를 제공한다
- 현재 사용 중인 `분산 시스템`의 `역할`과 `유형`을 정의한다
- `분산 파일 시스템` 설계와 관련된 문제를 논의한다

## 19.1 분산 시스템의 장점(Advantages of Distributed Systems)

- `분산 시스템`은 통신 `네트워크에 의해 상호 연결된` 느슨하게 결합한 `노드들의 집합`이다
- 특정 노드 관점에서 나머지 노드와 각 노드의 자원은 원격이지만 자체 자원은 로컬이다
- 노드는 크기와 기능이 다를 수 있다
  - 소형 마이크로 프로세서
  - 개인용 컴퓨터 및 대규모 범용 시스템
- 이러한 `맥락에 따라` 프로세서, 사이트, 시스템 및 호스트와 같은 `여러 이름으로 언급`된다
- 노드는 여러 유형으로 존재할 수 있다
  - 클라이언트 - 서버 구성
    - 클라이언트(노드) - 서버(노드) - 자원(노드)
  - 피어간 구성
    - 각 노드는 동등한 책임을 공유하며 클라이언트와 서버의 역할을 모두 수행할 수 있다
- 메시지

  - 낮은 수준에서 프로세스간 전달
  - 분산 시스템을 포함하여 확장
    - 파일 저장
    - 응용 프로그램 실행
    - 원격 프로시저 호출(RPC)

- 분산 시스템을 구축해야 하는 이유 3가지
  - 자원 공유
  - 계산 속도 향상
  - 신뢰성

### 19.1.1 자원 공유(Resource Sharing)

- 분산 시스템의 자원 공유
  - 원격 파일 공유
  - 분산 데이터 베이스에서 정보 처리
  - 원격 사이트에서 파일 인쇄
  - 슈퍼컴퓨터 또는 GPU(graphics processing unit)와 같은 원격 특수 하드웨어 장치 사용
  - 다른 작업을 할 수 있는 기법을 제공한다

### 19.1.2 계산 속도 향상(Computation Speedup)

- 특정 계산을 (동시에 실행할 수 있는) 하위 계산으로 분할할 수 있는 경우 분산 시스템을 통해 `하위 계산을 여러 사이트에 분산`시킬 수 있다
- 하위 계산을 동시에 실행할 수 있으므로 계산 속도가 향상된다
- 예시
  - 빅데이터 집합의 대규모 처리
  - 특정 사이트에 현재 요청이 과부하되어 있는 경우, 그중 일부는 부하가 적은 다른 사이트로 이동하거나 재배치할 수 있다
    - 부하 균등화(load balancing)
    - 분산 시스템 노드와 인터넷에서 제공되는 기타 서비스에서 흔히 볼 수 있다

### 19.1.3 신뢰성(Reliability)

- 분산 시스템에선 하나의 사이트가 장애가 발생해도 나머지 사이트는 정상 작동하여 시스템의 신뢰성이 향상된다
- 시스템이 여러 대의 독립 시스템으로 구성된 경우 하나의 장애가 나머지 부분에 영향을 미치지 않아야 한다
- 웹 서버 또는 파일 시스템 같은 중요한 시스템의 경우, 하나의 시스템 장애로 전체 시스템의 작동이 중단될 수 있다

  - 일반적으로 (하드웨어 및 데이터 모두에서) 충분한 중복성을 사용하면 일부 노드가 고장 나더라도 시스템이 계속 작동할 수 있다

- 한 사이트의 장애 -> 다른 시스템에서 감지
  - 시스템은 더 이상 해당 사이트의 서비스를 사용해서는 안된다
  - 고장 난 사이트의 기능을 다른 사이트가 인계할 수 있는 경우, 시스템은 기능의 전송이 올바르게 수행되는지 확인해야 한다
  - 고장난 사이트가 복구되거나 수리되었을 때 -> 사이트를 원할하게 시스템에 다시 통합할 수 있는 기법이 있어야 한다

## 19.2 네트워크 구조(Network Structure)

- 분산 시스템의 역할과 유형을 완전히 이해하려면 그것들을 상호 연결하는 네트워크를 이해할 필요가 있다
- 이 절은 분산 시스템과 관련된 네트워킹 개념과 과제를 소개하는 네트워크 입문서이다
- 이 장의 나머지 부분에서는 분산 시스템에 대해 구체적으로 설명한다

- 근거리 통신망(LAN, 로컬 영역 네트워크, Local Area Network)과 광역 통신망(WAN, Wide Area Network)의 두 가지 유형의 네트워크가 있다
  - 차이점 : 지리적 분포 방식
  - LAN은 소뮤모 건물(단일 건물 또는 인접한 여러 건물 등)에 분산된 호스트로 구성
  - WAN은 넓은 지역(미국 등)에 분산된 시스템으로 구성
  - 통신 네트워크의 속도와 신뢰성이 매우 다양하다는 것을 의미하며 분산 시스템 설계에 반영된다

### 19.2.1 LAN(Local Area Network, 로컬 영역 네트워크)

![19-2](./images/19-2.png)

- 그림 19.2 로컬 영역 네트워크

- 로컬 영역 네트워크는 대형 메인 프레임 컴퓨터 시스템을 대체하기 위해 등장했다
- 하나의 큰 시스템을 사용하는 것 보다 각각 자체 응용 프로그램을 갖춘 여러 개의 소형 컴퓨터를 사용하는 것이 더 경제적이다
  - 소형 컴퓨터는 주변 장치(디스크, 프린터 등)로 보완되어야 할 가능성이 높고
  - 데이터 공유 발생 가능성이 높기 때문에 이러한 소형 시스템을 네트워크에 연결하는 것은 당연한 조치였다
- 작은 지리적 지역을 포괄하도록 설계
  - 사무실, 가정환경
- 가깝기 때문에 통신 링크는 광역 네트워크의 링크보다 속도가 빠르고 오류율이 낮은 경향이 있다
- 일반적인 LAN은 여러 다른 컴퓨터, 다양한 공유 주변 장치 및 다른 네트워크에 대한 `접근을 제공하는 하나 이상의 라우터(특수 네트워크 통신 프로세서)`로 구성될 수 있다
  - 다른 컴퓨터 :워크스테이션, 서버, 랩톱, 태블릿, 스마트폰
    - [워크스테이션](https://ko.wikipedia.org/wiki/%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%85%98) : 전문분야 작업을 염두에 둔 고성능 개인용 컴퓨터
  - 다양한 공유 주변 장치 : 프린터, 저장장치 배열
- 이더넷(Ethernet)과 WiFi는 일반적으로 LAN을 구성하는 데 사용된다
- 무선 액세스 포인트(wireless access point)는 장치를 LAN에 무선으로 연결하며 자체가 라우터일 수도 아닐 수도 있다

#### 이더넷(Ethernet)

- 이더넷 네트워크는 다중 액세스 버스이기 때문에 중앙 컨트롤러가 없으므로 새 호스트를 네트워크에 쉽게 추가할 수 있다
- 이더넷 프로토콜은 IEEE 802.3 표준에 따라 정의되어 있다
- 트위스트 케이블 연결을 사용하는 일반적인 이더넷 속도는 10Mbps ~ 10Gbps 이상까지 다양할 수 있으며 다른 유형의 케이블은 100Gbps 속도에 이를 수 있다

#### WiFi

- WiFi는 현재 어디에나 있으며, 기존의 이더넷 네트워크를 보완하거나 자체적으로 존재한다
- 특히 WiFi를 사용하면 물리적 케이블을 사용하지 않고도 네트워크를 구축할 수 있다
- 각 호스트(랩톱, 스마트폰 등)는 네트워크에 참여하는 데 사용하는 무선 송신기 및 수신기를 가지고 있다
- WiFi는 IEEE 802.11 표준에 따라 정의되어 있다
- 무선 네트워크는 가정, 기업뿐만 아니라 도서관, 카페, 버스 등 공공 장소에서도 사용된다
- WiFi 속도는 11Mbps ~ 400Mbps 이상까지 다양하다

### 19.2.2 WAN(Wide Area Network, 광역 네트워크)

- 역사
  - 1960년대 사이트 간 효율적 통신을 제공하여 광범위한 사용자가 편리하고 경제적으로 하드웨어와 소프트웨어를 공유할 수 있게 하기 위한 학문적 연구 프로젝트로 등장하였다
  - 최초의 WAN은 APRANET -> 4개의 사이트 실험 네트워크
  - 현재 전 세계적인 네트워크인 인터넷(World Wide Web)으로 성장했다
- 내 생각
  - 인터넷은 WAN의 한 종류라고 생각한다
  - WAN은 인터넷을 포함하는 개념이라고 생각한다
- WAN은 넓은 지리적 지역에 물리적으로 분포되어있다
- 대표적인 링크
  - 전화선, 임대(전용 데이터) 회선, 광케이블, 마이크로파 링크, 전파 및 위성 채널
- 이 통신 링크는 트래픽을 다른 라우터 및 네트워크로 보내고 다양한 사이트 간에 정보를 전송하는 라우터에 의해 제어된다

![19-3](./images/19-3.png)

- 그림 19.3 광역 네트워크
- 인터넷 WAN을 사용하면 지리적으로 분리된 사이트의 호스트가 서로 통신할 수 있다
- `호스트`는 일반적으로 LAN에 연결되어 있으며, `지역 네트워크`를 통해 인터넷에 연결된다
- `지역 네트워크`는 `라우터`와 상호 연결되어 `전 세계 네트워크를 형성`한다
- 전문 인터넷 서비스 공급업체를 통해 인터넷에 연결
  - 전문 인터넷 서비스 공급업체 : 전화, 케이블 또는 라우터를 설치하여 인터넷에 연결하는 회사
  - 일반 가정에서 주로 사용
- 자체 사설 WAN

  - 인터넷 외 다른 WAN도 있다
  - 예를 들어 기업은 보안, 성능 또는 신뢰성 향상을 위해 자체 사설 WAN을 만들 수 있다
  - 내 생각 : 국방부 인트라넷

- 주요 도시를 연결하는 백본 WAN 연결은 광섬유 케이블을 통해 전송 속도가 매우 빠를 수 있지만 WAN은 일반적으로 LAN보다 느리다
- 실제로 많은 백본 제공 업체는 40Gbps 또는 100Gbps의 속도로 WAN을 제공한다

- 종종 WAN과 LAN은 서로 상호 연결되며, 둘 사이의 경계를 구분하는 것은 어렵다
  - 휴대 전화 데이터 네트워크를 고려해보자
    - 휴대전화는 음성 및 데이터 통신에 모두 사용된다
    - 특정 지역의 휴대전화는 송신기와 수신기가 포함된 셀타워에 연결된다
    - 네트워크의 이 부분은 휴대전화가 서로 통신하지 않는다는 점을 제외하고 LAN과 유사하다
    - 타워는 다른 타워 및 허브에 연결
      - 허브는 타워 통신을 지상선 또는 다른 통신 매체에 연결하고 패킷을 목적지로 라우팅한다
    - 네트워크의 이 부분은 WAN과 유사하다
    - 일단 적절한 타워가 패킷을 수신하면 송신기를 사용하여 올바른 수신자에게 보낸다

## 19.3 통신 구조(Communication Structure)

- 19.2에서 네트워크의 물리적 측면에 대해 살펴봤으므로 내부 작업으로 눈을 돌린다

### 19.3.1 이름 지정 및 이름 찾기(Naming and Name Resolution)

- 네트워크 통신의 첫 번째 문제는 네트워크상의 시스템 이름 지정과 관련이 있다
- 사이트 A의 프로세스가 사이트 B의 프로세스와 정보를 교환하려면 각각 서로를 지정할 수 있어야 한다
- 같은 PC 내에선 프로세스를 구분할 때 pid를 갖고 메모리를 공유하지만
  - 네트워크로 연결된 시스템은 메모리를 공유하지 않기 때문에 시스템 내의 호스트는 다른 호스트의 프로세스에 대해 알지 못한다
- 이 문제를 해결하기 위해 원격 시스템의 프로세스는 일반적으로 `<호스트 이름, 식별자>` 쌍으로 식별된다
  - 호스트 이름은 네트워크 내에서 고유한 이름이고,
  - 식별자는 해당 호스트 내에서 프로세스 식별자 또는 다른 고유 번호이다
- 호스트 이름
  - 호스트 이름은 일반적으로 사용자가 쉽게 지정할 수 있도록 숫자가 아닌 영숫자 식별자이다
    - 예를 들어, 사이트 A에는 이름이 program, student, faculty 및 cs인 호스트가 있을 수 있다
      - 호스트 이름 program은 숫자 호스트 주소(128.148.31.100) 보다 확실히 기억하기 쉽다
  - 이름은 사람이 사용하기 편리하지만 컴퓨터는 속도와 단순성을 위해 숫자를 선호한다
  - 이러한 이유로 호스트 이름을 호스트 id로 변환하는 기법이 있어야 한다
    - 호스트 id는 네트워킹 하드웨어에 대한 대상 시스템을 설명한다
  - 호스트 이름의 경우 두 가지 가능성이 있다
    - (1) 모든 호스트는 네트워크를 통해 연결할 수 있는 다른 모든 호스트의 이름과 숫자 주소를 가지고 있는 데이터 파일을 가질 수 있다
      - 컴파일 시 바인딩과 유사
      - 이 모델의 문제점은 네트워크에서 호스트를 추가하거나 제거하려면 모든 호스트에서 데이터 파일을 업데이트해야 한다는 것이다
      - 실제로 ARPANET 초기에는 모든 시스템이 정기적으로 복사되는 표준 호스트 파일이 있었다
      - 그러나 네트워크가 성장함에 따라 이 방법을 사용할 수 없게 되었다
    - (2) 대안은 네트워크상의 시스템 간에 정보를 배포하는 것이다
      - 네트워크는 프로토콜을 사용하여 정보를 배포하고 검색해야 한다
      - 이 기법은 실행 시간 바인딩과 같다
      - `인터넷은 호스트 이름 확인을 위해 DNS(domain-name system)를 사용`한다
- `DNS`는 `호스트의 이름 지정` 구조뿐만 아니라 `이름-주소 변환`을 지정한다
  - 인터넷의 호스트는 논리적으로 IP 주소라는 여러 부분으로 구성된 이름으로 주소가 표기된다
  - IP주소의 부분들은 필드를 구분하는 마침표와 함게 가장 구체적인 것에서 가장 일반적인 것으로 진행된다
  - e.g.
    - eric.cs.yale.edu 는 최상위 도메인 edu 내의 Yale 대학교의 cs(컴퓨터 과학부)에서 호스트 eric을 나타낸다
  - 다른 최상위 도메인에는 상업용 사이트의 com, 조직의 org, 조직 유형이 아닌 국가별로 지정된 시스템을 위한 네트워크에 연결된 각 국가의 도메인이 포함된다
  - 일반적으로 시스템은 호스트 이름 구성요소를 역순으로 검사하여 주소를 결정한다
    - 각 구성요소는 네임 서버(name server)를 가진다
      - 네임 서버 : 호스트 이름을 IP 주소로 변환하는 데 사용되는 서버
      - 네임 서버는 시스템상의 단순한 프로세스로서 이름을 받아들이고 해당 이름을 담당하는 네임 서버의 주소를 반환한다
  - 마지막 단계로, 해당 호스트의 네임 서버에 접속하여 호스트 id가 반환된다
- 예를 들어, 시스템 A의 프로세스가 eric.cs.yale.edu와 통신하도록 요청하면 다음 절차가 수행된다

  - 1. 시스템 라이브러리 또는 시스템 A의 커널은 edu 도메인 담당 네임 서버에 요청을 보내서 yale.edu를 담당하는 네임 서버의 주소를 물어본다
    - edu 도메인 담당 네임 서버는 자라 알려진 주소에 있어야만 질의가 가능하다
  - 2. edu 네임 서버는 yale.edu 네임 서버가 있는 호스트의 주소를 반환한다
  - 3. 그런 다음 시스템 A는 이 주소에서 네임 서버를 조회하고 cs.yale.edu에 대해 묻는다
  - 4. 주소가 반환된다. 이제 마지막으로 eric.cs.yale.edu에 대한 주소 요청은 해당 호스트의 인터넷 주소 호스트 id(e.g. 128.148.31.100)를 반환한다

- 이 프로토콜은 비효율적으로 보일 수 있지만 개별 호스트 처리 속도를 높이기 위해 이미 변환한 IP 주소를 캐시한다
  - 네임 서버가 이동하거나 주소가 변경되는 경우 이러한 캐시의 내용은 시간이 지남에 따라 새로 고쳐져야 한다
- 사실 프로토콜은 매우 중요하기 때문에 여러 번 최적화 되었으며 많은 안전장치가 추가되었다
- 기본 edu 네임 서버가 크래시된 경우 어떻게 되는지 고려하라
  - 어떤 edu 호스트도 주소를 변환할 수 없어서 모두 연결할 수 없을 가능성이 있다
  - 해결책은 기본 서버의 내용을 복제하는 보조 백업 네임 서버를 사용하는 것이다
- 도메인 네임 서비스에서 각 네임 서버 사이트는 해당 도메인의 호스트 정보를 업데이트 할 책임이 있다

  - 예를 들어, Yale 대학의 모든 호스트 변경은 yale.edu 네임 서버의 책임이며, 다른 어느 곳에도 보고할 필요가 없다
  - DNS 검색은 yale.edu에 직접 연락하기 때문에 업데이트 된 정보를 자동으로 검색한다
  - 도메인에는 호스트 이름 및 호스트 id 변경에 대한 책임을 더욱 분산시키기 위해 독립적인 하위 도메인이 포함될 수 있다

- 일반적으로 운영체제는 프로세서에서 `<호스트 이름, 식별자>`로 지정된 메시지를 수락하고 해당 메시지를 적절한 호스트로 전송할 책임이 있다
  - 그러면 목적지 호스트의 커널이 식별자에 의해 명명된 프로세스에 메시지를 전송한다
  - 이 프로세스는 19.3.4에 설명되어 있다
    - 19.3.4 전송 프로토콜 UDP 및 TCP

### 19.3.2 통신 프로토콜(Communications Protocols)

![그림19-5](./images/19-5.png)

- 그림 19.5 OSI 네트워크 모델을 통해 통신하는 두 대의 컴퓨터

  - 하드웨어로 구현된 3개의 최하위 층을 사용하는 두 컴퓨터 간의 논리적 통신을 보여준다

- 통신 네트워크 설계
  - 잠재적으로 느리고 오류가 발생하기 쉬운 환경에서 통신하는 비동기 연산이 가진 내재적 복잡성을 다뤄야 한다
- 프로토콜 (집합) 합의
  - 네트워크 상의 시스템은 호스트 이름 결정, 네트워크에서 호스트 찾기, 연결 설정 등을 위한 프로토콜 또는 프로토콜 집합에 합의해야 한다
- 문제를 `여러 층으로 분할`하여 설계 문제(및 관련 구현)을 단순화할 수 있다
- 시스템간 통신
  - 한 시스템의 각 층은 다른 시스템의 해당 층과 통신한다
  - 일반적으로 각 층에는 고유의 프로토콜을 가지고 있으며 특정 프로토콜을 사용하여 동위 층 간에 통신이 이루어진다
- 프로토콜은 하드웨어 또는 소프트웨어로 구현될 수 있다
- 국제 표준기구(International Standard Organization)는 다양한 네트워킹 층을 설명하기 위해 OSI(Open Systems Interconnection) 모델을 만들었다
- 이러한 계층은 실제로 구현되지는 않지만 네트워킹이 논리적으로 어떻게 작동하는지를 이해하는 데 유용하며 아래에서 설명한다

#### 층 1: 물리층(Physical Layer)

- 물리 층은 비트 스트림의 물리 전송에 대한 기계적 및 전기적 세부 사항의 처리르 담당한다
- 물리 층에서 데이터가 전기적 신호의 스트림으로 전송될 때 수신자가 데이터를 이진 데이터로 올바르게 해석할 수 있도록 통신 시스템은 이진 0과 1의 전기적 표현에 동의해야 한다
- 이 층은 네트워킹 장치의 하드웨어에서 구현된다.
- 비트 전송을 책임진다

#### 층 2: 데이터 링크 층(Data Link Layer)

- 데이터 링크 층은 물리 층에서 발생하는 오류 감지 및 복구를 포함하여 프레임 또는 고정 길이의 패킷 처리를 담당한다
- 물리 주소 간에 프레임을 보낸다

#### 층 3: 네트워크 층(Network Layer)

- 네트워크 층은 `메시지를 패킷으로` 나누고,
  - `논리 주소 사이의 연결`을 제공하고,
  - 통신 네트워크에서의 `패킷 라우팅`을 담당한다
    - 나가는 패킷의 주소처리
    - 들어오는 패킷의 주소 해독
    - 부하 수준 변경에 대한 적절한 응답을 위한 라우팅 정보 유지
- 라우터는 이 층에서 작동한다

#### 층 4: 전송 층(Transport Layer)

- 전송 층은 노드 간 메시지 전송, 패킷 순서 유지 및 혼잡을 피하기 위해 흐름 제어 등을 담당한다

#### 층 5: 세션 층(Session Layer)

- 세션 층은 세션 또는 프로세스 간 통신 프로토콜을 구현한다

#### 층 6: 프레젠테이션 층(Presentation Layer)

- 프레젠테이션 층은 문자 변환 및 반이중-전이중 모드(문자 에코)를 포함하여 네트워크의 여러 사이트 간의 형식 차이를 해결한다

#### 층 7: 응용 층(Application Layer)

- 응용 프로그램 층은 사용자와 직접 상호작용한다
- 이 층은 파일 전송, 원격 로그인 프로토콜, 이메일, 분산 데이터베이스의 스키마 처리 등을 담당한다

#### OSI 프로토콜 스택

![19-6](./images/19-6.png)

- 그림 19.6 OSI 프로토콜 스택
  - `데이터의 물리적 흐름`을 보여주는 OSI 프로토콜 스택(협력 프로토콜 스택의 집합)을 요약한 것이다
- 전송
  - 물리적으로 메시지는 응용 프로그램 층 또는 그 이상에서 시작해서 각 하위층을 차례로 통과한다
  - 각 층은 메시지를 수정할 수 있고 수신 측의 동위 층에 대한 메시지 헤더 데이터를 포함할 수 있다
  - 궁극적으로 메시지는 데이터 네트워크 층에 도달하여 하나 이상의 패킷으로 전송된다
