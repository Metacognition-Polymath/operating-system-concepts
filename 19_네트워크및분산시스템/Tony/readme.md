# 19. 네트워크 및 분산 시스템

- 분산 시스템 : 메모리나 시계를 공유하지 않는 프로세서 모음
  - 각 노드에는 자체 로컬 메모리가 있다
  - 노드는 고속버스와 같은 다양한 네트워크를 통해 서로 통신한다
  - 분산 시스템은 분산 서비스를 사용해왔다
  - 분산 시스템의 응용 프로그램들
    - 대규모 클라우드 파일 및 사진 저장 서비스
    - 대규모 데이터 집합의 경향에 대한 비즈니스 동향 분석
    - 과학 데이터의 병렬 처리 등
    - 인터넷
- 이 장에서는 분산 시스템의 일반적인 구조와 이들을 상호 연결하는 네트워크에 대해 설명한다
- 또한 현재 분산 시스템 설계의 `유형`과 `역할`의 주요 차이점을 대조한다
- 마지막으로 분산 파일 시스템의 일부 기본 설계 및 설계 당면과제를 조사한다

#### 이 장의 목표

- 네트워크 및 `분산 시스템의 장점`을 설명한다
- 분산 시스템을 상호 연결하는 `네트워크`에 대한 고수준의 `개요`를 제공한다
- 현재 사용 중인 `분산 시스템`의 `역할`과 `유형`을 정의한다
- `분산 파일 시스템` 설계와 관련된 문제를 논의한다

## 19.1 분산 시스템의 장점(Advantages of Distributed Systems)

- `분산 시스템`은 통신 `네트워크에 의해 상호 연결된` 느슨하게 결합한 `노드들의 집합`이다
- 특정 노드 관점에서 나머지 노드와 각 노드의 자원은 원격이지만 자체 자원은 로컬이다
- 노드는 크기와 기능이 다를 수 있다
  - 소형 마이크로 프로세서
  - 개인용 컴퓨터 및 대규모 범용 시스템
- 이러한 `맥락에 따라` 프로세서, 사이트, 시스템 및 호스트와 같은 `여러 이름으로 언급`된다
- 노드는 여러 유형으로 존재할 수 있다
  - 클라이언트 - 서버 구성
    - 클라이언트(노드) - 서버(노드) - 자원(노드)
  - 피어간 구성
    - 각 노드는 동등한 책임을 공유하며 클라이언트와 서버의 역할을 모두 수행할 수 있다
- 메시지

  - 낮은 수준에서 프로세스간 전달
  - 분산 시스템을 포함하여 확장
    - 파일 저장
    - 응용 프로그램 실행
    - 원격 프로시저 호출(RPC)

- 분산 시스템을 구축해야 하는 이유 3가지
  - 자원 공유
  - 계산 속도 향상
  - 신뢰성

### 19.1.1 자원 공유(Resource Sharing)

- 분산 시스템의 자원 공유
  - 원격 파일 공유
  - 분산 데이터 베이스에서 정보 처리
  - 원격 사이트에서 파일 인쇄
  - 슈퍼컴퓨터 또는 GPU(graphics processing unit)와 같은 원격 특수 하드웨어 장치 사용
  - 다른 작업을 할 수 있는 기법을 제공한다

### 19.1.2 계산 속도 향상(Computation Speedup)

- 특정 계산을 (동시에 실행할 수 있는) 하위 계산으로 분할할 수 있는 경우 분산 시스템을 통해 `하위 계산을 여러 사이트에 분산`시킬 수 있다
- 하위 계산을 동시에 실행할 수 있으므로 계산 속도가 향상된다
- 예시
  - 빅데이터 집합의 대규모 처리
  - 특정 사이트에 현재 요청이 과부하되어 있는 경우, 그중 일부는 부하가 적은 다른 사이트로 이동하거나 재배치할 수 있다
    - 부하 균등화(load balancing)
    - 분산 시스템 노드와 인터넷에서 제공되는 기타 서비스에서 흔히 볼 수 있다

### 19.1.3 신뢰성(Reliability)

- 분산 시스템에선 하나의 사이트가 장애가 발생해도 나머지 사이트는 정상 작동하여 시스템의 신뢰성이 향상된다
- 시스템이 여러 대의 독립 시스템으로 구성된 경우 하나의 장애가 나머지 부분에 영향을 미치지 않아야 한다
- 웹 서버 또는 파일 시스템 같은 중요한 시스템의 경우, 하나의 시스템 장애로 전체 시스템의 작동이 중단될 수 있다

  - 일반적으로 (하드웨어 및 데이터 모두에서) 충분한 중복성을 사용하면 일부 노드가 고장 나더라도 시스템이 계속 작동할 수 있다

- 한 사이트의 장애 -> 다른 시스템에서 감지
  - 시스템은 더 이상 해당 사이트의 서비스를 사용해서는 안된다
  - 고장 난 사이트의 기능을 다른 사이트가 인계할 수 있는 경우, 시스템은 기능의 전송이 올바르게 수행되는지 확인해야 한다
  - 고장난 사이트가 복구되거나 수리되었을 때 -> 사이트를 원할하게 시스템에 다시 통합할 수 있는 기법이 있어야 한다

## 19.2 네트워크 구조(Network Structure)

- 분산 시스템의 역할과 유형을 완전히 이해하려면 그것들을 상호 연결하는 네트워크를 이해할 필요가 있다
- 이 절은 분산 시스템과 관련된 네트워킹 개념과 과제를 소개하는 네트워크 입문서이다
- 이 장의 나머지 부분에서는 분산 시스템에 대해 구체적으로 설명한다

- 근거리 통신망(LAN, 로컬 영역 네트워크, Local Area Network)과 광역 통신망(WAN, Wide Area Network)의 두 가지 유형의 네트워크가 있다
  - 차이점 : 지리적 분포 방식
  - LAN은 소뮤모 건물(단일 건물 또는 인접한 여러 건물 등)에 분산된 호스트로 구성
  - WAN은 넓은 지역(미국 등)에 분산된 시스템으로 구성
  - 통신 네트워크의 속도와 신뢰성이 매우 다양하다는 것을 의미하며 분산 시스템 설계에 반영된다

### 19.2.1 LAN(Local Area Network, 로컬 영역 네트워크)

![19-2](./images/19-2.png)

- 그림 19.2 로컬 영역 네트워크

- 로컬 영역 네트워크는 대형 메인 프레임 컴퓨터 시스템을 대체하기 위해 등장했다
- 하나의 큰 시스템을 사용하는 것 보다 각각 자체 응용 프로그램을 갖춘 여러 개의 소형 컴퓨터를 사용하는 것이 더 경제적이다
  - 소형 컴퓨터는 주변 장치(디스크, 프린터 등)로 보완되어야 할 가능성이 높고
  - 데이터 공유 발생 가능성이 높기 때문에 이러한 소형 시스템을 네트워크에 연결하는 것은 당연한 조치였다
- 작은 지리적 지역을 포괄하도록 설계
  - 사무실, 가정환경
- 가깝기 때문에 통신 링크는 광역 네트워크의 링크보다 속도가 빠르고 오류율이 낮은 경향이 있다
- 일반적인 LAN은 여러 다른 컴퓨터, 다양한 공유 주변 장치 및 다른 네트워크에 대한 `접근을 제공하는 하나 이상의 라우터(특수 네트워크 통신 프로세서)`로 구성될 수 있다
  - 다른 컴퓨터 :워크스테이션, 서버, 랩톱, 태블릿, 스마트폰
    - [워크스테이션](https://ko.wikipedia.org/wiki/%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%85%98) : 전문분야 작업을 염두에 둔 고성능 개인용 컴퓨터
  - 다양한 공유 주변 장치 : 프린터, 저장장치 배열
- 이더넷(Ethernet)과 WiFi는 일반적으로 LAN을 구성하는 데 사용된다
- 무선 액세스 포인트(wireless access point)는 장치를 LAN에 무선으로 연결하며 자체가 라우터일 수도 아닐 수도 있다

#### 이더넷(Ethernet)

- 이더넷 네트워크는 다중 액세스 버스이기 때문에 중앙 컨트롤러가 없으므로 새 호스트를 네트워크에 쉽게 추가할 수 있다
- 이더넷 프로토콜은 IEEE 802.3 표준에 따라 정의되어 있다
- 트위스트 케이블 연결을 사용하는 일반적인 이더넷 속도는 10Mbps ~ 10Gbps 이상까지 다양할 수 있으며 다른 유형의 케이블은 100Gbps 속도에 이를 수 있다

#### WiFi

- WiFi는 현재 어디에나 있으며, 기존의 이더넷 네트워크를 보완하거나 자체적으로 존재한다
- 특히 WiFi를 사용하면 물리적 케이블을 사용하지 않고도 네트워크를 구축할 수 있다
- 각 호스트(랩톱, 스마트폰 등)는 네트워크에 참여하는 데 사용하는 무선 송신기 및 수신기를 가지고 있다
- WiFi는 IEEE 802.11 표준에 따라 정의되어 있다
- 무선 네트워크는 가정, 기업뿐만 아니라 도서관, 카페, 버스 등 공공 장소에서도 사용된다
- WiFi 속도는 11Mbps ~ 400Mbps 이상까지 다양하다

### 19.2.2 WAN(Wide Area Network, 광역 네트워크)

- 역사
  - 1960년대 사이트 간 효율적 통신을 제공하여 광범위한 사용자가 편리하고 경제적으로 하드웨어와 소프트웨어를 공유할 수 있게 하기 위한 학문적 연구 프로젝트로 등장하였다
  - 최초의 WAN은 APRANET -> 4개의 사이트 실험 네트워크
  - 현재 전 세계적인 네트워크인 인터넷(World Wide Web)으로 성장했다
- 내 생각
  - 인터넷은 WAN의 한 종류라고 생각한다
  - WAN은 인터넷을 포함하는 개념이라고 생각한다
- WAN은 넓은 지리적 지역에 물리적으로 분포되어있다
- 대표적인 링크
  - 전화선, 임대(전용 데이터) 회선, 광케이블, 마이크로파 링크, 전파 및 위성 채널
- 이 통신 링크는 트래픽을 다른 라우터 및 네트워크로 보내고 다양한 사이트 간에 정보를 전송하는 라우터에 의해 제어된다

![19-3](./images/19-3.png)

- 그림 19.3 광역 네트워크
- 인터넷 WAN을 사용하면 지리적으로 분리된 사이트의 호스트가 서로 통신할 수 있다
- `호스트`는 일반적으로 LAN에 연결되어 있으며, `지역 네트워크`를 통해 인터넷에 연결된다
- `지역 네트워크`는 `라우터`와 상호 연결되어 `전 세계 네트워크를 형성`한다
- 전문 인터넷 서비스 공급업체를 통해 인터넷에 연결
  - 전문 인터넷 서비스 공급업체 : 전화, 케이블 또는 라우터를 설치하여 인터넷에 연결하는 회사
  - 일반 가정에서 주로 사용
- 자체 사설 WAN

  - 인터넷 외 다른 WAN도 있다
  - 예를 들어 기업은 보안, 성능 또는 신뢰성 향상을 위해 자체 사설 WAN을 만들 수 있다
  - 내 생각 : 국방부 인트라넷

- 주요 도시를 연결하는 백본 WAN 연결은 광섬유 케이블을 통해 전송 속도가 매우 빠를 수 있지만 WAN은 일반적으로 LAN보다 느리다
- 실제로 많은 백본 제공 업체는 40Gbps 또는 100Gbps의 속도로 WAN을 제공한다

- 종종 WAN과 LAN은 서로 상호 연결되며, 둘 사이의 경계를 구분하는 것은 어렵다
  - 휴대 전화 데이터 네트워크를 고려해보자
    - 휴대전화는 음성 및 데이터 통신에 모두 사용된다
    - 특정 지역의 휴대전화는 송신기와 수신기가 포함된 셀타워에 연결된다
    - 네트워크의 이 부분은 휴대전화가 서로 통신하지 않는다는 점을 제외하고 LAN과 유사하다
    - 타워는 다른 타워 및 허브에 연결
      - 허브는 타워 통신을 지상선 또는 다른 통신 매체에 연결하고 패킷을 목적지로 라우팅한다
    - 네트워크의 이 부분은 WAN과 유사하다
    - 일단 적절한 타워가 패킷을 수신하면 송신기를 사용하여 올바른 수신자에게 보낸다

## 19.3 통신 구조(Communication Structure)

- 19.2에서 네트워크의 물리적 측면에 대해 살펴봤으므로 내부 작업으로 눈을 돌린다

### 19.3.1 이름 지정 및 이름 찾기(Naming and Name Resolution)

- 네트워크 통신의 첫 번째 문제는 네트워크상의 시스템 이름 지정과 관련이 있다
- 사이트 A의 프로세스가 사이트 B의 프로세스와 정보를 교환하려면 각각 서로를 지정할 수 있어야 한다
- 같은 PC 내에선 프로세스를 구분할 때 pid를 갖고 메모리를 공유하지만
  - 네트워크로 연결된 시스템은 메모리를 공유하지 않기 때문에 시스템 내의 호스트는 다른 호스트의 프로세스에 대해 알지 못한다
- 이 문제를 해결하기 위해 원격 시스템의 프로세스는 일반적으로 `<호스트 이름, 식별자>` 쌍으로 식별된다
  - 호스트 이름은 네트워크 내에서 고유한 이름이고,
  - 식별자는 해당 호스트 내에서 프로세스 식별자 또는 다른 고유 번호이다
- 호스트 이름
  - 호스트 이름은 일반적으로 사용자가 쉽게 지정할 수 있도록 숫자가 아닌 영숫자 식별자이다
    - 예를 들어, 사이트 A에는 이름이 program, student, faculty 및 cs인 호스트가 있을 수 있다
      - 호스트 이름 program은 숫자 호스트 주소(128.148.31.100) 보다 확실히 기억하기 쉽다
  - 이름은 사람이 사용하기 편리하지만 컴퓨터는 속도와 단순성을 위해 숫자를 선호한다
  - 이러한 이유로 호스트 이름을 호스트 id로 변환하는 기법이 있어야 한다
    - 호스트 id는 네트워킹 하드웨어에 대한 대상 시스템을 설명한다
  - 호스트 이름의 경우 두 가지 가능성이 있다
    - (1) 모든 호스트는 네트워크를 통해 연결할 수 있는 다른 모든 호스트의 이름과 숫자 주소를 가지고 있는 데이터 파일을 가질 수 있다
      - 컴파일 시 바인딩과 유사
      - 이 모델의 문제점은 네트워크에서 호스트를 추가하거나 제거하려면 모든 호스트에서 데이터 파일을 업데이트해야 한다는 것이다
      - 실제로 ARPANET 초기에는 모든 시스템이 정기적으로 복사되는 표준 호스트 파일이 있었다
      - 그러나 네트워크가 성장함에 따라 이 방법을 사용할 수 없게 되었다
    - (2) 대안은 네트워크상의 시스템 간에 정보를 배포하는 것이다
      - 네트워크는 프로토콜을 사용하여 정보를 배포하고 검색해야 한다
      - 이 기법은 실행 시간 바인딩과 같다
      - `인터넷은 호스트 이름 확인을 위해 DNS(domain-name system)를 사용`한다
- `DNS`는 `호스트의 이름 지정` 구조뿐만 아니라 `이름-주소 변환`을 지정한다
  - 인터넷의 호스트는 논리적으로 IP 주소라는 여러 부분으로 구성된 이름으로 주소가 표기된다
  - IP주소의 부분들은 필드를 구분하는 마침표와 함게 가장 구체적인 것에서 가장 일반적인 것으로 진행된다
  - e.g.
    - eric.cs.yale.edu 는 최상위 도메인 edu 내의 Yale 대학교의 cs(컴퓨터 과학부)에서 호스트 eric을 나타낸다
  - 다른 최상위 도메인에는 상업용 사이트의 com, 조직의 org, 조직 유형이 아닌 국가별로 지정된 시스템을 위한 네트워크에 연결된 각 국가의 도메인이 포함된다
  - 일반적으로 시스템은 호스트 이름 구성요소를 역순으로 검사하여 주소를 결정한다
    - 각 구성요소는 네임 서버(name server)를 가진다
      - 네임 서버 : 호스트 이름을 IP 주소로 변환하는 데 사용되는 서버
      - 네임 서버는 시스템상의 단순한 프로세스로서 이름을 받아들이고 해당 이름을 담당하는 네임 서버의 주소를 반환한다
  - 마지막 단계로, 해당 호스트의 네임 서버에 접속하여 호스트 id가 반환된다
- 예를 들어, 시스템 A의 프로세스가 eric.cs.yale.edu와 통신하도록 요청하면 다음 절차가 수행된다

  - 1. 시스템 라이브러리 또는 시스템 A의 커널은 edu 도메인 담당 네임 서버에 요청을 보내서 yale.edu를 담당하는 네임 서버의 주소를 물어본다
    - edu 도메인 담당 네임 서버는 자라 알려진 주소에 있어야만 질의가 가능하다
  - 2. edu 네임 서버는 yale.edu 네임 서버가 있는 호스트의 주소를 반환한다
  - 3. 그런 다음 시스템 A는 이 주소에서 네임 서버를 조회하고 cs.yale.edu에 대해 묻는다
  - 4. 주소가 반환된다. 이제 마지막으로 eric.cs.yale.edu에 대한 주소 요청은 해당 호스트의 인터넷 주소 호스트 id(e.g. 128.148.31.100)를 반환한다

- 이 프로토콜은 비효율적으로 보일 수 있지만 개별 호스트 처리 속도를 높이기 위해 이미 변환한 IP 주소를 캐시한다
  - 네임 서버가 이동하거나 주소가 변경되는 경우 이러한 캐시의 내용은 시간이 지남에 따라 새로 고쳐져야 한다
- 사실 프로토콜은 매우 중요하기 때문에 여러 번 최적화 되었으며 많은 안전장치가 추가되었다
- 기본 edu 네임 서버가 크래시된 경우 어떻게 되는지 고려하라
  - 어떤 edu 호스트도 주소를 변환할 수 없어서 모두 연결할 수 없을 가능성이 있다
  - 해결책은 기본 서버의 내용을 복제하는 보조 백업 네임 서버를 사용하는 것이다
- 도메인 네임 서비스에서 각 네임 서버 사이트는 해당 도메인의 호스트 정보를 업데이트 할 책임이 있다

  - 예를 들어, Yale 대학의 모든 호스트 변경은 yale.edu 네임 서버의 책임이며, 다른 어느 곳에도 보고할 필요가 없다
  - DNS 검색은 yale.edu에 직접 연락하기 때문에 업데이트 된 정보를 자동으로 검색한다
  - 도메인에는 호스트 이름 및 호스트 id 변경에 대한 책임을 더욱 분산시키기 위해 독립적인 하위 도메인이 포함될 수 있다

- 일반적으로 운영체제는 프로세서에서 `<호스트 이름, 식별자>`로 지정된 메시지를 수락하고 해당 메시지를 적절한 호스트로 전송할 책임이 있다
  - 그러면 목적지 호스트의 커널이 식별자에 의해 명명된 프로세스에 메시지를 전송한다
  - 이 프로세스는 19.3.4에 설명되어 있다
    - 19.3.4 전송 프로토콜 UDP 및 TCP

### 19.3.2 통신 프로토콜(Communications Protocols)

![그림19-5](./images/19-5.png)

- 그림 19.5 OSI 네트워크 모델을 통해 통신하는 두 대의 컴퓨터

  - 하드웨어로 구현된 3개의 최하위 층을 사용하는 두 컴퓨터 간의 논리적 통신을 보여준다

- 통신 네트워크 설계
  - 잠재적으로 느리고 오류가 발생하기 쉬운 환경에서 통신하는 비동기 연산이 가진 내재적 복잡성을 다뤄야 한다
- 프로토콜 (집합) 합의
  - 네트워크 상의 시스템은 호스트 이름 결정, 네트워크에서 호스트 찾기, 연결 설정 등을 위한 프로토콜 또는 프로토콜 집합에 합의해야 한다
- 문제를 `여러 층으로 분할`하여 설계 문제(및 관련 구현)을 단순화할 수 있다
- 시스템간 통신
  - 한 시스템의 각 층은 다른 시스템의 해당 층과 통신한다
  - 일반적으로 각 층에는 고유의 프로토콜을 가지고 있으며 특정 프로토콜을 사용하여 동위 층 간에 통신이 이루어진다
- 프로토콜은 하드웨어 또는 소프트웨어로 구현될 수 있다
- 국제 표준기구(International Standard Organization)는 다양한 네트워킹 층을 설명하기 위해 OSI(Open Systems Interconnection) 모델을 만들었다
- 이러한 계층은 실제로 구현되지는 않지만 네트워킹이 논리적으로 어떻게 작동하는지를 이해하는 데 유용하며 아래에서 설명한다

#### 층 1: 물리층(Physical Layer)

- 물리 층은 비트 스트림의 물리 전송에 대한 기계적 및 전기적 세부 사항의 처리르 담당한다
- 물리 층에서 데이터가 전기적 신호의 스트림으로 전송될 때 수신자가 데이터를 이진 데이터로 올바르게 해석할 수 있도록 통신 시스템은 이진 0과 1의 전기적 표현에 동의해야 한다
- 이 층은 네트워킹 장치의 하드웨어에서 구현된다.
- 비트 전송을 책임진다

#### 층 2: 데이터 링크 층(Data Link Layer)

- 데이터 링크 층은 물리 층에서 발생하는 오류 감지 및 복구를 포함하여 프레임 또는 고정 길이의 패킷 처리를 담당한다
- 물리 주소 간에 프레임을 보낸다

#### 층 3: 네트워크 층(Network Layer)

- 네트워크 층은 `메시지를 패킷으로` 나누고,
  - `논리 주소 사이의 연결`을 제공하고,
  - 통신 네트워크에서의 `패킷 라우팅`을 담당한다
    - 나가는 패킷의 주소처리
    - 들어오는 패킷의 주소 해독
    - 부하 수준 변경에 대한 적절한 응답을 위한 라우팅 정보 유지
- 라우터는 이 층에서 작동한다

#### 층 4: 전송 층(Transport Layer)

- 전송 층은 노드 간 메시지 전송, 패킷 순서 유지 및 혼잡을 피하기 위해 흐름 제어 등을 담당한다

#### 층 5: 세션 층(Session Layer)

- 세션 층은 세션 또는 프로세스 간 통신 프로토콜을 구현한다

#### 층 6: 프레젠테이션 층(Presentation Layer)

- 프레젠테이션 층은 문자 변환 및 반이중-전이중 모드(문자 에코)를 포함하여 네트워크의 여러 사이트 간의 형식 차이를 해결한다

#### 층 7: 응용 층(Application Layer)

- 응용 프로그램 층은 사용자와 직접 상호작용한다
- 이 층은 파일 전송, 원격 로그인 프로토콜, 이메일, 분산 데이터베이스의 스키마 처리 등을 담당한다

#### OSI 프로토콜 스택

![19-6](./images/19-6.png)

- 그림 19.6 OSI 프로토콜 스택
  - `데이터의 물리적 흐름`을 보여주는 OSI 프로토콜 스택(협력 프로토콜 스택의 집합)을 요약한 것이다
- 전송
  - 물리적으로 메시지는 응용 프로그램 층 또는 그 이상에서 시작해서 각 하위층을 차례로 통과한다
  - 각 층은 메시지를 수정할 수 있고 수신 측의 동위 층에 대한 메시지 헤더 데이터를 포함할 수 있다
  - 궁극적으로 메시지는 데이터 네트워크 층에 도달하여 하나 이상의 패킷으로 전송된다(그림 19.7)
  - 목적지 시스템의 데이터 링크 층은 이러한 데이터를 수신하고 메시지는 프로토콜 스택을 통해 위로 이동한다
  - 진행함에 따라 헤더를 분석, 수정 및 제거한다
  - 마지막으로 수신 프로세스에서 사용하기 위해 응용 프로그램 층에 도달한다

![19-7](./images/19-7.png)

- 그림 19.7 OSI 네트워크 메시지

- OSI 모델은 네트워크 프로토콜에서 행해진 초기 작업 중 일부를 공식화하지만, 1970년대 후반에 개발되어 현재 널리 사용되지는 않는다
  - OSI 모델은 네트워크 프로토콜의 기본 개념을 설명하는 데 유용하지만, 실제로는 TCP/IP 프로토콜 스택이 널리 사용된다
  - 가장 널리 채택된 프로토콜 스택은 거의 모든 인터넷 사이트에 의해 채택된 TCP/IP 모델(인터넷 모델)일 것이다
  - TCP/IP 프로토콜 스택은 OSI 모델보다 더 적은 수의 층을 가진다
  - 이론적으로는 각 OSI 계층의 여러 층의 기능을 결합하기 때문에 OSI네트워킹보다 구현하기가 더 어렵지만 효율적이다

![19-8](./images/19-8.png)

- 그림 19.8 OSI와 TCP/IP 프로토콜 스택

- TCP/IP 응용 프로그램 층은 인터넷에서 널리 사용되는 HTTP, FTP, SSH, DNS 및 SMTP를 포함한 여러 프로토콜을 식별한다

  - 전송층은 신뢰할 수 없는 무연결(User Datagram Protocol, UDP)과 안정적인 연결 지향(Transmission Control Protocol, TCP)을 식별한다
  - 인터넷 프로토콜(IP)은 인터넷을 통해 IP 데이터 그램 또는 패킷을 라우팅 하는 일을 담당한다
  - TCP/IP 모델은 링크 또는 물리적 층을 공식적으로 식별하지 않으므로 TCP/IP 트래픽이 임의의 물리적 네트워크에서 실행될 수 있다
    - 19.3.3절에서 이더넷 네트워크를 통해 실행되는 TCP/IP 모델을 고려한다

- 보안은 최신 통신 프로토콜 설계 및 구현에서 고려해야 한다

  - 안전한 통신을 위해서는 강력한 인증과 암호화가 필요하다
    - 강력한 인증은 통신의 송신자와 수신자가 누구인지 또는 어떤 사람이어야 하는지를 보장한다
    - 암호화는 통신 내용이 도청되지 않도록 보호한다
  - 그러나 여러 가지 이유로 약한 인증과 일반 텍스트 통신이 여전히 일반적이다
    - 대부분 일반 프로토콜이 설계되었을 때 보안은 성능, 단순성, 효율성 보다 덜 중요하였다
    - 기존 인프라에 보안을 추가하는 것이 어렵고 복잡하다는 것이 입증되고 있기 때문에 이러한 유산은 오늘날에도 계속되고 있다

- 강력한 인증에는 다단계 핸드셰이크 프로토콜 또는 인증 장치가 필요하므로 프로토콜이 복잡해진다
  - 암호화 요구 사항과 관련하여 최신 CPU는 암호화 가속 명령을 포함하여 암호화를 효율적으로 수행할 수 있으므로 시스템 성능이 저하되지 않는다
  - 16.4.2절에서 논의된 것 처럼 가상 사설망에서 통신 극단을 인증하고 패킷 스트림을 암호화하여 장거리 통신을 안전하게 만들 수 있다
  - LAN 통신은 대부분의 사이트에서 암호화되지 않은 상태로 유지되지만 강력한 네이티브 인증 및 암호화를 포함하는 NFS 버전 4와 같은 프로토콜은 LAN 보안 수준을 향상하는 데 도움이 된다
    - NFS
      - NFS는 네트워크 파일 시스템을 사용하여 클라이언트가 원격 서버의 파일을 로컬 파일 시스템에 마운트할 수 있도록 한다
      - https://cheershennah.tistory.com/140
      - https://www.ibm.com/docs/ko/aix/7.1?topic=performance-network-file-systems
    - NFS4
      - NFS4는 NFS 프로토콜의 최신 버전이다
      - https://www.ibm.com/docs/ko/aix/7.1?topic=nfs-version-4

### 19.3.3 TCP/IP 예(TCP/IP Example)

- 이번 절에서 다룰 내용

  - 인터넷 상의 TCP/IP 프로토콜 스택과 관련하여 이름 변환에 대해 언급하고 그것의 작동을 검토한다
  - 그런 다음 서로 다른 이더넷 네트워크의 호스트 간에 패킷을 전송하는 데 필요한 처리를 고려한다
  - 가장 많이 사용되는 유형인 IPV4 프로토콜을 기반으로 설명한다

- TCP/IP 네트워크에서 모든 호스트에는 `이름`과 연결된 `IP주소`(또는 호스트 id)가 있다
  - 이 두 문자열은 모두 유일해야 한다
  - 네임 스페이스를 관리할 수 있도록 세그먼트 단위로 관리한다
  - 앞에서 설명한 것 처럼 호스트 이름으 계층적이어서 호스트 이름을 먼저 설명하고 다음으로 호스트가 연결된 조직을 설명한다
- 호스트 id는 네트워크 번호와 호스트 번호로 나뉜다

  - 분할 비율은 네트워크 크기에 따라 다르다
  - 인터넷 관리자가 네트워크 번호를 할당하면 해당 번호의 사이트에서 호스트 id를 자유롭게 할당할 수 있다
  - IP 주소 클래스, 호스트 id, 네트워크 id
    - https://ko.ipshu.com/a-b-c-d-e

- 송신 시스템

  - 송신시스템은 자신의 라우팅 테이블을 점검하여 프레임을 송신할 라우터를 찾는다
  - 이 라우팅 테이블은 시스템 관리자가 수동으로 구성하거나 BGP(Border Gateway Protocol)와 같은 여러 라우팅 프로토콜 중 하나에 의해 채워진다
  - 라우터는 호스트 id의 네트워크 부분을 사용하여 소스 네트워크에서 목적지 네트워크로 패킷을 전송한다
  - 그러면 목적지 시스템은 패킷을 수신한다
  - 패킷은 완전한 메시지일 수도 있고, 메시지의 일부분일 수도 있다
    - 일부분일 경우 목적지 프로세스로 메시지를 전달할 TCP/UDP(전송) 층으로 전달되기 전에 더 많은 패킷을 모아서 재조립 후 전달해야 한다

- 네트워크에서 패킷은 송신자(호스트 또는 라우터)에서 수신자로 어떻게 이동하는가?

![19-9](./images/19-9.png)

- 그림 19.9 이더넷 패킷

  - 모든 이더넷 장치에는 주소 지정을 위해 할당된 MAC(medium access control) 주소라는 고유한 바이트 번호가 있다
    - MAC 주소 : 인터넷을 할 수 있는 이더넷 기반 기기에는 모두 다 하나씩 할당되어 있는 고유한 ID
    - PC의 랜카드나 스마트폰의 와이파이 모듈에도 1대씩 할당되어 있다. 인터넷전화나 IPTV 역시 마찬가지. 2000년대 이후의 비디오 게임기에는 통신기능이 있으므로 당연히 MAC주소가 있다.
    - https://namu.wiki/w/MAC%EC%A3%BC%EC%86%8C
    - https://ko.wikipedia.org/wiki/MAC_%EC%A3%BC%EC%86%8C
    - https://netxhack.com/network/mac-address-trace-evidence/
  - LAN의 두 장치는 이 번호로만 서로 통신한다
  - 시스템이 다른 시스템으로 데이터를 전송해야하는 경우, 네트워킹 소프트웨어는 목적지 시스템의 IP주소를 포함하는 ARP(address resolution protocol)패킷을 생성한다
    - 이 패킷은 해당 이더넷 네트워크의 다른 모든 시스템으로 방송(broadcast)된다

- 브로드 캐스트는 특수 네트워크 주소(일반적으로 가장 큰 주소)를 사용하여 모든 호스트가 패킷을 수신하고 처리해야 한다는 신호를 보낸다

  - 브로드 캐스트는 서로 다른 네트워크 사이에 있는 라우터에 의해 재전송되지 않기 때문에 로컬 네트워크의 시스템만 브로드캐스트를 수신한다
  - IP주소가 ARP 요청의 IP주소와 일치하는 시스템만 응답하여 자신의 MAC 주소를 질의를 시작한 시스템에 다시 보낸다
  - 효율성을 위해 호스트는 내부 테이블에 IP-MAC 주소 쌍을 캐시한다

- 이더넷 장치가 호스트 ID와 주소를 공표하면 통신을 시작할 수 있다
  - 프로세스는 통신할 호스트 이름을 지정할 수 있다
  - 네트워킹 소프트웨어는 DNS 조회 또는 변환을 수동으로 저장할 수 있는 로컬 호스트 파일의 항목을 사용하여 해당 이름을 목적지의 IP 주소로 변환한다
- 메시지는 응용 프로그램 층에서 소프트웨어 층을 거쳐 하드웨어 층으로 전달된다

  - 하드웨어 층에서 패킷은 전송을 시작할 때 이더넷 주소를 가지고 있다
  - 트레일러는 패킷의 끝을 나타내며, 패킷 손상 감지를 위한 체크섬을 포함한다(그림 19.9)

- 패킷은 이더넷 장치에 의해 네트워크에 놓인다

  - 패킷의 데이터 섹션은 원본 메시지의 일부 또는 전부를 포함할 수 있지만 메시지를 구성하는 일부 상위 수준 헤더도 포함할 수 있다
  - 즉, 원본 메시지의 모든 부분이 소스에서 목적지로 전송되어야 하며 802.3층(데이터 링크 층) 위의 모든 헤더가 이더넷 패킷의 데이터로 포함된다

- 목적지가 소스와 동일한 로컬 네트워크에 있는 경우 시스템은 ARP 캐시를 보고 호스트의 이더넷 주소를 찾은 다음 패킷을 유선상에 놓을 수 있다

  - 그러면 목적지 이더넷 장치는 패킷에서 주소를 확인하고 패킷을 읽어 프로토콜 스택으로 전달한다

- 목적지 시스템이 소스와 다른 네트워크에 있는 경우 소스 시스템은 자신의 네트워크에서 적절한 라우터를 찾아 패킷을 보낸다

  - 그런 다음 라우터는 목적지 네트워크에 도달할 때까지 WAN을 따라 패킷을 전달한다
  - `목적지 네트워크를 연결`하는 `라우터`는 `ARP 캐시를 확인`하고 `목적지의 이더넷 번호를 찾은다음` `해당 호스트로 패킷을 보낸다`
  - 이러한 모든 전송 과정 동안 연결 고리의 다음 라우터의 이더넷 주소가 사용되기 때문에 데이터 링크 층 헤더는 변경될 수 있지만 패킷의 다른 헤더는 패킷이 프로토콜 스택에 의해 수신되고 처리될 때 까지, 그리고 마지막으로 커널에 의해 수신 프로세스로 전달될 때 까지 같은 값으로 유지된다
    - 내 생각) 패킷은 여러개의 헤더를 가지고 있고, 이 헤더들은 각각의 층에서 사용되는 헤더이다. 그리고 이 헤더들은 각각의 층에서 사용되는 헤더이기 때문에, 각각의 층에서 사용되는 헤더는 해당 층에서만 사용되고, 다른 층에서는 사용되지 않는다. 그래서 패킷이 다른 네트워크로 전송될 때, 패킷의 헤더는 변경될 수 있지만, 패킷의 다른 헤더는 변경되지 않는다는 것이다

- 찾아보기) 이더넷 패킷과 프레임 차이

  - 프레임
    - LAN의 2계층 스위치에서 일어난다. 부서 간 우편처럼 프레임은 LAN 바깥의 인터넷으로는 보낼 수 없다. 데이터를 다른 네트워크에 있는 디바이스로 보내려면, 프레임은 반드시 패킷으로 만들어야 한다
  - 패킷
    - 패킷은 3계층에서 만들어지며, 정보를 서로 다른 LAN 간에 보통 라우터(Router)를 통해 주고받을 수 있다. 라우터는 작은 규모의 네트워크인 LAN 간을 상호 연결해 정보를 좀 더 큰 규모로 상호 교환할 수 있도록 해주는데, MAC 주소 대신 IP 주소를 사용해 패킷을 전달한다.
  - 이더넷 테스트 장비를 선택할 때 중요하다
  - 서로 다른 종류의 네트워크 상에서 동작
  - https://www.itworld.co.kr/tags/2669/%EC%9D%B4%EB%8D%94%EB%84%B7/106484
  - [패킷의 이해, Ethernet 프레임, IP 헤더](https://blog.naver.com/sujunghan726/220315439853)
  - [ARP 패킷](https://blog.naver.com/sujunghan726/220315619029)

- 찾아보기) 라우터와 스위치
  - 네트워크 스위치와 허브, 라우터는 어떻게 다른 걸까
    - https://www.itworld.co.kr/news/167585#csidx9c6e081dfe2181e9a391c2f895c3b37
  - 라우터
    - 라우터는 네트워크 간의 통신을 담당하는 장비이다. 라우터는 네트워크 간의 경계에 위치하며, 라우터를 통해 다른 네트워크로 패킷을 전송한다. 라우터는 패킷을 전송할 때 패킷의 목적지 주소를 보고 패킷을 전송할 경로를 결정한다.
  - 스위치
    - 스위치는 네트워크 내부에서 통신을 담당하는 장비이다. 스위치는 네트워크 내부에 위치하며, 스위치를 통해 같은 네트워크 내의 다른 장비로 패킷을 전송한다. 스위치는 패킷을 전송할 때 패킷의 목적지 주소를 보고 패킷을 전송할 경로를 결정한다.
    - 물리적 기기를 식별
  - 허브
    - 허브는 네트워크 내부에서 통신을 담당하는 장비이다. 허브는 네트워크 내부에 위치하며, 허브를 통해 같은 네트워크 내의 다른 장비로 패킷을 전송한다. 허브는 패킷을 전송할 때 패킷의 목적지 주소를 보지 않고 패킷을 전송할 경로를 결정한다.
  - 스위치 vs. 허브
    - 허브 역시 리소스 공유를 목적으로 여러 기기를 하나로 연결할 수 있는데, 허브에 연결된 기기집단을 LAN 세그먼트라고 한다
    - 허브와 스위치가 다른 점은 기기 중 하나에서 전송된 패킷이 허브에 연결된 모든 기기로 브로드캐스팅된다는 점이다
    - 반면 스위치는 목적지 주소로 지정된 기기로 이어지는 포트만 패킷이 전달된다
    - 또한 스위치는 일반적으로 LAN 세그먼트와 세그먼트에 연결된 허브를 연결한다
    - 스위치는 동일한 LAN세그먼트의 기기를 향하는 트래픽을 걸러낸다
    - 이런 기능 덕분에 스위치는 자체 프로세싱 리소스와 네트워크 대역폭을 더 효율적으로 활용한다
  - 스위치 vs. 라우터
    - 라우터는 네트워크 트래픽 포워딩과 라우팅 기능을 제공하며 라우터라는 이름도 여기에 유래한다
    - 그러나 이 작업을 수행하는 목적과 위치가 스위치와 다르다
    - 라우터는 계층 3(네트워크 계층)에서 작동하며 네트워크를 다른 네트워크로 연결하는 데 사용된다
    - 스위치와 라우터 간의 차이를 쉽게 이해하려면 LAN과 WAN을 생각하면 된다
    - 기기는 스위치를 통해 로컬로 연결되고 네트워크는 라우터를 통해 다른 네트워크에 연결된다
    - 패킷이 인터넷에 이르기까지 일반적으로 거치는 경로
      - 기기 -> 허브 -> 스위치 -> 라우터 -> 인터넷
    - 스위칭 기능이 라우터 하드웨어에 내장돼 라우터가 스위치 역할까지 하는 경우도 있다
      - 대표적인 것이 가정용 무선 라우터다
      - WAN 포트를 통해 광대역 연결을 라우팅하지만 보통 컴퓨터와 텔레비전, 프린터 등을 위한 이더넷 케이블을 연결하는 데 사용되는 부가적인 이더넷 포트도 제공한다
      - 다른 노트북이나 스마트폰과 같은 네트워크의 다른 기기는 와이파이 라우터를 통해 연결되지만 여전히 LAN을 통해 스위칭 기능을 제공한다
      - 따라서 라우터는 사실상 스위치이기도 하다
      - 또한 라우터에 별도의 스위치를 연결해 부가적인 기기에 인터넷과 LAN 액세스를 동시에 제공할 수도 있다
