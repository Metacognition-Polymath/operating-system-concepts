# Part 9. 사례 검토

- Linux와 Windows 10의 두 가지 시스템에 대해 자세히 다룬다
- Linux
  - 널리 사용되며 무료로 사용할 수 있으며 완전한 기능을 갖춘 UNIX 시스템을 나타낸다
- Windows 10
  - UNIX의 설계 및 구현과 확연히 다른 최신 운영체제를 검토할 수 있다
  - Microsoft의 이 운영체제는 모바일 기기의 운영체제로도 사용될 수 있다
  - Windows 10은 현대적으로 설계되었으며 Microsoft에서 제작한 이전 운영체제와는 매우 다른 모양과 느낌이 있다

# 20. Linux 시스템

- 실제 시스템을 고찰함으로써 우리가 논의했던 개념들이 서로 어떻게 연관되는지를 알 수 있다
- Linux는 UNIX의 한 버전으로 휴대전화붜 슈퍼컴퓨터까지 사용되고 있다
- Linux의 역사와 발전 과정을 살펴보고
  - 사용자 측면과 프로그래머 측면에서의 인터페이스에 대해 알아보기로 한다
    - 또한 Linux가 이 인터페이스를 어떻게 설계하고 구현하는지 살펴본다
- 이 장에서는 2017년에 배포된 Linux 4.12 커널까지의 발전에 관해 설명한다

#### 이 장의 목표

- Linux가 파생된 UNIX 운영체제의 역사를 탐구하고 Linux가 설계된 원칙을 탐구한다
- Linux `프로세스와 스레드 모델`을 조사하고 Linux가 어떻게 `스레드를 스케줄`하고 `프로세스 간 통신`을 제공하는지 조사한다
- Linux에서의 메모리 관리를 살펴본다
- Linux가 파일 시스템을 어떻게 구현하고 입출력 장치를 관리하는지 탐구한다

## 20.1 Linux의 역사(Linux History)

- 1991년 Linus Tovalds라는 핀란드 학생이 80386 프로세서를 위해 만든 커널로서 크기는 작지만 완전한 기능을 가지고 있었다
- 초기부터 무료로 공개
- 초기 시스템에는 Unix 시스템의 일부만을 구현했지만 이제는 Unix의 대부분 기능을 포함하도록 발전하였다
- 완벽한 운영체제를 만들어내기 위해서는 커널 이상의 많은 것들이 필요하다
  - Linux 커널과 Linux 시스템을 구분하는 것이 필요하다
    - 커널은 Linux 공동체에 의해서 완전히 새로이 개발된 독창적인 소프트웨어이지만
    - Linux 시스템은 새로 개발된 소프트웨어 뿐만 아니라 다른 개발 프로젝트에서 가져온 소프트웨어나 다른 팀과의 협조를 통해 만들어진 것들을 포함하고 있다
- Linux가 발전해 감에 따라 Linux 시스템 위에 또 다른 계층이 필요하게 되었다 => Linux 배포본
- Linux 배포본은 Linux의 표준요소와 함게 몇 가지 관리 툴(administration tool)들의 집합을 포함한다
  - 관리 툴
    - 초기 설치와 이후의 시스템 업데이트를 간단하게 하기 위한 것들
    - 시스템 내 다른 패키지들의 설치와 삭제를 다루는 것들
    - 배포본들은 전형적으로 아래 툴들을 포함한다
      - 파일 시스템을 다루는 툴
      - 사용자 계정의 생성과 관리를 다루는 툴
      - 네트워크 관리를 위한 툴
      - 웹 브라우저
      - 워드 프로세서 등

### 20.1.1 Linux 커널(The Linux Kernel)

- 1991년 Linux 0.01 버전의 커널은 네트워킹 기능을 포함하지 않았다
- 1994년 3월 14일 Linux 1.0 버전이 발표되었고 이 버전은 네트워킹 기능을 포함하고 있었다
  - 네트워킹 프로그래밍을 위한 BSD 호환 소켓 인터페이스 뿐만 아니라
  - UNIX의 표준 TCP/IP 네트워킹 프로토콜에 대한 지원도 포함하고 있었다
  - 이더넷(Ethernet)이나 직렬 회선(serial line)이나 모뎀을 통하여 IP를 실행하는 장치 드라이버에 대한 지원도 추가되었다
- 1.0 커널은 초기의 Minix 파일 시스템의 제한이 없는 개선된 파일 시스템을 포함하였으며,
  - 고성능 디스크 접근을 위해 일군의 SCSI(Small Computer System Interface) 컨트롤러를 포함하였다
    - SCSI : 컴퓨터와 주변기기 사이의 데이터 전송을 위한 인터페이스 표준
      - https://namu.wiki/w/SCSI
      - https://ko.wikipedia.org/wiki/SCSI
      - https://docs.vmware.com/kr/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-5872D173-A076-42FE-8D0B-9DB0EB0E7362.html
  - 이 버전에서는 몇몇 하드웨어에 대한 지원이 추가되었다(인텔 PC 플랫폼 한정)
    - 사운드 카드와 다수의 마우스, 다국어 지원 키보드, 플로피 디스크, CD-ROM
  - 부동 소수점 연산 에뮬레이션이 커널에 포함
  - V Unix 스타일의 공유 메모리
  - 세마포
  - 메시지큐와 같은 프로세스 간 통신(IPC)도 구현되었다
- 1.1 부터 커널의 번호를 부여하는 표준적 관습
  - 마이너 버전이 홀수이면 개발 버전, 짝수이면 안정 버전
  - 안정된 버전에서 수정은 오직 버전의 개선을 위해서만 가능했던 것에 비해
  - 개발 중인 버전의 커널은 좀 더 새로우면서도 상대적으로 테스트가 덜 된 기능들을 포함할 수 있었다
  - 이 패턴은 3.0까지 지속되었다
- 1995년 1.2버전

  - PCI 하드웨어 버스 아키텍처를 포함한 보다 넓은 범위의 하드웨어를 지원하고 있었다
    - PCI(Peripheral Component Interconnect) : 컴퓨터의 주변기기를 연결하는 표준 버스
      - https://namu.wiki/w/PCI
      - https://ko.wikipedia.org/wiki/PCI_%EB%B2%84%EC%8A%A4
  - DOS 운영체제 에뮬레이션을 위한 것을 포함
  - 어카운팅(accounting)과 방화벽(firewalling) 기능을 포함함으로써 IP 구현을 갱신
    - 어카운팅 : 사용자의 사용량을 기록하는 것
      - https://kimtaekju-study.tistory.com/57

- 1996년 2.0
  - 여러 개의 아키텍처 지원(완벽한 64비트 native Alpha 포트 포함)
  - 다중 처리기(multiprocessor) 아키텍처 지원
  - 메모리 관리를 다루는 코드 개선
    - 블록 장치(block device)의 캐싱(caching)과는 독립적으로 파일 시스템 데이터의 단일화된 캐시를 제공하였다
  - 이러한 변화로 커널은 매우 강화된 성능의 파일 시스템과 가상 메모리를 제공할 수 있게 되었다
  - 처음으로 파일 시스템의 캐싱이 네트워크 파일 시스템으로까지 확장되었고
  - 쓰기 가능한 메모리 맵드 영역(memory-mapped region) 역시 처음으로 제공되었다
  - 내부 커널 스레드 추가
- 1999년 2.2

  - 네트워킹 향상
  - 새로운 커널 모드 NFS 디먼의 추가로 NFS 개선
  - SMP 성능 향상하기 위해 시그널 처리, 인터럽트, 다수의 입출력에 대한 락을 보다 미세한 수준에서 행해지도록 변경
    - SMP(Symmetric Multi-Processing) : 대칭형 다중 처리
      - 두 개 또는 그 이상의 프로세서가 한 개의 공유된 메모리를 사용하는 다중 프로세서 컴퓨터 아키텍처이다. 현재 사용되는 대부분의 다중 프로세서 시스템은 SMP 아키텍처를 따르고 있다.
      - https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD%ED%98%95_%EB%8B%A4%EC%A4%91_%EC%B2%98%EB%A6%AC

- 2011년 3.0

  - 리눅스 탄생 20주년을 기념하기 위해 2에서 3으로 main 버전이 변경되었다
  - 새로운 기능
    - 가상화 지원
    - 새로운 페이지 되쓰기(write-back) 설비
    - 메모리 관리 시스템 개선
    - 새로운 스레드 스케줄러인 완전 공평 스케줄러(Completely Fair Scheduler, CFS)가 포함

- 2015년 4.0
  - Linux 커널 관리자는 부 버전ㅁ나 계속되는 승급에 질리게 되었다
  - 현재 Linux 커널 버전은 배포 순서 이외의 다른 의미는 없다
  - 4.0 커널 시리즈
    - 새로운 아키텍처
    - 향상된 모바일 기능
    - 여러 가지 반복적인 개선을 지원
  - 이 장의 나머지 부분에서 이 최신 커널에 초점을 맞춘다

### 20.1.2 Linux 시스템(Linux System)

- 운영체제 구성 요소
  - Linux 커널
  - Linux 시스템
- Linux 시스템을 구성하는 많은 소프트웨어 요소들은 Linux에 한정되지 않고 다른 UNIX운영체제와 같이 쓰는 것들이다
  - 버클리의 BSD 시스템
  - MIT의 X윈도 시스템
  - Free Software Foundation의 GNU 프로젝트의 일부분으로서 개발된 많은 툴
    - GNU 프로젝트에서 만들어진 C 컴파일러인 gcc

### 20.1.3 Linux 배포본(Linux Distributions)

- 누구나 ftp 사이트로부터 자신이 필요로 하는 시스템 컴포넌트의 최신 개정판을 가져와서 컴파일함으로써 Linux 시스템을 설치할 수 있다
- 초기에는 이런 일을 개인이 수행했지만
  - 이를 간편하게 수행하려는 시도가 이루어져왔다
    - 간편한 설치를 위해서 표준화된 그리고 미리 컴파일 된 패키지의 집합을 제공
- Linux 배포본은 시스템 이상의 것을 포함하고 있었다
  - 뉴스 서버, 웹브라우저, 텍스트 처리와 같은 편집을 위한 툴 => 미리 컴파일 => 설치가능 상태로 만든 패키지
  - 시스템 설치와 관리를 위한 패키지도 포함
- 오늘날의 Linux 배포본은 패키지를 더욱 쉽고 간판하게 설치하고 업그레이드하며 삭제할 수 있도록 패키지 트래킹 데이터베이스를 제공한다
- 많은 배포본들이 등장
  - Red Hat, Debian
    - Red Hat : 상업적인 Linux 지원회사로 부터 나온 배포본
    - Debian : 가용 소프트웨어(free-software) Linux 공동체에서 나온 것
- 많은 배포본의 등장으로 이들 간에 호환성을 보장하기 위한 방법이 필요해졌다
  - 많은 배포본이 RPM 패키지 파일 포맷을 사용하거나 인식한다
  - RPM : Red Hat Package Manager
    - 리눅스 배포판에서 사용되는 소프트웨어 패키지 관리 시스템
    - https://dololak.tistory.com/312

### 20.1.4 Linux 저작권(Linux Licensing)

- Linux 커널은 Free Software Foundation에서 시작된 개념인 GNU General Public License(GPL)하에서 배포된다
- Linux는 퍼블릭-도메인(public-domain) 소프트웨어가 아니다
  - 퍼블릭-도메인 : 프로그램의 저자가 소프트웨어에 대한 저작권은 포기하지만 소스 코드에 대한 저작권은 여전히 가지고 있음을 의미
- 대신 free 소프트웨어이다
  - 누구나 아무런 제한 없이 Linux 코드를 복사하고 변경하고 원하는 방법으로 사용할 수 있으며, 복사본을 무료 제공(또는 판매)할 수 있음을 뜻한다
- Linux 저작권 개념에서 중요한 것은 Linux를 사용하는자나 일부 변경하여 변종을 만들어낸 누구든지 소스 코드 없이 배포할 수 없다는 것이다
  - GPL하에서 배포되는 소프트웨어는 실행 파일만을 포함한 형태로는 재배포될 수 없다
  - 소스 코드를 포함한 형태로만 재배포될 수 있다
- 판매도 가능한데 합리적인 배포 가격에 해당 소스 코드를 받을 수 있어야 한다

## 20.2 설계 원칙(Design Principles)

- Linux는 다중 사용자, 다중 태스킹 시스템이며, Unix와 호환되는 툴들 전부를 가지고 있다
- Linux의 파일 시스템은 전통적인 Unix 시맨틱에 충실하며, 표준적인 Unix 네트워킹 모델도 Linux에서 완벽히 구현되고 있/다
- Linux는 다양한 플랫폼에서 작동하지만 초기에는 PC 아키텍처에서만 개발되었다
- Linux는 기관이 아닌 개인들에 의해 발전해왔기 때문에, 제한된 자원으로부터 가능한 많은 기능을 뽑아내려는 시도가 행해졌다
- 오늘날 Linux는 몇백 GB 단위의 메모리와 몇 TB단위의 디스크 공간을 지닌 다중 처리기 기계에서도 작동하지만
  - 여전히 16MB 이하의 메모리에서도 유용하게 사용할 수 있다
- 최근에 진행되고 있는 작업은 `표준화`라는 목표에 초점을 맞추어 가고 있다
  - UNIX는 다양한 시스템에서 수행되는 대신 한 시스템에서 작성된 소스코드가 다른 시스템에서 제대로 컴파일 되지 않거나 작동하지 않을 수 있다는 점이 문제가 될 수 있다
  - UNIX의 경우 시스템이 다르면 시스템 콜이 완전히 동일하게 동작하지 않을 수 있다
  - `POSIX` 표준은 운영체제의 여러 측면에 관한 명세의 집합으로 구성된다
    - 운영체제의 기능들에 관한 것
    - 프로세스, 스레드, 실시간 동작(real-time operations)과 같은 확장된 기능들에 관한 것들이 있다
    - Linux는 POSIX 표준을 준수하도록 디자인되며, 최소한 두 개의 Linux 배포본이 공식적인 POSIX 인증을 획득했다
- Linux는 사용자와 프로그래머 양쪽에게 표준 인터페이스를 제공
  - UNIX와 친숙한 사람에게는 Linux의 인터페이스가 낯설지 않을 것이다
  - 인터페이스 -> C.3절, C.4절 참고

### 20.2.1 Linux 시스템의 구성요소(Components of a Linux System)

- Linux 커널 코드는 세 개의 주요 부분으로 구성되어 있다(UNIX 구현과 일치)
  - 1. 커널
    - 가상 메모리, 프로세스 등을 포함하는 운영체제의 핵심을 다루는 부분
  - 2. 시스템 라이브러리
    - 응용 프로그램이 커널과 소통하는 함수들을 정의
    - 커널 코드의 특권이 필요하지 않은 기능들을 구현한 함수들도 정의
    - 가장 중요한 시스템 라이브러리는 C 라이브러리로 libc로 알려져있다
    - 표준 C 라이브러리를 제공하는 외에도 libc는 Linux 시스템 콜 인터페이스의 `사용자 모드 측`과 또한 다른 중요한 `시스템 수준` 인터페이스를 구현한다
  - 3. 시스템 유틸리티
    - 개별적이고 특수한 관리 기능을 수행하는 프로그램
    - 몇몇 시스템 유틸리티들은 초기화할 때와 시스템 구성을 위해 한번만 불리고 끝나지만,
    - 다른 시스템 유틸리티들은 시스템 내에서 계속 돌아가면서 네트워크 연결 요청에 대한 응답, 터미널로부터의 로그인 요청처리, 로그 파일들을 업데이트하는 일 등을 수행한다(Unix 용어로 디먼(daemon)이라 불린다)

![20-1](./images/20-1.png)

- 그림 20.1 Linux 시스템의 구성요소

- 그림 20.1은 Linux 시스템 전체를 구성하는 요소를 도시한 것이다
- 커널과 그 외 다른 요소들 사이에 중요한 차이점
  - 모든 커널 코드는 프로세서에서 특권 모드(privileged mode ~ `커널 모드`)로 수행 -> 컴퓨터의 모든 자원에 대한 접근 권한을 갖는다
- Linux에서 사용자 모드의 코드가 커널에 포함될 수 없다
  - 운영체제 자체에서 지원하는 코드라 해도 커널 모드에서 반드시 동작해야 할 필요가 없는 코드들은 `커널 밖`의 시스템 라이브러리에 위치하여 `사용자 모드`로 수행된다
  - 사용자 모드에서는 시스템 자원 중 통제된 일부분만 접근할 수 있다
- 오늘날 많은 운영체제는 커널 내부가 메시지 전달 아키텍처를 채택하고 있지만
- Linux는 Unix의 전통적인 모델인 `커널이 단일화된 실행 파일로 생성`되는 형태를 그대로 유지하고 있다
  - 이런 형탤를 유지하는 이유는 성능향상을 위한 것이다
    - 모든 커널 코드와 자료구조를 하나의 주소 공간에 유지함으로써 시스템 콜을 호출하거나 하드웨어 인터럽트 발생 시 `문맥 교환(context switch)이 필요하지 않다`
  - 커널은 더욱 복잡한 프로세스 간 통신(IPC)가 아니라 비교적 싼 C 함수 호출을 통해 여러 서브 시스템 간에 데이터를 전달하거나 요구를 할 수 있다
  - 스케줄링이나 가상 메모리 관리와 같은 커널의 핵심적인 부분뿐만 아니라, 장치 드라이버나 파일 시스템, 네트워킹과 같은 `모든 커널 코드가 하나의 주소 공간 내에 유지`된다
- 모든 커널 코드가 하나의 주소 공간을 공유한다고 해서 모듈화에 대한 배려가 없다는 것을 뜻하지는 않는다
  - Linux 커널도 필요한 모듈을 실행 중에 동적으로 적재하고 메모리에서 제거(unload)할 수 있다
- Linux 커널은 운영체제의 핵심이다
  - 커널은 `프로세스를 관리`하고 `스레드를 수행`하는 데 필요한 모든 지원 기능들을 `제공`한다
  - `하드웨어 자원`들에 대한 중재되고 보호된 `액세스를 대행`해주는 서비스를 제공한다
  - 커널은 운영체제로 동작하기 위해 필요한 모든 기능들을 구현한다
- 커널은 완전한 Unix 시스템이 아니다
  - `응용`은 `시스템 라이브러리를 호출`하고, 시스템 라이브러리가 필요에 따라 운영체제 서비스를 호출한다
- 시스템 라이브러리는 응용 프로그램이 커널에 대한 시스템 콜을 할 수 있게 한다

  - 시스템 라이브러리는 또한 기본 시스템 콜보다 복잡한 형태의 서비스를 제공한다
    - 예를 들어, C 언어의 버퍼링(buffering)을 하는 관련 함수들은 모두 시스템 라이브러리에 의해 구현되며
      - 이는 기본적인 시스템 콜이 제공하는 것보다 훨씬 다양한 파일 입/출력 기능을 제공한다
  - 또한 시스템 콜과는 무관한 루틴들도 구현되어 있는데
    - 정렬 알고리즘과 관련된 것, 수학 관련 함수들, 스트링(string) 처리 루틴 같은 것들
    - Unix나 POSIX 응용 프로그램 작동을 위해 필요한 모든 함수도 시스템 라이브러리에 구현되어 있다

- Linux 시스템은 매우 `많은 종류의 사용자 모드의 프로그램을 제공`
  - `시스템 유틸리티(utility)와 사용자 유틸리티`가 이에 포함된다
  - `시스템 유틸리티`
    - `네트워크 인터페이스의 설정`, `시스템에 사용자를 추가하거나 제거`하는 일 등 `시스템을 초기화하고 관리`하는 데 필요한 모든 프로그램을 포함한다
    - 내 생각) Windows의 제어판에 해당하는 것 같다
  - `사용자 유틸리티`
    - 파일을 복사, 디렉터리를 생성, 텍스트 파일을 편집 등
    - 가장 중요한 사용자 유틸리니 중 하나는 `셸(shell)`로 UNIX 시스템의 표준 명령 라인 인터페이스(CLI)이다
    - Linux는 많은 셸을 지원하며 가장 일반적인 것은 본-어게인 셸(bourne-again shell, bash)이다

## 20.3 커널 모듈(Kernel Modules)

- Linux 커널은 `요구가 발생할 때 마다`(on demand) 커널 코드의 임의이 부분을 `모듈 단위로 적재하고 메모리에서 제거`할 수 있다
- 이러한 `적재 가능 커널 모듈(loadable kernel modules)`은 특권을 지닌 커널 모드에서 수행되고, 그 기계(machine)의 모든 하드웨어에 대한 권한을 갖게 된다
- 이론적으로 커널 모듈은 할 수 있는 일에 제한이 없지만
  - 일반적으로는 `장치 드라이버`, `파일 시스템`, `네트워킹 프로토콜 등을 다루는 부분`으로 구성된다
- 커널 모듈을 사용하는 것이 편리한 이유
  - Linux 소스 코드는 공개되어 있다
    - 커널 코드를 작업하고자 하는 사람이라면 누구나 커널을 수정해서 재컴파일 할 수 있으며, 새로운 기능을 적재하기 위해서는 컴퓨터를 재부팅 시키는 일이 필요하다
    - 그러나 새로운 드라이버(즉, 장치 드라이버)를 개발하려 할 때 커널 전체를 재컴파일하고 새로 링크(link)하고 새로 적재하는 작업을 반복하는 것은 너무 번거롭다
    - 커널 모듈을 사용한다면 커널 개발 시 이러한 번거로움을 피할 수 있다
- 커널 모듈 덕택에 Linux에서는 필요치 않은 장치 드라이버는 제외하고 표준적인 최소 커널의 Linux 시스템을 설치할 수 있다

  - 사용자가 필요한 장치 드라이버는 시스템이 시작할 때 적재, 아니면 나중에 필요할 때 시스템에 의해서 자동으로 적재
  - 필요하지 않을 때는 메모리에서 제거
  - e.g. 마우스 드라이버는 USB 마우스가 꽂혀 있을 때는 적재되고 뽑혀 있을 때는 메모리에서 제거되도록 할 수 있다

- Linux는 모듈을 지원하는 네 개의 컴포넌트가 있다
  - 1. 모듈 관리(module management) 시스템
    - 모듈이 메모리에 적재되고 커널의 나머지 부분과 소통할 수 있도록 하는 부분
  - 2. 모듈 로더와 언로더(unloader)
    - 사용자 모드 유틸리티로 모듈 관리 시스템과 협력하여 모듈을 메모리에 적재한다
  - 3. 장치 드라이버 등록(driver registration) 시스템
    - 새로운 장치 드라이버의 존재를 커널의 다른 부분에 알리게 한다
  - 4. 충돌 해결 기법(conflict-resolution mechanism)
    - 서로 다른 장치 드라이버들이 하드웨어 자원을 예약하는 것을 도와주고 이들 자원을 다른 드라이버가 상충하게 사용하는 것을 막아준다

### 20.3.1 모듈 관리(Module Management)

- 모듈을 적재하는 것은 단순히 실행 파일을 커널 메모리 영역에 올려놓는 것 이상을 요구한다
  - 시스템은 모듈이 참조하는 커널 심볼(symbol)이나 진입 지점(entry point)이 커널 주소 영역의 정확한 위치를 가리킬 수 있도록 모듈을 확실히 설정해야 한다
- Linux 모듈 적재 작업 두 부분
  - 커널 메모리 내에서 모듈 코드를 관리하는 일
  - 모듈이 참조하는 심볼을 다루는 일
- Linux 커널은 심볼 테이블(symbol table)을 가지고 있다
  - 이 심볼 테이블은 커널에 정의된 모든 심볼을 가지고 있는 것이 아닌, 이 심볼들은 커널에 의해 명시적으로 수출(export)되어야만 한다
  - 이러한 심볼들의 집합은 잘 정의된(well-defined) 인터페이스를 구성함으로써 이를 통해 모듈들은 커널과 소통할 수 있게 된다
- 커널 함수로부터 심볼을 수출(export)하려면 프로그래머가 이를 명시적으로 요구해야하지만 이들 심볼을 모듈에서 사용하는 데는 특별한 노력이 필요 없다
  - 모듈을 작성하는 사람은 C언어의 표준 외부 연결 방법(standard external linking)을 사용하기만 하면 이렇게 수출(export)된 심볼을 사용할 수 있게 된다
  - 즉, 모듈 안에서 정의되지 않은 심볼의 경우, 컴파일러가 미해결(unresolved) 심볼임을 표시해 놓고 나중에 이 모듈이 커널에 적재될 때 시스템 유틸리티가 모듈 전체를 살피면서 미해결 심볼을 찾는다
  - 모든 미해결 심볼은 커널의 심볼 테이블에서 찾은 후, 이 심볼이 현재 작동하는 커널에서 정확한 주소를 모듈에 대체해 넣는다
  - 그런 후에 모듈이 메모리에 적재되도록 커널에 넘겨진다
  - 만약 시스템 유틸리티가 커널의 심볼 테이블에서 그 심볼을 찾아 낼 수 없다는 그 모듈을 적재시키는 일이 거부된다
- 모듈 메모리 적재 - 생략
- 모듈 요청자 - 생략
- 내 생각) 커널 모듈과 노드 모듈을 비교해서 생각해보자
  - 커널 모듈 ~ 노드 모듈
  - 심볼 테이블 ~ package.lock.json, package.json
  - RPM ~ npm

### 20.3.2 드라이버 등록(Driver Registration)

- 일단 `모듈이 적재`되면, `커널의 나머지 부분에 그 모듈이 제공하는 기능에 관해 알려주어야 한다`
- 이러한 일을 위해 커널은 모든 `장치 드라이버를 등록하는 동적 테이블`을 유지하면서 장치 드라이버들이 이 테이블에 언제든 추가, 혹은 삭제할 수 있도록 한다
- 한 모듈은 여러 유형의 기능을 등록할 수 있다

  - 예를 들면, 한 장치 드라이버가 한 장치에 접근하는 두 가지 별도의 기법을 등록하려 할 수 있다

- `등록 테이블`이 포함하고 있는 것들은 다음과 같은 것들이 있다

  - `장치 드라이버`
    - 문자 장치(character device)
      - 프린터, 터미널, 마우스
    - 블록 장치(모든 디스크 드라이브를 포함)
    - 네트워크 인터페이스 장치
  - `파일 시스템`
    - Linux의 `가상 파일 시스템 콜 루틴들을 구현`하고 있으면 어떤 것이나 가능하다
    - 이는 디스크에 파일을 저장하는 포맷을 구현할 수도 있고
    - NFS와 같은 네트워크 파일 시스템일 수도 있고
    - Linux의 /proc 파일 시스템 처럼 요구 시에(on-demand) 그 내용이 생성되는 가상 파일 시스템일 수도 있다
  - `네트워크 프로토콜`
    - IPX처럼 하나의 모듈이 전체 네트워크 프로토콜을 구현할 수도 있고
      - IPX(Internetwork Packet Exchange)는 Novell NetWare에서 사용하는 네트워크 프로토콜이다
      - TCP/IP와 같은 네트워크 프로토콜이다
      - TCP/IP의 인기로 인해, IPX는 쇠퇴의 길을 걷고 만다
      - 참고
        - https://ko.wikipedia.org/wiki/IPX
    - 단순히 네트워크 방화벽을 위해 패킷을 걸러내는 규칙들만을 구현할 수도 있다
  - `이진(binary) 포맷`
    - 새로운 유형의 실행 가능한 파일을 인식하고 적재하며 실행하는 방법을 지정한다

- 모듈이 동적으로 구성되도록 하기 위해 sysctl과 /proc 테이블에 새로운 항목(entry)들의 집합을 등록할 수도 있다(20.7.4절 참고)

### 20.3.3 충돌 해결(Conflict Resolution)

- 상용 Unix 제품은 보통 특정 하드웨어에서만 동작하도록 되어있다
  - 장점 : 소프트웨어 판매가자 하드웨어 구성을 잘 알고 있다
  - 그러나 IBM PC 하드웨어는 네트워크 카드나 SCSI 컨트롤러, 비디오 디스플레이 어댑터와 같이 장치 드라이버가 다양하기 때문에 하드웨어 설정이 몇 가지로 제한되지 않는다
  - 여기에 모듈화된 장치 드라이버를 허용하면 현재 구동 중인 하드웨어의 구성이 가변적이기 때문에 하드웨어 설정의 문제는 점점 어려워진다
- Linux는 `특정한 하드웨어 자원에 대한 접근을 조정`하기 위해 아래와 같은 `중앙집중식 충돌 해결 방법을 제공`하고 있다
  - 이 기법의 `목표`는 다음과 같다
    - 여러 모듈이 한 하드웨어 자원에 접근 할 때 발생하는 충돌 방지
    - 장치 드라이버가 자동으로 장치 설정을 하여(autoprobes) 기존의 장치 드라이버를 방해하는 것을 방지
    - 여러 개의 장치 드라이버가 같은 하드웨어에 접근하려 하는 경우의 조정
      - 예를 들어, 병렬 프리너 드라이버와 병렬 회선 IP(PLIP, parallel line IP) 네트워크 드라이버가 모두 병렬 프린터 포트에 접근하려 할 때의 조정
  - 이런 목적을 위해 커널은 `할당된 하드웨어 자원에 대한 목록을 유지`한다
    - 어떤 장치 드라이버든지 `자원에 접근`하려 할 때 이 `목록에서 예약`해야 한다
    - 부수적으로 특정 시점에서 어느 자원을 어느 드라이버에 할당할 것인지를 시스템 관리자가 결정할 수도 있다
  - 모듈은 이런 기법을 통해 사용하고자 하는 하드웨어 자원을 예약한다
    - 자원이 존재하지 않거나 이미 사용 중인 경우에는 모듈이 해당 자원을 예약할 수 없다
