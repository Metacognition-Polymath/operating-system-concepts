# Part2. 프로세스 관리(Process Management)

- `프로세스`는 `실행 중인 프로그램`이라고 생각할 수 있다
- 프로세스들은 작업을 완수하기 위해 자원들이 필요하다
  - CPU, 메모리, 파일, I/O장치들
  - 이러한 자원들은 보통 프로세스가 실행되는 동안 할당된다
- 대부분 시스템에서 프로세스는 작업의 단위가 된다
- 즉, 대부분 시스템은 프로세스들의 집합으로 구성된다
- `운영체제-프로세스`는 `시스템 코드를 실행`시키고, `사용자 프로세스`는 `사용자의 코드를 실행`시킨다
- 이 모든 프로세스는 병행하게 처리될 수 있다
- 최신 운영체제에서는 `여러 제어 스레드가 있는 프로세스`를 지원한다
- 여러 하드웨어 처리 코어가 있는 시스템에서 이 스레드는 병렬로 실행될 수 있다
- 운영체제의 가장 중요한 측면 중 하나는 `사용 가능한 처리 코어`에 `스레드를 예약`하는 방법이다
- 프로그래머는 CPU 스케줄러를 설계하기 위한 몇 가지 선택 사항을 사용할 수 있다

# Chapter 3. 프로세스 (Process)

- 초기 컴퓨터 시스템 -> 한 번에 하나의 프로그램만을 실행
- 오늘날 컴퓨터 시스템 -> 메모리에 다수의 프로그램이 적재, 병행 실행
  - 다양한 프로그램을 견고하게 제어하고 관리하는 것이 중요
    - 프로세스 개념 등장
- 프로세스 : `실행 중인 프로그램`
- 운영체제는 다양한 시스템 작업을 처리
- 하나의 시스템 : 일부는 사용자 코드를 실행하고 일부는 운영체제 코드를 실행하는 프로세스의 집합체
- 모든 프로세스는 잠재적으로 병행 실행이 가능
  - CPU는 이들 프로세스 가운데 다중화(multiplex - 다양한)된다
    - multiplex는 무슨 뜻일까?
      - 다중화 : 여러 개의 작업을 동시에 처리하는 것
      - 다중화된 프로세스 : CPU가 여러 프로세스를 번갈아가며 실행하는 것
- 이 장에서는 `프로세스`가 무엇인지, 운영체제에서 `어떻게 표현`되는지 그리고 `어떻게 작동`하는지에 대해 설명한다

## 이 장의 목표

- 프로세스의 개별 구성요소를 식별하고 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄 되는지 기술한다
- 운영체제에서 `프로세스를 생성하고 종료하는 방법`을 설명한다
  - 이러한 작업을 수행하는 적절한 시스템 콜을 사용하여 프로그램의 개발 등이 포함된다
- 공유 메모리 및 메시지 전달을 사용하는 `프로세스 간 통신`을 설명하고 대조한다
- 파이프와 POSIX 공유 메모리를 사용하여 `프로세스 간 통신을 수행하는 프로그램을 설계`한다
  - POSIX(IEEE 1003.1) : UNIX와 호환되는 운영체제를 위한 표준
    - https://ko.wikipedia.org/wiki/POSIX
- `소켓`과 `원격 프로시저` 호출을 사용하여 클라이언트-서버 통신을 설명한다
- Linux 운영체제와 상호 작용하는 커널 모듈을 설계한다

## 3.1 프로세스 개념

### 3.1.1 프로세스

### 3.1.2 프로세스 상태

### 3.1.3 프로세스 제어 블록

### 3.1.4 스레드

## 3.2 프로세스 스케줄링(Process Scheduling)

### 3.2.1 스케줄링 큐(scheduling queue)

### 3.2.2 CPU 스케줄링(CPU scheduling)

### 3.2.3 Context Switch

## 3.3 프로세스에 대한 연산(Operations on Processes)

### 3.3.1 프로세스 생성(Process Creation)

- https://server-talk.tistory.com/430
- https://jhnyang.tistory.com/268

### 3.3.2 프로세스 종료(Process Termination)

- 프로세스에 할당되었던 자원(메모리, 파일, 입출력 버퍼 등)을 운영체제로 반납한다

#### 3.3.2.1 Android 프로세스 계층(Android Process Hierarchy)

- 중요도 계층
- 중요한 순서
  - 전경 프로세스(forground process)
    - 사용자가 현재 상호 작용하고 있는 응용 프로그램, 화면에 보이는 현재 프로세스
  - 가시적 프로세스(visible process)
    - 전경에서 직접 볼 수 없지만 전경 프로레스가 참조하는 활동(즉, 현재 상태가 전경 프로세스에 표시되는 활동을 수행하는 프로세스)을 수행하는 프로세스
  - 서비스 프로세스(service process)
    - 백그라운드 프로세스와 유사하지만 사용자가 인지할 수 있는 활동(예: 음악 스트리밍)을 수행하는 프로세스
  - 백그라운드 프로세스(background process)
    - 사용자가 인지할 수 없는 활동(예: 앱 업데이트)을 수행하는 프로세스
  - 빈 프로세스(empty process)
    - 응용 프로그램과 관련된 활성 구성요소가 없는 프로세스

## 3.4 프로세스 간 통신(inter process communication)

- IPC 기법
  - 공유 메모리(shared memory)
    - 프로세스가 공유 메모리에 접근할 수 있도록 허용하는 기법
  - 메시지 패싱(message passing)
    - 프로세스 간에 메시지를 전달하는 기법

#### 다중 프로세스 구조 - Chrome 브라우저

- 한 탭에서 문제가 생겨도 다중 프로세스 구조로 인해 다른 탭은 영향을 받지 않는다

## 3.5 공유 메모리 시스ㅔㅁ에서의 프로세스 간 통신(IPC in shared memory systems)

- 생산자
- 소비자
- 버퍼
  - 무한버퍼(unbounded buffer)
  - 유한버퍼(bounded buffer)

## 3.6 메시지 전달 시스템에서의 프로세스 간 통신(IPC in message passing systems)

- 공유 메모리 단점 : 응용 프로그래머에 의해 명시적으로 작성되어야 한다
- 메시지 전달 방식
  - 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다

### 3.6.1 명명(Naming)

- 직접 통신

  - 하드 코딩 기법
  - send(P, message) : 프로세스 P에 메시지를 전송한다
  - receive(Q, message) : 프로레스 Q에 메시지를 수신한다

- 간접 통신
  - 메일박스(mailbox) 또는 포트(port)로 송신되고, 그것으로 부터 수신된다
  - 각 메일 박스는 고유의 id를 가진다
  - 내 생각) send, receive 함수를 사용하는 것은 같지만 옵저버 패턴으로 추상화해놓은 것 같다

### 3.6.2 동기화(Synchronization)

- blocking(봉쇄형), non-blocking(비봉쇄형) (~= synchronous(동기식), asynchronous(비동기식))

### 3.6.3 버퍼링(Buffering)

## 3.7 IPC 시스템의 사례(Examples of IPC systems)

### 3.7.1 POSIX 공유 메모리 (POSIX shared memory)

- POSIX : Portable Operating System Interface (for UNIX)
  - 이식 가능 운영체제 인터페이스
- 공유 메모리를 위한 POSIX API를 살펴본다

### 3.7.2 Mach 메시지 전달(Mach Message Passing)

- Mach 운영체제의 메시지 전달 시스템을 살펴본다
- 포트(port) : 메일박스
  - 크기가 정해져 있고 단방향
  - 양방향 통신의 경우, 메시지가 한 포트로 전송되고 응답이 별도의 응답 포트로 전송된다
- 메시지 시스템의 주요 문제점
  - 송신자의 포트에서 수신자의 포트로 메시지를 복사해야 하므로 발생하는 성능저하
  - Mach 메시지 시스템은 가상 메모리 관리 기술(10장)을 사용하여 복사 연산을 피하려고 한다
  - 송신자와 수신자 모두 동일한 메모리에 엑세스 하므로 메시지 자체는 실제로 복사되지 않는다

### 3.7.3 Windows

- Windows 운영체제는 모듈화를 이용하여 기능을 향상시키고 새로운 기능을 구현하는 시간을 감소시킨 최신 설계의 예이다
  - 서브시스템을 지원하며, 응용프로그램은 메시지 전달 기법을 통해 이들과 통신한다
  - 응용 프로그램은 서브시스템 서버의 클라이언트로 간주할 수 있다
- Windows의 메시지 전달 설비는 고급 로컬 프로시저 호출 설비(advanced local procedure call facility, ALPC)라 불린다
  - ALPC는 동일 기계상에 있는 두 프로세스 간의 통신에 사용한다
- 연결포트(connection port)와 통신포트(communication port)의 두 가지 유형의 포트를 사용한다

### 3.7.4 파이프(Pipes)

#### 3.7.4.1 일반 파이프(ordinary pipes)

- 단방향 통신
- 양방향 통신을 하고 싶다면 파이프 두 개를 사용

#### 3.7.4.2 지명 파이프(Named pipes)

- 양방향 가능
  - 반 이중 전송만이 가능
  - 데이터가 양방향으로 전송될 필요가 있다면, 보통 2개의 FIFO가 사용된다
- 부모-자식 관계도 필요하지 않음
- 다수의 writer를 가진다
- 지명 파이프를 UNIX에서는 FIFO라고 부른다
- 지명파이프는 파일 시스템의 보통 파일처럼 존재한다
  - FIFO는 mkfifo() 시스템 콜을 이요하여 생성되고
  - 일반적인 open(), read(), write(), close() 시스템 콜로 조작된다

## 3.8 클라이언트 서버 환경에서 통신(Communication in Client-Server Systems)

- `클라이언트-서버`에서 사용할 수 있는 두 가지 다른 통신 전략
  - 소켓(sockets)
  - 원격 프로시저 호출(RPCs, Remote Procedure Calls)

### 3.8.1 소켓(Sockets)

- 소켓은 통신의 endpoint를 뜻한다
- 두 프로세스가 네트워크상에서 통신을 하려면 양 프로세스마다 하나씩, 총 두 개의 소켓이 필요해진다
- 각 소켓은 IP 주소와 포트 번호 두 가지를 접합(concatenate)해서 구별한다

  - 소켓 = IP 주소 + 포트 번호

- 그림 3.26 소켓을 사용한 통신

  - host X(146.86.5.20)
    - 소켓 : 146.86.5.20:1625
  - web server(161.25.19.8)
    - 소켓 : 161.25.19.8:80

- 소켓은 클라리언트-서버 구조를 사용한다
  - 서버는 지정된 포트에 클라이언트 요청 메시지가 도착하기를 기다린다
  - 요청이 수신되면 서버는 클라이언트 소켓으로부터 연결 요청을 수락함으로써 연결이 완성된다
- Telnet, ftp, http 등의 특정 서비스를 구현하는 서버는 well-known 포트로부터 메시지를 기다린다
  - well-known 포트 : 1024 미만의 포트, 표준 서비스를 구현하는 데 사용된다
    - SSH : 22
    - Telnet : 23
    - FTP : 21
    - HTTP : 80
- Java는 세 가지 종류의 소켓을 제공한다
  - 연결 기반(TCP) : Socket 클래스로 구현
  - 비연결 기반(UDP) : DatagramSocket 클래스로 구현
  - MulticastSocket
    - DatagramSocket클래스의 서브 클래스
    - 데이터를 여러 수신자에게 보낼 수 있다
- 127.0.0.1은 loopback address로, 자신의 컴퓨터를 가리킨다

  - loopback address는 자신의 컴퓨터에 있는 프로세스들이 서로 통신할 때 사용된다

- 소켓을 이용한 통신은 분산된 프로세스 간에 널리 사용되고 효율적이긴 하지만 너무 낮은 수준이다
- 소켓은 스레드 간에 구조화되지 않은 바이트 스트림만을 통신하도록 하기 때문이다
- 이런 원시적인 바이트 스트림 데이터를 구조화하여 해석하는 것은 클라이언트와 서버의 책임이 된다
- 더 높은 수준의 통신 기법인 원격 프로시저 호출(remote procedure call, RPC)을 살펴보자

### 3.8.2 원격 프로시저 호출(RPC, Remote Procedure Calls)

- 원격 서비스와 관련한 가장 보편적인 형태 중 하나는 RPC 패러다임으로서, 네트워크에 연결된 두 시스템 사이의 통신에 사용하기 위해 프로시저 호출 기법을 추상화하는 방법으로 설계되었다
- RPC는 IPC 기반 위에 만들어진다
  - 프로세스들이 서로 다른 시스템 위에서 돌아가기 때문에 메시지 기반 통신을 사용해야 한다
- IPC 방식과는 달리 RPC 통신에서 전달되는 메시지는 구조화되어 있고, 따라서 데이터의 패킷 수준을 넘어서게 된다
- RPC 메시지
  - 각 메시지에는 `원격 포트에서 listen 중인 RPC 디먼(port 번호)의 주소`가 지정되어 있고
  - 실행되어야 할 `함수의 식별자`
  - 그리고 그 함수에게 전달되어야 할 `매개변수`가 포함된다
- 요청된 함수가 실행되고 어떤 출력이든지 별도의 메시지를 통해 요청자에게 반환된다

#### 3.8.2.1 Android RPC

## 3.9 요약 (Summary)

- 프로세스는 실행 중인 프로그램이며 프로세스의 현재 활동 상태는 프로그램 카운터와 다른 레지스터로 나타난다
- 메모리에서 프로세스의 레잉아웃은 아래 네 가지 섹션으로 표시된다
  - (1) 텍스트 - 프로세스의 코드
  - (2) 데이터
  - (3) 힙
  - (4) 스택
- 프로세스가 실행되면 상태가 변경된다
  - 프로세스의 일반적인 상태
    - (1) 준비
    - (2) 실행
    - (3) 대기
    - (4) 종료
- 프로세스 제어 블록(PCB)은 운영체제의 프로세스를 나타내는 커널 데이터 구조이다
- 프로세스 스케줄러의 역할은 CPU에서 실행할 수 있는 사용 가능한 프로세스를 선택하는 것이다
- 운영체제는 한 프로세스 실행에서 다른 프로세스 실행으로 전환할 때 문맥 교환(context switch)을 수행한다
- fork() 및 CreateProcess() 시스템 콜은 각각 UNIX 및 Windows 시스템에서 프로세스를 생성하는 데 사용된다
- 프로세스 간 통신에 공유 메모리를 사용하는 경우 두 개 이상의 프로세스가 동일한 메모리 영역을 공유한다
  - POSIX는 공유 메모리를 위한 API를 제공한다
- 메시지 전달을 사용하여 두 프로세스가 서로 메시지를 교환하여 통신할 수 있다
  - Mach 운영체제는 프로세스 간 통신의 기본 형태로 메시지 전달을 사용한다
  - Windows는 메시지 전달 방식도 제공한다
- 파이프는 두 프로세스가 통신할 수 있는 통로를 제공한다
  - 일반 및 지명 파이프의 두 가지 형태가 있다
  - 일반 파이프는 부모-자식 관계가 있는 프로세스 간 통신을 위해 설계 되었다
  - 지명 파이프가 더 일반적이며 여러 프로세스가 통신할 수 있다
- UNIX 시스템은 pipe() 시스템 콜을 통해 일반 파이프를 제공한다
  - 일반 파이프에는 읽기 종단과 쓰기 종단이 있다
  - 예를 들어, 부모 프로세스는 쓰기 종단을 사용하여 파이프로 데이터를 전송할 수 있으며 자식 프로세스는 읽기 종단에서 데이터를 읽을 수 있다
  - UNIX에서 지명 파이프를 FIFO라고 한다
- Windows 시스템도 익명 및 지명 파이프라는 두 가지 형식의 파이프를 제공한다
  - 익명 파이프는 UNIX 일반 파이프와 유사하다
  - 이들은 단방향이며 통신 프로세스 간에 부모-자식 관계가 있어야 한다
  - 지명 파이프는 UNIX의 대응되는 FIFO보다 풍부한 프로세스 간 통신 방식을 제공한다
- 클라이언트-서버 통신의 두 가지 일반적인 형태는 소켓과 원격 프로시저 호출(RPC)이다
  - 소켓을 사용하면 다른 시스템의 두 프로세스가 네트워크를 통해 통신할 수 있다
  - RPC는 다른 컴퓨터에 있는 프로세스에서 함수를 호출할 수 있는 방식으로 함수(프로시저) 호출 개념을 추상화 한다
  - 참고
    - https://blog.naver.com/wonjinho81/222568765867
    - https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460
- Android 운영체제는 바인더 프레임워크를 사용하여 프로세스 간 통신의 형태로 RPC를 사용한다
