# 12. 입출력 시스템(I/O System)

`컴퓨터의 두 가지 주요 작업`은 `계산`과 `입출력` 작업이다

많은 경우 `입출력 작업이` 계산 작업보다 `더 많다`

예를 들어, 웹 페이지를 읽거나 파일을 편집할 때, 대부분의 일은 정보를 읽거나 기록하는 것이다

입출력 시 `운영체제의 역할`은 입출력 작업 및 `입출력 장치를 관리하고 제어`하는 일이다

다른장에서도 입출력에 관한 주제가 여러 차례 언급되긴 하였지만 여기서는 입출력 전반에 걸쳐 보다 완전한 설명을 제시한다

- 입출력 하드웨어의 기본적인 사항을 설명한다
  - 하드웨어 인터페이스의 특성
  - 운영체제가 제공해야 할 내부 기능
- 운영체제가 제공하는 입출력 서비스들과 응용 프로그램에 제공되는 입출력 인터페이스에 대해 살펴본다
- `운영체제`가 `하드웨어 인터페이스`와 `응용 인터페이스` 간의 `간격을 어떻게 메우는지`를 설명한다
- 응용 프로그램이 컨트롤러 코드들을 동적으로 파이프라인 화 할 수 있는 UNIX System V의 STREAMS(streams)를 기법에 대해 논의한다
- `입출력의 성능 향상`을 위한 `운영체제 설계 원리`와 입출력의 성능에 대해 살펴본다

#### 이 장의 목표

- 운영체제의 입출력 서브시스템의 구조를 살펴본다
- 입출력 하드웨어의 원리와 복잡함에 대해 논의한다
- 입출력 하드웨어와 소프트웨어의 성능 측면을 상술한다

## 12.1 개관

- `컴퓨터에 연결된 장치들을 제어`하는 일은 운영체제의 주요 관심사이다
  - 마우스, 하드디스크, 등 입출력 장치들은 기능이나 속도 면에서 매우 다양하기 때문에 `각각의 특성에 맞는 제어가 필요`하다
  - 이와 같은 `다양한 제어 방법들`이 `커널의 입출력 서브시스템(I/O subsystem)을 형성`하며, 커널의 다른 부분이 입출력 장치를 관리하는 복잡한 일에 신경을 쓰지 않게 해준다
- `포트`, `버스`, `장치 컨트롤러` 등과 같은 표준적인 하드웨어 요소들은 엄청나게 다양한 입출력 장치를 수용할 수 있다
  - 서로 다른 장치들의 다양성을 가려주기 위해서 운영체제 커널은 장치 드라이버 모듈(device driver module)을 사용하도록 구성되어 있다
- `장치 드라이버` : `모든 하드웨어를 일관된 인터페이스로 표현`해주며, 이러한 인터페이스를 그보다 상위층인 `커널의 입출력 서브시스템에 제공`해준다
  - 이는 `시스템 콜`이 응용(application)과 운영체제 간에 `표준적인 인터페이스를 제공하는 것과 유사`하다

## 12.2 입출력 하드웨어 (I/O Hardware)

- 컴퓨터에서 작동되는 `다양한 종류의 장치`들
  - 저장장치 : 디스크, 테이프
  - 전송 장치 : 네트워크 연결, 블루투스
  - 사용자 인터페이스 장치 : 스크린, 키보드, 마우스, 오디오 입출력 등
- 이러한 다양한 입출력 장치들이 어떻게 부착되고 어떻게 제어되는지를 이해하기 위해 몇 가지 표준적인 개념들만 이해하면 된다
- `하드웨어 장치` -> 케이블 or 무선 -> 컴퓨터 시스템
  - 포트 : 연결점
    - e.g. 직렬 포트
  - 버스 : 연결선, 하나의 장치들이 공동으로 여러 선(wire)을 사용한다면 이러한 선을 버스라고 부른다
    - e.g. PCI 버스
    - 버스의 정의는 `회선의 집합`으로써 어떻게 해야 메시지를 주고 받을 수 있는 지를 정한 `프로토콜(protocol)까지를 포함`한다
- 입출력 예시
  - `메시지` - 전선 - `전압의 패턴`에 의해 전달
  - 데이지 체인 : 장치 A -> 장치 B -> 장치 C -> 컴퓨터의 포트
    - 데이지 체인은 통상 하나의 버스처럼 동작한다

![12-1](./images/12-1_%EC%A0%84%ED%98%95%EC%A0%81%EC%9D%B8PC%EB%B2%84%EC%8A%A4%EA%B5%AC%EC%A1%B0.png)

- 그림 12.1 전형적인 PC 버스 구조

- 버스는 컴퓨터 구조에서 널리 사용되고 신호 방식, 속도, 처리량 및 연결 방식에 따라 다양한 종류가 있다
- 그림 12.1은 전형적인 PC 버스 구조를 보여준다

  - PCI 버스(일반적인 PC 시스템 버스)가 프로세서 - 메모리 `서브시스템`을
    - 고속 장치와 키보드와 직렬,
    - USB 포트 처럼 상대적으로 느린 장치들을 연결하는 확장 버스(expansion bus)에 연결하는 모습을 나타내고 있다
  - 왼쪽 하단 - 네 개의 디스크가 SAS 컨트롤러에 접속된 직렬연결SCSI(SAS) 버스에 연결되어 있는 것을 볼 수 있다

- 컨트롤러 : 포트, 버스 또는 장치를 동작할 수 있는 전자장치 집합체이다
  - 직렬 포트 컨트롤러는 가장 간단한 장치 컨트롤러이다
  - 광섬유 채널(FC) 컨트롤러 : 복잡, 데이터 센터에서 사용
    - 종종 컴퓨터의 버스에 연결되는 별도의 회로보드 또는 호스트 버스 어댑터(HBA)로 구현
    - FC 프로토콜 메시지를 처리할 수 있는 프로세서, 마이크로코드 및 일부 전용 메모리가 포함되어 있다

### 12.2.1 메모리 맵드 입출력 (Memory Mapped I/O)

- `입출력 전송`을 하기 위해 `처리기(processor)`는 어떻게 `명령어와 데이터를` `컨트롤러에 전달`하는가?
  - 모든 `컨트롤러는` (제어용 또는 데이터용) `레지스터를 가지고 있다`
  - 본체의 `프로세서는` 이들 `컨트롤러의 레지스터에` `비트 패턴을 쓰거나 읽음으로써 입출력을 수행`한다
- 이러한 통신을 수행하는 한 방법은 "특별한 입출력 명령어"를 사용하는 것이다
  - 입출력 명령어는 해당 장치에 맞는 버스 회선을 선택하여 장치 레지스터로 비트들을 보내거 읽어오도록 촉발한다
- 다른 방법, 특수 입출력 명령어 대신 `장치 제어 레지스터`를 `프로세서의 주소 공간으로 매핑`한다

  - 메모리 맵드 입출력(memory-mapped I/O) 방식
  - 주변 `장치 레지스터`들은 `메모리 주소`와 `일대일 대응`된다
  - CPU는 물리 메모리에 매핑된 장치-제어 레지스터를 읽고 쓸 때 표준 데이터 명령을 사용함으로써 입출력 요청을 수행하게 된다

- 과거에는 PC는 `일부 장치`를 제어하기 위해 `입출력 명령`을 사용하고, `다른 장치들`을 제어하기 위해 `메모리 맵드 입출력`을 사용했다
  - 그림 12.2는 일반적인 PC 입출력 포트 주소들을 보여준다

![12-2](./images/12-2_PC%EC%97%90%EC%84%9C-%EC%9E%A5%EC%B9%98-%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%8F%AC%ED%8A%B8%EC%9D%98-%EC%9C%84%EC%B9%98%EC%9D%BC%EB%B6%80.png)

- 그림 12.2 PC에서 장치 입출력 포트의 위치(일부)

- `메모리 영역에 데이터를 기록`하면
  - `컨트롤러`가 자동으로 그것을 `스크린에 출력`
    - 이 메모리를 기반으로 스크린 이미지를 형성
  - 단순해서 사용하기에 좋다
  - 메모리에 기록하는 것은 입출력 명령어를 사용하는 것보다 `빠르다`
- 시간이 지남에 따라 시스템은 메모리 맵드 I/O로 바뀌어왔다
- 오늘날 대부분의 I/O는 메모리 맵드 I/O를 사용하여 장치 컨트롤러가 수행한다

- 입출력 장치 컨트롤러는 보통 네 개의 레지스터로 구성되어 있는데
  - 상태(status), 제어(control), 입력(data-in), 출력(data-out) 레지스터들이다
    - 입력 레지스터는 호스트가 입력을 얻기 위해 읽기를 수행한다
    - 출력 레지스터는 호스트가 데이터를 출력하기 위해 쓰기를 수행한다
    - 상태 레지스터는 호스트가 읽는 용도이며, 이 비트들은 현재의 명령이 완료되었는지, 입력 레지스터로부터 한 바이트를 읽어도 되는지, 그리고 오류가 있었는가와 같은 상태들을 보고한다
    - 제어 레지스터는 호스트가 주변 장치에 입출력 명령을 내리거나 장치의 모드를 변경하기 위해 쓰기를 수행하는 대상이다
      - 예를 들어, 직렬 포트의 제어 레지스터의 각 비트는 쌍방향 통신과 단방향 통신 중 어느 것을 선택할 것인지, 패리티 검사를 할 것이지, 7이나 8비트를 쓸 것인지 등을 지정할 수 있으며, 일부 비트들은 직렬 포트가 지원하는 속도 중 하나를 선택하는 데 사용된다
  - 입력 및 출력 레지스터 등의 데이터 레지스터들은 보통 1~4바이트이다
    - 어떤 컨트롤러들은 이러한 데이터 레지스터의 크기를 확장하기 위해 FIFO칩들을 제공 - FIFO칩은 데이터의 발생이 돌발적으로 많아지는 상황이 발생하더라도 대응할 수 있다

### 12.2.2 폴링

- https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)

- 호스트(컴퓨터) - 입출력 하드웨어(장치)

  - 호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만 기본적인 핸드셰이킹 개념은 간단하다
  - 예를 들어, 컨트롤러와 호스트 사이에 생산자 소비자 관계를 조정하기 위해 두 개의 비트가 사용된다고 가정하자
    - 컨트롤러는 상태 레지스터의 비지 비트를 통해 자신의 상태를 나타낸다
    - 호스트는 명령 레지스터의 명령 준비완료 비트를 통해 자신이 입출력을 원한다는 신호를 한다
    - 호스트는 다음과 같은 방법으로 `핸드셰이킹을 통해` 컨트롤러와 협력하면서 `포트를 통해 출력`을 쓴다
      - 1. 호스트가 `반복적으로` (소거될 때까지) `비지 비트를 검사`한다
      - 2. 호스트가 명령 레지스터에 쓰기 비트(write bit)를 설정하고 출력(data-out) 레지스터에 출력할 바이트를 쓴다
      - 3. 호스트가 명령 준비 `완료 비트(command-ready bit)를 설정`한다
      - 4. (입출력 하드웨어) 컨트롤러가 명령 준비 완료 비트가 설정된 것을 알아차렸을 때, 자신의 비지 비트를 설정한다
      - 5. (입출력 하드웨어) 컨트롤러는 명령 레지스터를 읽고, 쓰기 명령임을 알게 된다.
        - 출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어 장치로 출력한다
      - 6. (입출력 하드웨어) 컨트롤러는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거한다
        - 또한 입출력이 끝났음을 알리기 위해 비지 비트를 소거한다
    - 이 루프는 바이트마다 반복된다
    - 위 1단계에서 `바쁜 대기(busy-waiting), 즉, 폴링(polling)`을 하게 된다
      - 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복한다
      - 호스트가 `폴링을 반복`하고 있지만 `장치가 서비스할 준비가 되는 데 시간이 오래걸린다면`, `폴링은 비효율적`인 연산이 되고,
        자신의 상태가 바뀔 때 CPU에 그것을 통보해주는 것이 폴링을 반복하는 것보다 더욱더 효율적이다
        - `입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법`을 `인터럽트(interrupt)`라고 한다

- 인터럽트 vs 시스템콜
  - 하드웨어 인터럽트
    - 하드웨어가 발생시킨 인터럽트로 입출력 장치, 전원 등 외부적인 요인으로 발생
  - 소프트웨어 인터럽트(Trap)
    - 프로그램이 커널 함수(system call)을 호출해서 발생
  - 시스템 콜
    - 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
    - 해당 인터럽트 처리를 위해 OS로 CPU 제어권이 넘어가고 OS영역의 코드가 실행된다
  - 참고
    - https://velog.io/@minzz/OS-3.-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8interrupt-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9Csystem-call
    - https://latter2005.tistory.com/43

### 12.2.3 인터럽트

- 기본 인터럽트 기법
  - CPU 하드웨어는 인터럽트 요청 라인(interrupt request line)이라고 불리는 선을 하나 갖는다
  - CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사한다
  - `입출력 하드웨어 컨트롤러`가 이 `요청 라인에 신호`를 보내면 `CPU가` 알아차리고 각종 레지스터 값과 상태 정보를 저장한 다음, 메모리상의 `인터럽트 핸들러 루틴으로 이동(jump)`한다
  - `인터럽트 핸들러는` `인터럽트의 발생 원인을 조사`하고 `필요한 작업을 수행`한 후 `CPU를 인터럽트 전의 실행 상태로` 되돌리기 위해 인터럽트 이전으로 복귀 명령(return from interrupt)을 실행한다

![12-3](./images/12-3_%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EA%B5%AC%EB%8F%99%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%82%AC%EC%9D%B4%ED%81%B4.png)

- 그림12.3 인터럽트 구동식 입출력 사이클

  - 장치 컨트롤러는 인터럽트 요청라인에 신호를 보냄으로써 인터럽트를 야기하고
  - CPU는 인터럽트 상황을 알아차리고 인터럽트 핸들러를 수행한다
  - 핸들러는 입출력 장치를 서비스함으로써 이 인터럽트를 처리해준다

- 현대 운영체제에서 세분화된 `인터럽트 핸들링 방법이 필요`하다

  - 1. 어떤 특수한 상황에서는 `인터럽트 발생을 연기`시키는 능력이 필요하다
  - 2. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 알아내는 방법이 필요하다
  - 3. 여러 개의 인터럽트가 병행하게 발생할 때 운영체제는 높은 `우선순위`와 낮은 우선순위 인터럽트를 구별하고 긴급한 정도에 따라 먼저 응답하기 위한 다수준 인터럽트(multi-level interrupt)가 필요하다
  - 4. 페이지 폴트 및 0으로 나누기 오류와 같은 활동에 대해 운영체제의 주의를 직접 돌릴 수 있는 (I/O 요청과 별도로) 방법이 필요하다
    - 앞으로 살펴보겠지만 이 작업은 "트랩"으로 수행된다
  - 현대 컴퓨터에서는 이들 요소를 CPU와 인터럽트 컨트롤러 하드웨어에 제공하고 있다

- 대부분 CPU는 두 종류의 인터럽트 요청 라인(interrupt request line)을 가진다

  - 인터럽트 요청라인은 인터럽트가 되어서는 안되는 주요 명령 시퀀스를 수행하기 전에 CPU가 끌 수 있다
  - (1) 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 마스크 불가 인터럽트
  - (2) 필요하면 `인터럽트 기능을 잠시 중단` 시켜놓을 수 있는 `마스크 가능(maskable interrupt) 인터럽트`이다
    - 마스크 가능 인터럽트는 장치 컨트롤러가 서비스를 요청하기 위해 사용한다

- 인터럽트 기법은 보통 주소라고 하는 하나의 작은 정수를 받아들이는데 이 정수는 특정 인터럽트 핸들링 루틴을 선택하기 위해 사용된다
  - 대부분의 아키텍처에서 이 주소는 인터럽트 벡터라고 불리는 테이블의 오프셋으로 사용된다
  - 이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다
  - 컴퓨터는 인터럽트 벡터 내에 있는 주소들보다 더 많은 수의 장치가 있다
    - 이러한 문제를 해결하기 위해 인터럽트 사슬화(chaining) 기술을 사용한다
  - 인터럽트 사슬화에서는 인터럽트 벡터의 각 원소가 여러 인터럽트 핸들러로 이루어진 리스트 헤더를 가리키고 있다

![12-5](./images/12-5_intel-pentium%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%B2%A1%ED%84%B0-%ED%85%8C%EC%9D%B4%EB%B8%94.png)

- 그림 12.5 Intel Pentium 프로세서 이벤트-벡터 테이블
  - 내 생각) 웹에서 상태코드 처럼 인터럽트 벡터 테이블에는 인터럽트가 발생했을 때 해당 인터럽트를 처리할 수 있는 핸들러가 있을 것 같다
  - 0 ~ 31 : 마스크 불가능한 이벤트
    - 다양한 오류 조건(시스템 크래시를 유발)
    - 페이지 폴트(즉각 적인 조치 필요)
    - 디버깅 요청(정상 작동 중지 및 디버거 응용으로 점프)
  - 32 ~ 255 : 마스크가 가능한 것(인터럽트를 잠시 중단)
- 인터럽트 기법은 인터럽트 우선순위 수준(interrupt priority levels)의 구현을 가능하게 한다

- 오늘날 운영체제는 여러 방식으로 인터럽트 기법을 사용한다
  - 부팅 시에 운영체제는 하드웨어 버스를 조사하여 어떤 장치들이 존재하는지 알아내고, 인터럽트 벡터에 필요한 장치들의 인터럽트 핸들러들을 등록한다
  - 입출력하는 동안에는 출력을 마쳤거나, 새로 입력된 데이터를 가지고 있거나, 문제가 생긴 장치들이 인터럽트를 발생시키고 운영체제는 이를 처리한다
  - 운영체제는 인터럽트를 사용하여 여러가지 예외(exceptions)도 처리한다
    - 예외 예시
      - 어떤 수를 0으로 나누는 경우
      - 액세스해서는 안되는 메모리 영역을 액세스
      - CPU가 사용자 모드 상태에서는 허용될 수 없는 특권 명령을 수행하려고 시도했을 때 등
- 인터럽트를 야기한 이벤트들의 공통 점 : 운영체제가 가능한 최단 시간 내에 독자적인 루틴을 수행해 줄 것을 필요로 함
- 인터럽트 처리
  - 시간과 자원이 제한되어 구현하기 복잡하기 때문에 1차, 2차로 나눈다
  - 1차 인터럽트 처리기(FLIH)
    - 문맥교환, 상태저장 및 처리작업을 큐에 삽입하는 작업을 수행
  - 2차 SLIH는 요청된 작업 처리를 수행한다

#### 운영체제에서 인터럽트 사용 예

- 운영체제는 가상 메모리 페이징을 위해 인터럽트 기법을 사용한다
  - `페이지 폴트는 인터럽트`를 발생시키는 가장 일반적인 이벤트이다
    - 페이지 폴트 발생 시 CPU는 `하던 일을 미루고` `페이지 폴트를 처리하는 핸들러`로 달려간다
    - 이 핸들러는
      - 프로세스 현 상태를 저장하고,
      - 페이지 폴트를 발생시킨 프로세스를 대기(wait) 큐로 보내 잠재우고,
      - 페이지 캐시 관리를 수행하고,
      - 요청된 페이지 입력을 스케줄하고,
      - 다른 프로세스가 수행을 다시 시작하도록 스케줄하고,
      - 인터럽트로부터 돌아간다
    - 추후 일정한 시간이 지난 후에 입력이 스케줄 되었던 페이지가 드디어 메모리로 올라오게 되면, 그때 다시 인터럽트가 걸리게 되고, 그때는 대기 큐에서 잠자던 프로세스를 자시 준비 완료 큐(ready queue)로 옮긴다
    - 이 프로세스는 CPU를 재할당받고 앞에서 `중단되었던 지점부터 재개`된다
- 또 다른 예는 시스템 콜(System call)의 수행이다

  - 일반적으로 응용 프로그램은 시스템 콜을 수행하기 위해 라이브러리 루틴을 호출한다
  - 라이브러리 루틴
    - 호출인자를 점검
    - 커널로 인자를 넘겨주기 위한 자료구조를 구성
    - 소프트웨어 인터럽트(software interrupt)또는 트랩(trap)이라고 하는 '특수한 명령어'를 수행한다
      - 이 명령어는 요구되는 커널 서비스를 확인하는 피연산자를 갖는다
  - 시스템 콜이 트랩 명령어를 수행하면,
    - 인터럽트 하드웨어가 사용자 코드의 상태를 저장한 후
    - 커널모드로 전환하고
    - 요구되는 서비스를 구현하는 커널 루틴 또는 스레드를 수행한다
  - 트랩은 입출력 장치 인터럽트에 비해 낮은 인터럽트 우선순위를 가진다
    - 왜냐하면 시스템 콜은 네트워크나 디스크 서비스보다 긴급하지 않기 때문이다

- 인터럽트는 또한 커널 안에서 제어의 흐름을 관리하는 데 사용될 수 있다

  - 예를 들어, 디스크 읽기를 고려해보자
    - (1) 커널 공간으로부터 데이터를 사용자 버퍼로 복사
      - 이러한 복사는 시간이 오래걸리지만 긴급하지는 않으므로 다른 높은 우선순위 인터럽트 핸들링을 막아서는 안된다
    - (2) 그 디스크 드라이브를 위한 대기 입출력을 시작시키는 일
      - 이 단계는 높은 우선순위를 가진다
      - 왜냐하면 디스크가 효과적으로 사용되려면 이전 입출력이 끝나자마자 바로 다음 입출력을 시작 시킬 필요가 있기 때문

- 스레드를 구현한 커널 -> 응용 처리 루틴보다 인터럽트 핸들링에 우선권을 부여

  - 20장 Linux, 21장 Windows 10, 부록 C에서 UNIX의 인터럽트 아키텍처에 관해 설명한다

- `정리`
  - 인터럽트는 모든 현대 시스템에서 비동기적(asynchronous)으로 일어나는 이벤트를 처리하고
  - 커널 내의 수퍼바이저 루틴(supervisor routine)으로 달려가기 위한 방도로 사용된다
  - 이러한 일 중에서도 가장 급한 일부터 차례로 수행하기 위해서 현대 컴퓨터들은 인터럽트 간에도 다른 우선순위를 부여한다
  - 인터럽트를 발생 시키는 것들 : 입출력 장치, 하드웨어 고장, 시스템 콜과 같은 이벤트들
    - 인터럽트 야기 -> 커널 루틴 촉발
  - 인터럽트는 처리시간을 다투는 일들이 많으므로 커널의 인터럽트 처리는 매우 효율적으로 수행되어야 한다
  - `인터럽트 구동 I/O`는 이제 `폴링보다` 훨씬 `일반적`이며 폴링은 높은 처리량을 보이는 I/O에 사용된다
    - 때로는 이 둘이 함께 사용되기도 한다
    - 일부 장치 드라이버는 I/O 발생률이 낮으면 인터럽트를 사용하고 폴링이 더 빠르고 효율적인 수준까지 발생률이 증가하면 폴링으로 전환한다

### 12.2.4 직접 메모리 접근(DMA, Direct Memory Access)

- 디스크와 같은 많은 데이터를 입출력하는 장치를 위해 비싼 범용 프로세서(general-purpose processor)가 매번 바이트 전송을 제어하게 하는 것은 낭비이다
- `CPU가 상태비트를 반복적으로 검사`하면서 `1바이트씩 옮기는 입출력 방식`을 `PIO(Programmed I/O)`라고 한다
- 컴퓨터는 CPU의 `PIO 작업 중 일부`를 `DMA 컨트롤러`라고 불리는 `특수 프로세서에 위임`함으로써 CPU의 일을 줄여준다
- `DMA 전송을 시작` 시키기 위해서 `호스트는 메모리에` `DMA 명령 블록`을 쓴다
  - 이 블록에는 전송할 데이터가 있는 곳의 포인터, 전송할 장소에 대한 포인터, 그리고 전송될 바이트 수를 기록해 놓는다
    - 연속적이지 않은 소스 및 대상 주소 목록 등 명령 블록은 더 복잡해질 수 있다
- 이 분산-수집(scatter-gather) 방법을 사용하면 하나의 DMA 명령을 통해 여러 개의 전송을 실행할 수 있다
- CPU는 이 DMA 명령 블록의 주소를 `DMA에게 알려주고 자신은 다른 일을 한다`
- DMA는 CPU의 도움 없이도 자신이 직접 버스를 통해 DMA 명령 블록을 액세스하여 입출력을 수행하게 된다
- 스마트폰에서 부터 메인 프레임까지 현대의 모든 컴퓨터는 간단한 DMA 컨트롤러를 표준 구성으로 가지고 있다

- 대상 주소가 사용자 공간에 있으면 수정할 수 있고 일부 데이터를 잃을 수 있다
  - DMA로 전송된 데이터를 스레드가 액세스 할 수 있게 하려면 커널 메모리에서 사용자 메모리로 두 번째 복사 작업이 필요하다
  - 이중 버퍼링은 비효율적이다
  - 시간이 지남에 따라 I/O 전송을 수행하기 위해 메모리 매핑(12.2.1절)을 사용하게 되었다

![12-6](./images/12-6_DMA%EC%A0%84%EC%86%A1%EC%9D%98%EB%8B%A8%EA%B3%84.png)

- 그림 12.6 DMA 전송 단계

  - `DMA 컨트롤러`와 `장치 컨트롤러` 간의 `핸드셰이킹`은 `DMA-request`와 `DMA-acknowledge`라고 불리는 두 개의 선을 통해 수행된다
    - 장치 컨트롤러는 전송할 자료가 생기면 DMA-request 선에 신호를 보낸다
    - 이 신호를 받으면 컨트롤러는 한 워드를 메모리로 전송하고 DMA-request 신호를 제거한다
  - 전송이 완전히 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 건다

- DMA가 메모리 버스를 점유 중이면 CPU는 주메모리에 있는 데이터는 접근하지 못한다

  - `이러한 사이클 스틸링(cycle stealing)은 CPU의 속도를 저하하지만 입출력 작업을 DMA로 넘기는 기기 때문에 전체적으로 시스템 성능은 향상된다`
  - 어떠한 컴퓨터들은 DMA를 할 때, 물리 주소를 사용하지만 다른 컴퓨터들은 직접 가상 주소 접근(direct virtual memory access, DVMA)를 사용하기도 한다
    - DVMA를 사용하면 CPU나 메모리의 개입이 없어도 가상 주소로 두 개의 메모리 맵(memory-mapped) 장치 간에 데이터를 전송할 수가 있게 된다

- 보호 모드(protected-mode)에서 돌아가는 커널을 가진 운영체제는 일반 프로세스들이 입출력 명령을 직접 내리는 것을 금지한다
  - 이것은 접근 제어(access-control)를 하기 위해서 뿐만 아니라 시스템 고장(crash)을 방지하기 위해서도 필요하다
  - 대신 운영체제는 충분한 특권을 가진 프로세스가 하드웨어에 대해 낮은 수준의 연산을 수행하게 할 수 있는 함수들을 제공한다
  - 메모리 보호 장치가 없는 커널에서는 일반 프로세스들이 직접 장치 컨트롤러에 접근할 수 있다
    - 이 방식은 커널 통신, 문맥교환, 커널 소프트웨어의 여러 층 등을 안 거쳐도 되므로 높은 성능을 발휘할 수 있지만
    - 시스템 보안과 안정성에 큰 문제를 야기시킨다
    - 일반적인 범용 운영체제는 메모리와 장치를 보호하여 시스템이 잘못되거나 악의적인 응용 프로그램으로부터 보호할 수 있도록 한다

### 12.2.5 입출력 하드웨어 요약(I/O Hardware Summary)

- 입출력 하드웨어를 전자회로 층까지 내려가서 보면 복잡하지만 운영체제의 입출력 측면을 이해하는 데는 앞에서 설명한 개념으로 충분하다
- 주요한 개념을 다시 살펴보자

  - 버스
  - 컨트롤러(controller)
  - 입출력 포트와 레지스터
  - 호스트와 장치 컨트롤러 간의 핸드셰이킹 관계
  - 폴링이나 인터럽트를 통한 핸드셰이킹의 수행
  - 큰 데이터 전송을 DMA 컨트롤러로 넘김

- 12.2절에서 호스트와 장치 컨트롤러 간의 간단한 핸드셰이킹 사례를 보여주었다
  - 그러나 실제로는 매우 다양한 입출력 장치들이 존재한다
  - 다양한 장치들을 운영체제를 고치지 않고 추가될 수 있도록 하려면 운영체제를 어떻게 디자인해야 하는가?
  - 이 장치들은 제어 비트(control-bit) 정의도 각기 다르고, 호스트와 상호 작용하는 프로토콜도 각기 다르며, 그 장치를 위해 제공해 주어야 할 기능들도 다 각기 다를 수 있다
  - 장치가 이렇게 다양해질 때 운영체제는 어떻게 이들을 수용해야 하며, 그런데도 어떻게 응용 프로그램에 편리하고 일관된 입출력 인터페이스를 제공해 줄 수 있는가?
  - 12.3에서 알아보자
  - 내 생각) 커맨드 패턴일 것 같다
    - 컴퓨터 시스템에서 인식하는 부분과, 실제로 동작하는 부분을 분리
    - 실제로 동작하는 부분은 드라이버를 인터넷에서 다운받아서 설치
    - 설치된 드라이버는 추가된 장치를 인식하고, 커맨드 패턴을 통해 컴퓨터 시스템에 인식시킨다
    - 해당 드라이버를 통해 설치되면 컴퓨터 시스템의 특정 인터페이스(제어판 또는 시스템 설정)에서 해당 장치를 컨트롤 할 수 있는 인터페이스를 제공

## 12.3 응용 입출력 인터페이스(Application I/O Interfaces)

- 이 절에서는 모든 입출력 장치들이 일관된 방법으로 다루어질 수 있도록 운영체제가 인터페이스를 구성하는 기술을 설명한다
- 예를 들어 응용 프로그램은 디스크가 무슨 종류인지 알 필요 없이 그 디스크에 있는 파일을 오픈할 수 있고, 새로운 디스크가 나오면 기존 운영체제에 혼란을 주지 않고도 이를 쉽게 추가시킬 수 있어야 한다

- 다른 복잡한 소프트웨어 엔지니어링 문제와 같이 여기서도 추상화와 캡슐화, 소프트웨어 계층화(layering)를 사용한다
- 특히, 몇 가지 대표적인 종류의 장치에 대한 정의를 세움으로써 각 입출력 장치들의 구체적인 차이점을 추상화하여 감출 수 있다
- 각 대표적인 종류의 장치들은 인터페이스라고 불리는 표준 함수들의 집합을 통하여 접근된다
- "장치 드라이버(device driver)"라고 부르는 커널 내의 모듈들은 각 입출력 장치를 위한 구체적인 코딩을 제공하여 "인터페이스"의 표준 함수들을 내부적으로 수행한다

![12-7](./images/12-7_%EC%BB%A4%EB%84%90-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0.png)

- 그림 12.7 커널 입출력 구조

- 장치 드라이버(device driver) 층의 목적은 여러 입출력 하드웨어 간의 차이를 숨기고, 이들을 간단한 표준 인터페이스들로 보이도록 포장해서, 이것을 상위의 커널 입출력 서브시스템에 제공하는 것이다
- 이렇게 되면 입출력 서브시스템은 하드웨어와 독립적으로 되어서 운영체제 개발자의 작업을 간단하게 해준다
- 이것은 하드웨어 제조업자에게도 이익을 가져다 준다
  - 그들이 새로운 장치들을 개발할 때 그 컨트롤러를 기존 컨트롤ㄹ러 인터페이스와 같게 만들어 주든지(예를 들면 SATA)
  - 아니면 이 장치를 위한 새로운 장치 드라이버를 써주면 되는 것이다
  - 새로운 장치를 위해 운영체제 코드를 크게 고칠 필요가 없이 곧바로 컴퓨터에 붙일 수 있게 된다
- 내 생각)
  - 대부분 USB 또는 블루투스를 이용해서 새로운 장치를 연결하지만
  - 메모리(RAM)나 그래픽카드 같은 것들은 특별한 연결점이 필요할 수 있다
- 한 가지 문제는 운영체제마다 장치 드라이버 인터페이스에 대한 규격이 다르다는 것이다
  - 따라서 새로운 장치는 Windows, Linux, AIX 및 macOS에 대한 드라이버와 같은 여러 개의 장치 드라이버와 함께 제공되어야 할 것이다
  - 입출력 장치들은 그림 12.8에서 보인 바와 같이 여러 가지 차원에서 다양하다

![12-8](./images/12-8_%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%ED%8A%B9%EC%84%B1.png)

- 그림 12.8 입출력 장치의 특성

- 다양한 입출력 장치들의 종류

  - 문자 스트림과 브록(character stream and block)
    - 문자 스트림 장치는 바이트를 하나씩 전송하지만 블록 장치는 블록 단위로 전송한다
  - 순차 접근과 임의 접근(sequential access or random access)
    - 순차 장치는 순차적 순서로만 자료를 전송하지만 임의 접근 장치는 임의의 위치에 있는 자료도 입출력할 수 있다
  - 동기와 비동기(synchronous or asynchronous)
    - 동기식 장치는 시스템의 다른 측면과 조율하여 일정한 응답 시간을 보인다
    - 비동기식 장치는 다른 이벤트와 조율없이 불규칙한 혹은 예측 불가능한 응답 시간을 보인다
  - 공유와 전용(sharable or dedicated)
    - 공유 가능한 장치는 몇 개의 프로세스나 스레드에 의해 동시에 사용될 수 있으나 전용 장치는 혼자만 사용해야 한다
  - 동작 속도(speed of operation)
    - 장치 속도는 초당 몇 바이트에서 초당 수 기가바이트까지 다양하다
  - 읽기/쓰기, 읽기 전용, 한 번만 쓰기(reading/writing, read-only, write-once)
    - 몇몇 장치들은 읽기와 쓰기를 모두 수행하지만 어떤 것들은 하나만 지원한다
    - 일부는 쓰기 후에 데이터를 수정할 수 있지만 다른 하나는 한 번만 쓸 수 있으며 그 후에는 읽기 전용이다

- 응용의 접근 목적에 따라 운영체제는 장치들의 차이를 숨겨주고 `장치들을 몇 개의 범주로 분류`한다

  - 이러한 장치 접근의 분류는 유용하고 대부분의 운영체제에서 통용된다
  - 운영체제마다 구체적인 시스템 콜은 다르지만, 장치 범주는 매우 표준적이다
  - 그 범주들이란 `블록 입출력`, `문자 스트림 입출력`, `메모리 맵드 파일 접근`, `네트워크 소켓` `등`이다

- 운영체제는 또한 현재의 `시각을 알리는 클록`이나 `타이머` 같은 몇몇 다른 `장치들이 접근하기 위한 특별 시스템 콜`을 제공한다
- 어떤 운영체제는 그래픽 기반 디스플레이, 비디오와 오디오 장치를 위한 시스템 콜 집합도 제공한다
- 또한 대부분의 운영체제는 `응용 프로그램이` `입출력 장치로` `임의의 명령을 전달`하도록 하는 escape(또는 back-door) 시스템 콜을 갖고 있다
  - UNIX에서는 ioctle()이 이 시스템 콜에 해당한다
    - ioctle() 시스템 콜은
      - 새로운 시스템 콜을 만들 필요 없이 `응용 프로그램이` `임의의 장치 드라이버가 제공하는 임의의 기능을 사용`할 수 있게 한다
      - ioctle 시스템콜은 3가지 인자를 갖는다
        - (1) 장치 식별자로서 입출력 장치를 지칭
        - (2) 이 장치가 알아듣는 명령 중 하나를 지정하는 정수
        - (3) 포인터 : 메모리 상의 임의의 자료구조를 가리킬 수 있어서 응용 프로그램과 입출력 장치가 어떠한 정보라도 주고 받을 수 있도록 한다

### 12.3.1 블록 장치와 문자 장치(Block and Character Device)

### 12.3.1.1 블록 장치

- 블록 장치 인터페이스는 `디스크`나 이와 유사한 블록 지향 장치를 사용하기 위해 필요한 모든 요소를 제공하고 있다
- 일반적으로는 읽기(read)와 쓰기(write) 그리고 다음에 전송할 위치를 지정하는 탐색(seek) 명령을 제공한다
- `응용 프로그램은` 보통 `파일 시스템 인터페이스를 통해` `이 블록 인터페이스에 접근`한다
- read(), write(), seek() 등의 명령이 블록 저장장치의 핵심 작동을 대변하기 때문에 응용은 이들 장치의 저 수준 차이에 신경을 쓰지 않아도 된다

#### 비가공 입출력(raw I/O)

- 운영체제나 데이터베이스는 블록 장치를 선형 배열이라고 이해하고 사용하길 원할 것이다(속도 및 충돌 문제 때문)
- 이러한 접근 모드를 비가공 입출력이라고 한다
- 비가공 장치의 접근은 장치 제어권을 직접 응용에 일임하고 운영체제는 한 발 뒤로 물러나야 한다

#### 직접 입출력(direct I/O)

- 비가공 입출력 장치에 대해서는 어떤 운영체제 서비스도 수행되지 말아야 한다
- 이에 대해 보편화되고 있는 절충안은 운영체제가 버퍼링과 잠금을 하지 않는 모드로 파일에 대한 입출력 작업을 하는 것이다
- UNIX 시스템에서는 이런 방식을 직접 입출력이라고 한다

#### 메모리 맵드(Memory mapped) 파일 접근

- 블록 장치 위의 층으로 구현할 수 있다
- 디바이스를 읽거나 쓰는 명령을 사용하는 대신, `메모리의 특정 번지를 읽거나 쓰는 명령`으로 `파일 입출력을 대신`하는 방식
- 메모리 맵드 방식을 사용하려면 그 파일 이름을 가지고 지정된 시스템 콜을 호출
  - 그러면 이 파일을 가상 메모리로 매핑한 다음
  - 그 가상 메모리의 주소를 가지고 돌아온다
  - 이 파일의 데이터는 파일에 대응되는 메모리가 참조되어야만 실제로 메모리로 올라온다
- 파일 입출력 인터페이스를 쓰지 않고 요구 페이징을 사용하므로 더 효율적이다
- 메모리 맵드 파일에 대한 접근은 메모리를 읽고 쓰는 것만큼 단순하다
  - 가상 메모리를 제공하는 운영체제는 커널 서비스를 위해 매핑 인터페이스를 이용한다
  - 예를 들면, 운영체제가 새로운 사용자 프로그램 코드를 실행할 때 실행가능 파일을 메모리로 매핑한 후
    - 제어를 실행 가능 파일의 진입 주소로 이동한다
    - 커널이 디스크에 있는 스왑 공간을 액세스 할 때도 이 방식이 사용된다

### 12.3.1.2 문자 장치

- `키보드`는 문자 스트림(character stream) 인터페이스를 통해 접근되는 장치의 예이다
- 이러한 인터페이스의 시스템 콜은 응용 프로그램에 한 글자씩 보내거나(put) 받아 오는(get) 명령을 제공한다
- 이 인터페이스의 위에 라이브러리를 만들면 응용 프로그램이 한 줄(line)씩 읽게도 해주고, 버퍼링과 같은 편집 기능을 제공해 줄 수도 있다
- 또한 이러한 인터페이스는 프린터나 audio-board 처럼 바이트들을 선형 스트림으로 처리하는 출력 장치에도 적합하다

### 12.3.2 네트워크 장치

- 네트워크 입출력은 디스크 입출력과는 상당히 다르기 때문에 대부분의 운영체제는 디스크에서 사용되는 read, write, seek 인터페이스와는 다른 인터페이스를 네트워크 입출력에 제공한다
- UNIX나 Windows NT를 포함한 많은 운영체제에서 사용하는 인터페이스는 네트워크 소켓(socket) 인터페이스이다
- Socket을 이애하기 위해서는 벽에 나와 있는 소켓을 연상하면 된다
  - 전기 소켓에는 아무 가전제품이나 꽂을 수 있다
- 소켓 인터페이스에서 시스템 콜은
  - 응용 프로그램이 소켓을 생성하고,
  - 로컬 소켓을 원격지 주소와 연결 해주고(이 응용을 다른 응용에 의해 생성된 소켓과 연결)
  - 원격지의 응용 프로그램이 이 소켓으로 접속을 완료하였는지 알아보고
  - 연결되었으면 패킷(packet)을 주고 받도록 해준다
- 프로세스 간 통신이나 네트워크 통신을 위해 많은 방법들이 구현되어 왔다
  - 예를 들어, Windows는 네트워크 인터페이스 카드를 위해서는 한 인터페이스를 제공하고, 네트워크 프로토콜을 위해서는 다른 인터페이스를 제공한다.
  - UNIX는 네트워크 기술에서 가장 오랜 역사를 자랑하며, FIFO, full-duplex, STREAMS, 메시지 큐, 소켓 등 매우 다양한 IPC 방편들을 제공한다
- UNIX 네트워킹은 C.9절에서 자세히 소개한다

### 12.3.3 클록과 타이머

- 대부분의 컴퓨터는 하드웨어 클록과 타이머를 가지고 3가지 기본적인 기능들을 제공한다
  - 현재 시각을 제공
  - 지난 시간을 제공
  - T 시각이 되면 X 오퍼레이션을 실행
- 이 기능들을 구현하는 시스템 콜은 운영체제 사이에서 표준화되어 있지 않다
- 프로그램 가능 인터벌 타이머(programmable interval timer)
  - 지나간 시간을 재고 특정 오퍼레이션을 실행하는 하드웨어
- 최신 PC에는 고성능 이벤트 타이버(HPET)가 포함되어 있다
  - 10MHz 범위의 속도로 실행된다
  - 이보다 더 정밀해지면 가상 클록(virtual clock)을 유지하는 데 드는 오버헤드가 매우 크다
  - 부정확성은 네트워크 시간 프로토콜(NTP)을 사용하여 보정될 수 있다

### 12.3.4 봉쇄형과 비봉쇄형 입출력(Blocking and Nonblocking I/O)

![12-9](./images/12-9_%EB%91%90-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%B0%A9%EB%B2%95_%EB%8F%99%EA%B8%B0%EC%A0%81-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81.png)

- 그림 12.9 두 입출력 방법: (a) 동기적, (b) 비동기적

### 12.3.5 벡터형 입출력(Vectored I/O)

- 변형 입출력
- 하나의 시스템 콜을 호출 => 복수의 위치에 여러 입출력 연산을 수행할 수 있게 한다
- 예를 들어, UNIX readv 시스템 콜은 여러 버퍼로 이루어진 벡터를 인자로 받아 벡터의 목적지 간의 읽기 혹은 쓰기 작업을 수행한다
- 동일하게 시스템 콜을 여러번 호출할 수 있지만
  - 여러 이유로 이러한 분산-수집 방식이 유용하다
    - 문맥교환과 시스템콜 오버헤드를 줄일 수 있다
    - 스캐터-게더 입출력은 원자성을 제공하여 모든 입출력은 방해받지 않는 다는 것을 보장

## 12.4 커널 입출력 서브시스템(Kernel I/O Subsystem)

- 커널은 입출력과 관련된 많은 서비스를 제공한다
  - 입출력 스케줄링, 버퍼링, 캐싱, 스풀링, 장치 예약, 오류 처리 등
  - 이들은 하드웨어와 장치 드라이버 구조를 바탕으로 한다
  - 입출력 서브시스템은 오류가 있는 프로세스나 악의적인 사용자로부터 자신을 보호할 책임이 있다

### 12.4.9 커널 입출력 서브시스템 요약(Kernel I/O Subsystem Summary)

- 입출력 서브시스템은 광범위한 서비스를 조정하며, 이 서비스는 응용 프로그램과 커널의 다른 부분이 사용할 수 있는 것이다
- 입출력 서브시스템은 다음 사항들을 관리한다

  - 파일 및 장치의 이름 관리
  - 파일 및 장치에 대한 접근 제어
  - 작업 제어(예를 들어, 모뎀은 seek를 할 수 없음)
  - 파일 시스템을 위한 공간 할당
  - 장치(device) 할당
  - 버퍼링, 캐싱 및 스풀링
  - 입출력 스케줄링
  - 장치 상태 모니터링, 오류 처리 및 고장 복구
  - 장치 드라이버 구성(configuration) 및 초기화
  - 입출력 장치의 전원 관리

- 입출력 서브시스템의 상위 계층은 장치 드라이버가 제공하는 공통적인 인터페이스를 통해 장치(device)에 접근한다

## 12.5 입출력 요구를 위한 하드웨어 연산으로 변환(Transforming I/O Requests to Hardware Operations)

- 앞에서 장치 컨트롤러와 장치 드라이버 사이의 핸드셰이킹에 대해 설명했지만
  - 운영체제가 응용 프로그램의 요청을 네트워크 회선(wire)이나 특정 디스크 섹터에 어떻게 연계시키는지는 기술하지 않았다
- 최신 운영체제들은 입출력 요청과 장치 컨트롤러 사이에 여러 단계의 lookup table을 두어 상당한 유연성을 제공해 준다
  - 응용과 드라이버 사이에 요구를 전달하는 기법은 일반화 된 것이다
  - 따라서 커널을 다시 컴파일 하지 않고도 새로운 장치와 드라이버를 컴퓨터에 추가할 수 있다

![12-14](./images/12-14_%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%9A%94%EC%B2%AD%EC%9D%98-%EC%83%9D%EC%95%A0%EC%A3%BC%EA%B8%B0.png)

- 입출력 요청의 생애 주기
- 위 그림은 `하나의 입출력 작업`이 `엄청나게 많은 CPU 사이클을 사용`하며 많은 단계를 거친다는 것을 보여주고 있다

## 12.6 STREAMS

- UNIX 시스템 V(그리고 많은 후속 UNIX 릴리스)는 STREAMS라 불리는 흥미로운 기법을 가지고 있는데,
  - 그것은 응용 프로그램이 `동적으로 드라이버 코드의 파이프라인을 조립`할 수 있게 한다
- 스트림은 `디바이스 드라이버`와 `사용자 레벨 프로세스` 사이의 완전 `양방향 연결`을 말한다

![12-15](./images/12-15_STREAMS%EA%B5%AC%EC%A1%B0.png)

- 그림 12.15 STREAMS 구조

- 스트림은 사용자 프로세스와 상호 연동하는 `스트림 헤드`와 디바이스를 제어하는 `드라이버 엔드`, 그 둘 사이에 존재하는 0개 이상의 `스트림 모듈`로 구성된다
- 각 구성요소들은 읽기와 쓰기를 위한 한 쌍의 큐를 가지고 있다
- 큐 사이에 데이터를 전송하는 데 메시지 전달이 사용된다

- 모듈은 스트림 처리 기능을 제공
  - ioctl() 시스템 콜을 사용하여 스트림에 푸시된다
- 예를 들어, 프로세스는 스트림을 통하여

  - USB 장치(키보드 같은)를 오픈할 수 있고
  - 입력 편집을 다루는 모듈을 삽입할 수 있다

- `스트림을 사용`함으로써 얻어지는 `이득`은 디바이스 드라이버와 네트워크 프로토콜을 작성할 때 모듈식이며, `점진적인 접근`을 위한 프레임워크를 제공한다는 것이다

## 12.7 성능(Performance)

- 현대 컴퓨터들은 초당 수천 번의 인터럽트를 처리할 수 있지만 인터럽트 처리 역시 많이 부담이 되는 작업이다
- 인터럽트가 발생할 때마다 상태를 바꾸어야 하고, 인터럽트 핸들러를 수행시켜야 하고, 또 다시 상태를 복원해주어야만 한다
- 바쁜 대기(busy-wait)에서 낭비되는 사이클만 적다면 programmed I/O가 인터럽트보다 더 효율적일 수도 있다
- 네트워크 트래픽 또한 문맥 교환을 매우 많이 야기할 수 있다
- 입출력의 효율을 높이기 위해서 다음과 같은 여러 가지 원칙들을 적용할 수 있다
  - 문맥 교환의 빈도를 줄인다
  - 메모리에서 장치와 응용 프로그램 사이에 데이터가 복사되는 횟수를 줄인다
  - 인터럽트 빈호를 줄인다
    - 이러기 위해서는 한번 입출력할 때 많은 데이터를 전송해도 되고, 지능적인 컨트롤러를 사용하거나 (바쁜 대기를 최소화할 수 있다면) 폴링을 지혜롭게 사용해도 된다
  - DMA나 채널 등을 사용하여 cpu의 입출력 부담을 줄이고, 입출력과 주 연산이 될 수록 많이 중첩되도록 도모한다
  - 원시 처리 연산을 하드웨어로 구현하여 장치 컨트롤러 내의 그들의 작업이 CPU와 버스의 작업과 병렬로 진행되게 한다
  - CPU, 메모리, 버스, 입출력 등에 대한 부하가 균일하게 되도록 한다

## 12.8 요약

- 입출력에 관련된 가장 기본적인 하드웨어 장치들은 버스, 장치 컨트롤러와 장치들 자신이다
- 장치들과 메모리 사이의 자료 이동은 프로그램된 입출력으로서 CPU에 의해 직접 이루어지거나 DMA 컨트롤러에 의해 이루어진다
- 이때 장치를 제어하는 커널 모듈이 바로 장치 컨트롤러이다
- 커널의 입출력 서브시스템은 많은 서비스를 제공한다
  - 입출력 스케줄, 버퍼링, 스풀링, 오류 처리, 장치 예약 등
- STREAMS는 장치 드라이버와 네트워크 프로토콜을 작성하는 데 모듈화되고 점진적인 접근 방식을 취할 수 있는 프레임워크를 제공하는 구현이자 방법론이다
  - 스트림을 통해 드라이버를 층으로 쌓을 수 있으며 데이터는 이 층을 순차적으로 양방향으로 전송된다
- 물리 장치와 응용 프로그램 간의 많은 소프트웨어 계층으로 인해 입출력 시스템 콜은 CPU의 사용면에서 비용이 많이 든다
  - 이러한 계층이 야기하는 오버헤드의 원인에는
    - 커널의 보호 경계를 넘을 때의 문맥 교환과
    - 입출력 장치를 조작하기 위한 인터럽트와 신호
    - 커널 버퍼와 응용 프로그램 공간간의 자료 복사에 따른 CPU와 메모리 시스템의 부하 등이 있다
