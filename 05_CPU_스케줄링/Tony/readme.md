# 5. CPU 스케줄링(Scheduling)

CPU 스케줄링은 다중 프로그램 운영체제의 기본이다

운영체제는 CPU를 프로세스 간에 교환함으로써, 컴퓨터를 보다 생산적으로 만든다

스케줄링 개념 소개, 스케줄링 알고리즘 제시

운영체제는 프로세스가 아니라 커널 수준 스레드를 스케줄 한다

일반적인 스케줄링 개념 : 프로세스 스케줄링

스레드에 국한된 개념을 가리키는 경우 : 스레드 스케줄링

1코어 : CPU의 기본 계산 단위

- 프로세스가 CPU 코어에서 실행되는 방식에 관해 설명

프로세스를 스케줄링하여 "CPU에서 실행"

- 프로세스가 CPU 코어에서 실행되고 있음을 의미

#### 이 장의 목표

- 다양한 CPU 스케줄링 알고리즘을 설명한다
- 스케줄링 기준에 따라 CPU 스케줄링 알고리즘을 평가한다
- 다중 처리기(Multi-processor) 및 다중 코어 스케줄링과 관련된 쟁점을 설명한다
- 다양한 실시간 스케줄링 알고리즘을 설명한다
- Windows, Linux 및 Solaris 운영체제에서 사용되는 스케줄링 알고리즘을 설명한다
- CPU 스케줄링 알고리즘을 평가하기 위해 모델링 및 시뮬레이션을 적용한다
- 여러 가지 다른 CPU 스케줄링 알고리즘을 구현하는 프로그램을 설계한다

## 5.1 기본 개념(Basic Concepts)

- 다중 프로그래밍의 목적은 CPU 이용률을 최대화
- 어떤 프로세스가 대기해야 할 경우, 운영체제는 CPU를 그 프로세스로 부터 회수해 다른 프로세스가 CPU 사용을 양도받을 수 있다
- 이러한 스케줄링은 운영체제의 기본 기능이다
- CPU는 컴퓨터의 중요한 자원 중 하나이고 CPU 스케줄링은 운영체제 설계의 핵심이 된다

### 5.1.1 CPU - I/O Burst Cycle

- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다
- CPU burst : 프로세스가 CPU를 사용하는 시간
- I/O burst : 프로세스가 I/O를 수행하는 시간
- 짧은 CPU 버스트가 많고, 긴 CPU 버스트는 적다

### 5.1.2 CPU 스케줄러

- CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다
  - (1) 한 프로세스가 `실행 상태 -> 대기 상태`로 전환 될때
    - e.g. wait() 시스템 콜
  - (2) 프로세스가 `실행 상태 -> 준비 완료` 상태로 전환될 때
    - e.g. 인터럽트가 발생할 때
  - (3) 프로세스가 `대기 상태 -> 준비 완료` 상태로 전환될 때
    - e.g. I/O 종료 시점
  - (4) 프로세스가 종료할 때
- 1, 4 : 선택의 여지 없이 반드시 선택되어야 함
- 2, 3 : 선택의 여지가 있음

#### 선점형(preemptive), 비선점형(non-preemptive)

- `선점형` 스케줄링 : 스케줄러가 프로세스를 `강제로` 중단시키는 스케줄링
  - 프로세스가 CPU를 점유하고 있을 때, 스케줄러가 강제로 다른 프로세스를 CPU에 할당
  - 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 mutex lock과 같은 기법이 필요
  - 대부분 `최신 운영체제는` 완전한 `선점형` 스케줄링을 지원
- 비선점형 스케줄링 : 스케줄러가 프로세스를 강제로 중단시키지 않는 스케줄링
  - 한번 CPU가 할당 되면 CPU를 방출할 때 까지 점유
  - 실시간 컴퓨팅을 지원하기에는 좋은 모델이 아니다

### 5.1.4 디스패처(Dispatcher)

- 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모델

  - dispatcher : 스케줄러가 선택한 프로세스에 CPU를 할당하는 모듈

- dispatcher가 하는 일

  - 한 프로세스에서 다른 프로세스로 context switch
  - 사용자 모드로 전환
  - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)

- 디스패치 지연(dispatcher latency) : 디스패처가 프로세스를 CPU에 할당하기 위해 걸리는 시간
- context switching이 얼마나 자주 발생하는가?

  - (linux) vmstat 명령어를 사용하여 확인 가능
    - e.g. vmstat 1 3 : 1초 지연단위로 3줄의 출력을 제공한다

- 자발적 문맥 교환 vs 비자발적 문맥 교환
  - 자발적 문맥 교환(voluntary context switch) : 프로세스가 자신을 중단시키는 것
    - e.g. I/O를 기다리며 대기 상태로 전환
  - 비자발적 문맥 교환(involuntary context switch) : 프로세스가 자신을 중단시키지 않고 스케줄러에 의해 중단되는 것
    - e.g.
      - 시간 할당량(tiem slice)이 만료되어 대기 상태로 전환
      - 우선순위가 높은 프로세스가 낮은 우선순위 프로세스를 중단시키는 것

## 5.2 스케줄링 기준(Scheduling Criteria)
